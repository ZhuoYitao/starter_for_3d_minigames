{"version":3,"file":"layerSceneComponent.js","sourceRoot":"","sources":["../../../../../lts/core/generated/Layers/layerSceneComponent.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport type { Layer } from \"./layer\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { AbstractScene } from \"../abstractScene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * The list of layers (background and foreground) of the scene\r\n         */\r\n        layers: Array<Layer>;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines the layer scene component responsible to manage any layers\r\n * in a given scene.\r\n */\r\nexport class LayerSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_LAYER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    private _engine: Engine;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene?: Scene) {\r\n        this.scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        if (!this.scene) {\r\n            return;\r\n        }\r\n        this._engine = this.scene.getEngine();\r\n        this.scene.layers = new Array<Layer>();\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_LAYER, this, this._drawCameraBackground);\r\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_LAYER, this, this._drawCameraForeground);\r\n\r\n        this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_LAYER, this, this._drawRenderTargetBackground);\r\n        this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_LAYER, this, this._drawRenderTargetForeground);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        const layers = this.scene.layers;\r\n\r\n        for (const layer of layers) {\r\n            layer._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const layers = this.scene.layers;\r\n\r\n        while (layers.length) {\r\n            layers[0].dispose();\r\n        }\r\n    }\r\n\r\n    private _draw(predicate: (layer: Layer) => boolean): void {\r\n        const layers = this.scene.layers;\r\n\r\n        if (layers.length) {\r\n            this._engine.setDepthBuffer(false);\r\n            for (const layer of layers) {\r\n                if (predicate(layer)) {\r\n                    layer.render();\r\n                }\r\n            }\r\n            this._engine.setDepthBuffer(true);\r\n        }\r\n    }\r\n\r\n    private _drawCameraPredicate(layer: Layer, isBackground: boolean, cameraLayerMask: number): boolean {\r\n        return !layer.renderOnlyInRenderTargetTextures && layer.isBackground === isBackground && (layer.layerMask & cameraLayerMask) !== 0;\r\n    }\r\n\r\n    private _drawCameraBackground(camera: Camera): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawCameraPredicate(layer, true, camera.layerMask);\r\n        });\r\n    }\r\n\r\n    private _drawCameraForeground(camera: Camera): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawCameraPredicate(layer, false, camera.layerMask);\r\n        });\r\n    }\r\n\r\n    private _drawRenderTargetPredicate(layer: Layer, isBackground: boolean, cameraLayerMask: number, renderTargetTexture: RenderTargetTexture): boolean {\r\n        return (\r\n            layer.renderTargetTextures.length > 0 &&\r\n            layer.isBackground === isBackground &&\r\n            layer.renderTargetTextures.indexOf(renderTargetTexture) > -1 &&\r\n            (layer.layerMask & cameraLayerMask) !== 0\r\n        );\r\n    }\r\n\r\n    private _drawRenderTargetBackground(renderTarget: RenderTargetTexture): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawRenderTargetPredicate(layer, true, this.scene.activeCamera!.layerMask, renderTarget);\r\n        });\r\n    }\r\n\r\n    private _drawRenderTargetForeground(renderTarget: RenderTargetTexture): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawRenderTargetPredicate(layer, false, this.scene.activeCamera!.layerMask, renderTarget);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    public addFromContainer(container: AbstractScene): void {\r\n        if (!container.layers) {\r\n            return;\r\n        }\r\n        container.layers.forEach((layer) => {\r\n            this.scene.layers.push(layer);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    public removeFromContainer(container: AbstractScene, dispose = false): void {\r\n        if (!container.layers) {\r\n            return;\r\n        }\r\n        container.layers.forEach((layer) => {\r\n            const index = this.scene.layers.indexOf(layer);\r\n            if (index !== -1) {\r\n                this.scene.layers.splice(index, 1);\r\n            }\r\n            if (dispose) {\r\n                layer.dispose();\r\n            }\r\n        });\r\n    }\r\n}\r\n"]}