{"version":3,"file":"gizmo.js","sourceRoot":"","sources":["../../../../../lts/core/generated/Gizmos/gizmo.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Observer } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { WebVRFreeCamera } from \"../Cameras/VR/webVRCamera\";\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport { Quaternion, Vector3, Matrix } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { TargetCamera } from \"../Cameras/targetCamera\";\r\nimport type { Node } from \"../node\";\r\nimport type { Bone } from \"../Bones/bone\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport type { LinesMesh } from \"../Meshes/linesMesh\";\r\nimport type { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior\";\r\nimport type { ShadowLight } from \"../Lights/shadowLight\";\r\nimport { Light } from \"../Lights/light\";\r\n\r\n/**\r\n * Cache built by each axis. Used for managing state between all elements of gizmo for enhanced UI\r\n */\r\nexport interface GizmoAxisCache {\r\n    /** Mesh used to render the Gizmo */\r\n    gizmoMeshes: Mesh[];\r\n    /** Mesh used to detect user interaction with Gizmo */\r\n    colliderMeshes: Mesh[];\r\n    /** Material used to indicate color of gizmo mesh */\r\n    material: StandardMaterial;\r\n    /** Material used to indicate hover state of the Gizmo */\r\n    hoverMaterial: StandardMaterial;\r\n    /** Material used to indicate disabled state of the Gizmo */\r\n    disableMaterial: StandardMaterial;\r\n    /** Used to indicate Active state of the Gizmo */\r\n    active: boolean;\r\n    /** DragBehavior */\r\n    dragBehavior: PointerDragBehavior;\r\n}\r\n/**\r\n * Renders gizmos on top of an existing scene which provide controls for position, rotation, etc.\r\n */\r\nexport class Gizmo implements IDisposable {\r\n    /**\r\n     * The root mesh of the gizmo\r\n     */\r\n    public _rootMesh: Mesh;\r\n    private _attachedMesh: Nullable<AbstractMesh> = null;\r\n    private _attachedNode: Nullable<Node> = null;\r\n    private _customRotationQuaternion: Nullable<Quaternion> = null;\r\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\r\n    protected _scaleRatio = 1;\r\n\r\n    /**\r\n     * boolean updated by pointermove when a gizmo mesh is hovered\r\n     */\r\n    protected _isHovered = false;\r\n\r\n    /**\r\n     * When enabled, any gizmo operation will perserve scaling sign. Default is off.\r\n     * Only valid for TransformNode derived classes (Mesh, AbstractMesh, ...)\r\n     */\r\n    public static PreserveScaling = false;\r\n\r\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\r\n    public set scaleRatio(value: number) {\r\n        this._scaleRatio = value;\r\n    }\r\n\r\n    public get scaleRatio() {\r\n        return this._scaleRatio;\r\n    }\r\n\r\n    /**\r\n     * True when the mouse pointer is hovered a gizmo mesh\r\n     */\r\n    public get isHovered() {\r\n        return this._isHovered;\r\n    }\r\n\r\n    /**\r\n     * If a custom mesh has been set (Default: false)\r\n     */\r\n    protected _customMeshSet = false;\r\n    /**\r\n     * Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\r\n    public get attachedMesh() {\r\n        return this._attachedMesh;\r\n    }\r\n    public set attachedMesh(value) {\r\n        this._attachedMesh = value;\r\n        if (value) {\r\n            this._attachedNode = value;\r\n        }\r\n        this._rootMesh.setEnabled(value ? true : false);\r\n        this._attachedNodeChanged(value);\r\n    }\r\n    /**\r\n     * Node that the gizmo will be attached to. (eg. on a drag gizmo the mesh, bone or NodeTransform that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\r\n    public get attachedNode() {\r\n        return this._attachedNode;\r\n    }\r\n    public set attachedNode(value) {\r\n        this._attachedNode = value;\r\n        this._attachedMesh = null;\r\n        this._rootMesh.setEnabled(value ? true : false);\r\n        this._attachedNodeChanged(value);\r\n    }\r\n\r\n    /**\r\n     * Disposes and replaces the current meshes in the gizmo with the specified mesh\r\n     * @param mesh The mesh to replace the default mesh of the gizmo\r\n     */\r\n    public setCustomMesh(mesh: Mesh) {\r\n        if (mesh.getScene() != this.gizmoLayer.utilityLayerScene) {\r\n            throw \"When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)\";\r\n        }\r\n        this._rootMesh.getChildMeshes().forEach((c) => {\r\n            c.dispose();\r\n        });\r\n        mesh.parent = this._rootMesh;\r\n        this._customMeshSet = true;\r\n    }\r\n\r\n    protected _updateGizmoRotationToMatchAttachedMesh = true;\r\n\r\n    /**\r\n     * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\r\n     */\r\n    public set updateGizmoRotationToMatchAttachedMesh(value: boolean) {\r\n        this._updateGizmoRotationToMatchAttachedMesh = value;\r\n    }\r\n    public get updateGizmoRotationToMatchAttachedMesh() {\r\n        return this._updateGizmoRotationToMatchAttachedMesh;\r\n    }\r\n    /**\r\n     * If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)\r\n     */\r\n    public updateGizmoPositionToMatchAttachedMesh = true;\r\n    /**\r\n     * When set, the gizmo will always appear the same size no matter where the camera is (default: true)\r\n     */\r\n    public updateScale = true;\r\n    protected _interactionsEnabled = true;\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _attachedNodeChanged(value: Nullable<Node>) {}\r\n\r\n    private _beforeRenderObserver: Nullable<Observer<Scene>>;\r\n    private _tempQuaternion = new Quaternion(0, 0, 0, 1);\r\n    private _tempVector = new Vector3();\r\n    private _tempVector2 = new Vector3();\r\n    private _tempMatrix1 = new Matrix();\r\n    private _tempMatrix2 = new Matrix();\r\n    private _rightHandtoLeftHandMatrix = Matrix.RotationY(Math.PI);\r\n\r\n    /**\r\n     * Creates a gizmo\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     */\r\n    constructor(\r\n        /** The utility layer the gizmo will be added to */\r\n        public gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer\r\n    ) {\r\n        this._rootMesh = new Mesh(\"gizmoRootNode\", gizmoLayer.utilityLayerScene);\r\n        this._rootMesh.rotationQuaternion = Quaternion.Identity();\r\n\r\n        this._beforeRenderObserver = this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.add(() => {\r\n            this._update();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * posture that the gizmo will be display\r\n     * When set null, default value will be used (Quaternion(0, 0, 0, 1))\r\n     */\r\n    public get customRotationQuaternion(): Nullable<Quaternion> {\r\n        return this._customRotationQuaternion;\r\n    }\r\n\r\n    public set customRotationQuaternion(customRotationQuaternion: Nullable<Quaternion>) {\r\n        this._customRotationQuaternion = customRotationQuaternion;\r\n    }\r\n\r\n    /**\r\n     * Updates the gizmo to match the attached mesh's position/rotation\r\n     */\r\n    protected _update() {\r\n        if (this.attachedNode) {\r\n            let effectiveNode = this.attachedNode;\r\n            if (this.attachedMesh) {\r\n                effectiveNode = this.attachedMesh || this.attachedNode;\r\n            }\r\n\r\n            // Position\r\n            if (this.updateGizmoPositionToMatchAttachedMesh) {\r\n                const row = effectiveNode.getWorldMatrix().getRow(3);\r\n                const position = row ? row.toVector3() : new Vector3(0, 0, 0);\r\n                this._rootMesh.position.copyFrom(position);\r\n            }\r\n\r\n            // Rotation\r\n            if (this.updateGizmoRotationToMatchAttachedMesh) {\r\n                const transformNode = (<Mesh>effectiveNode)._isMesh ? (effectiveNode as TransformNode) : undefined;\r\n                effectiveNode.getWorldMatrix().decompose(undefined, this._rootMesh.rotationQuaternion!, undefined, Gizmo.PreserveScaling ? transformNode : undefined);\r\n            } else {\r\n                if (this._customRotationQuaternion) {\r\n                    this._rootMesh.rotationQuaternion!.copyFrom(this._customRotationQuaternion);\r\n                } else {\r\n                    this._rootMesh.rotationQuaternion!.set(0, 0, 0, 1);\r\n                }\r\n            }\r\n\r\n            // Scale\r\n            if (this.updateScale) {\r\n                const activeCamera = this.gizmoLayer.utilityLayerScene.activeCamera!;\r\n                let cameraPosition = activeCamera.globalPosition;\r\n                if ((<WebVRFreeCamera>activeCamera).devicePosition) {\r\n                    cameraPosition = (<WebVRFreeCamera>activeCamera).devicePosition;\r\n                }\r\n                this._rootMesh.position.subtractToRef(cameraPosition, this._tempVector);\r\n                const dist = this._tempVector.length() * this.scaleRatio;\r\n                this._rootMesh.scaling.set(dist, dist, dist);\r\n\r\n                // Account for handedness, similar to Matrix.decompose\r\n                if (effectiveNode._getWorldMatrixDeterminant() < 0 && !Gizmo.PreserveScaling) {\r\n                    this._rootMesh.scaling.y *= -1;\r\n                }\r\n            } else {\r\n                this._rootMesh.scaling.setAll(this.scaleRatio);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle position/translation when using an attached node using pivot\r\n     */\r\n    protected _handlePivot() {\r\n        const attachedNodeTransform = this._attachedNode as any;\r\n        // check there is an active pivot for the TransformNode attached\r\n        if (attachedNodeTransform.isUsingPivotMatrix && attachedNodeTransform.isUsingPivotMatrix() && attachedNodeTransform.position) {\r\n            // When a TransformNode has an active pivot, even without parenting,\r\n            // translation from the world matrix is different from TransformNode.position.\r\n            // Pivot works like a virtual parent that's using the node orientation.\r\n            // As the world matrix is transformed by the gizmo and then decomposed to TRS\r\n            // its translation part must be set to the Node's position.\r\n            attachedNodeTransform.getWorldMatrix().setTranslation(attachedNodeTransform.position);\r\n        }\r\n    }\r\n    /**\r\n     * computes the rotation/scaling/position of the transform once the Node world matrix has changed.\r\n     */\r\n    protected _matrixChanged() {\r\n        if (!this._attachedNode) {\r\n            return;\r\n        }\r\n\r\n        if ((<Camera>this._attachedNode)._isCamera) {\r\n            const camera = this._attachedNode as Camera;\r\n            let worldMatrix;\r\n            let worldMatrixUC;\r\n            if (camera.parent) {\r\n                const parentInv = this._tempMatrix2;\r\n                camera.parent._worldMatrix.invertToRef(parentInv);\r\n                this._attachedNode._worldMatrix.multiplyToRef(parentInv, this._tempMatrix1);\r\n                worldMatrix = this._tempMatrix1;\r\n            } else {\r\n                worldMatrix = this._attachedNode._worldMatrix;\r\n            }\r\n\r\n            if (camera.getScene().useRightHandedSystem) {\r\n                // avoid desync with RH matrix computation. Otherwise, rotation of PI around Y axis happens each frame resulting in axis flipped because worldMatrix is computed as inverse of viewMatrix.\r\n                this._rightHandtoLeftHandMatrix.multiplyToRef(worldMatrix, this._tempMatrix2);\r\n                worldMatrixUC = this._tempMatrix2;\r\n            } else {\r\n                worldMatrixUC = worldMatrix;\r\n            }\r\n\r\n            worldMatrixUC.decompose(this._tempVector2, this._tempQuaternion, this._tempVector);\r\n\r\n            const inheritsTargetCamera =\r\n                this._attachedNode.getClassName() === \"FreeCamera\" ||\r\n                this._attachedNode.getClassName() === \"FlyCamera\" ||\r\n                this._attachedNode.getClassName() === \"ArcFollowCamera\" ||\r\n                this._attachedNode.getClassName() === \"TargetCamera\" ||\r\n                this._attachedNode.getClassName() === \"TouchCamera\" ||\r\n                this._attachedNode.getClassName() === \"UniversalCamera\";\r\n\r\n            if (inheritsTargetCamera) {\r\n                const targetCamera = this._attachedNode as TargetCamera;\r\n                targetCamera.rotation = this._tempQuaternion.toEulerAngles();\r\n\r\n                if (targetCamera.rotationQuaternion) {\r\n                    targetCamera.rotationQuaternion.copyFrom(this._tempQuaternion);\r\n                    targetCamera.rotationQuaternion.normalize();\r\n                }\r\n            }\r\n\r\n            camera.position.copyFrom(this._tempVector);\r\n        } else if (\r\n            (<Mesh>this._attachedNode)._isMesh ||\r\n            this._attachedNode.getClassName() === \"AbstractMesh\" ||\r\n            this._attachedNode.getClassName() === \"TransformNode\" ||\r\n            this._attachedNode.getClassName() === \"InstancedMesh\"\r\n        ) {\r\n            const transform = this._attachedNode as TransformNode;\r\n            if (transform.parent) {\r\n                const parentInv = this._tempMatrix1;\r\n                const localMat = this._tempMatrix2;\r\n                transform.parent.getWorldMatrix().invertToRef(parentInv);\r\n                this._attachedNode.getWorldMatrix().multiplyToRef(parentInv, localMat);\r\n                localMat.decompose(this._tempVector, this._tempQuaternion, transform.position, Gizmo.PreserveScaling ? transform : undefined);\r\n            } else {\r\n                this._attachedNode._worldMatrix.decompose(this._tempVector, this._tempQuaternion, transform.position, Gizmo.PreserveScaling ? transform : undefined);\r\n            }\r\n            transform.scaling.copyFrom(this._tempVector);\r\n            if (!transform.billboardMode) {\r\n                if (transform.rotationQuaternion) {\r\n                    transform.rotationQuaternion.copyFrom(this._tempQuaternion);\r\n                    transform.rotationQuaternion.normalize();\r\n                } else {\r\n                    transform.rotation = this._tempQuaternion.toEulerAngles();\r\n                }\r\n            }\r\n        } else if (this._attachedNode.getClassName() === \"Bone\") {\r\n            const bone = this._attachedNode as Bone;\r\n            const parent = bone.getParent();\r\n\r\n            if (parent) {\r\n                const invParent = this._tempMatrix1;\r\n                const boneLocalMatrix = this._tempMatrix2;\r\n                parent.getWorldMatrix().invertToRef(invParent);\r\n                bone.getWorldMatrix().multiplyToRef(invParent, boneLocalMatrix);\r\n                const lmat = bone.getLocalMatrix();\r\n                lmat.copyFrom(boneLocalMatrix);\r\n            } else {\r\n                const lmat = bone.getLocalMatrix();\r\n                lmat.copyFrom(bone.getWorldMatrix());\r\n            }\r\n            bone.markAsDirty();\r\n        } else {\r\n            const light = this._attachedNode as ShadowLight;\r\n            if (light.getTypeID) {\r\n                const type = light.getTypeID();\r\n                if (type === Light.LIGHTTYPEID_DIRECTIONALLIGHT || type === Light.LIGHTTYPEID_SPOTLIGHT || type === Light.LIGHTTYPEID_POINTLIGHT) {\r\n                    const parent = light.parent;\r\n\r\n                    if (parent) {\r\n                        const invParent = this._tempMatrix1;\r\n                        const nodeLocalMatrix = this._tempMatrix2;\r\n                        parent.getWorldMatrix().invertToRef(invParent);\r\n                        light.getWorldMatrix().multiplyToRef(invParent, nodeLocalMatrix);\r\n                        nodeLocalMatrix.decompose(undefined, this._tempQuaternion, this._tempVector);\r\n                    } else {\r\n                        this._attachedNode._worldMatrix.decompose(undefined, this._tempQuaternion, this._tempVector);\r\n                    }\r\n                    // setter doesn't copy values. Need a new Vector3\r\n                    light.position = new Vector3(this._tempVector.x, this._tempVector.y, this._tempVector.z);\r\n                    light.direction = new Vector3(light.direction.x, light.direction.y, light.direction.z);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * refresh gizmo mesh material\r\n     * @param gizmoMeshes\r\n     * @param material material to apply\r\n     */\r\n    protected _setGizmoMeshMaterial(gizmoMeshes: Mesh[], material: StandardMaterial) {\r\n        if (gizmoMeshes) {\r\n            gizmoMeshes.forEach((m: Mesh) => {\r\n                m.material = material;\r\n                if ((<LinesMesh>m).color) {\r\n                    (<LinesMesh>m).color = material.diffuseColor;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Subscribes to pointer up, down, and hover events. Used for responsive gizmos.\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI\r\n     * @returns {Observer<PointerInfo>} pointerObserver\r\n     */\r\n    public static GizmoAxisPointerObserver(gizmoLayer: UtilityLayerRenderer, gizmoAxisCache: Map<Mesh, GizmoAxisCache>): Observer<PointerInfo> {\r\n        let dragging = false;\r\n\r\n        const pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {\r\n            if (pointerInfo.pickInfo) {\r\n                // On Hover Logic\r\n                if (pointerInfo.type === PointerEventTypes.POINTERMOVE) {\r\n                    if (dragging) {\r\n                        return;\r\n                    }\r\n                    gizmoAxisCache.forEach((cache) => {\r\n                        if (cache.colliderMeshes && cache.gizmoMeshes) {\r\n                            const isHovered = cache.colliderMeshes?.indexOf(pointerInfo?.pickInfo?.pickedMesh as Mesh) != -1;\r\n                            const material = cache.dragBehavior.enabled ? (isHovered || cache.active ? cache.hoverMaterial : cache.material) : cache.disableMaterial;\r\n                            cache.gizmoMeshes.forEach((m: Mesh) => {\r\n                                m.material = material;\r\n                                if ((m as LinesMesh).color) {\r\n                                    (m as LinesMesh).color = material.diffuseColor;\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n\r\n                // On Mouse Down\r\n                if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                    // If user Clicked Gizmo\r\n                    if (gizmoAxisCache.has(pointerInfo.pickInfo.pickedMesh?.parent as Mesh)) {\r\n                        dragging = true;\r\n                        const statusMap = gizmoAxisCache.get(pointerInfo.pickInfo.pickedMesh?.parent as Mesh);\r\n                        statusMap!.active = true;\r\n                        gizmoAxisCache.forEach((cache) => {\r\n                            const isHovered = cache.colliderMeshes?.indexOf(pointerInfo?.pickInfo?.pickedMesh as Mesh) != -1;\r\n                            const material = (isHovered || cache.active) && cache.dragBehavior.enabled ? cache.hoverMaterial : cache.disableMaterial;\r\n                            cache.gizmoMeshes.forEach((m: Mesh) => {\r\n                                m.material = material;\r\n                                if ((m as LinesMesh).color) {\r\n                                    (m as LinesMesh).color = material.diffuseColor;\r\n                                }\r\n                            });\r\n                        });\r\n                    }\r\n                }\r\n\r\n                // On Mouse Up\r\n                if (pointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                    gizmoAxisCache.forEach((cache) => {\r\n                        cache.active = false;\r\n                        dragging = false;\r\n                        cache.gizmoMeshes.forEach((m: Mesh) => {\r\n                            m.material = cache.dragBehavior.enabled ? cache.material : cache.disableMaterial;\r\n                            if ((m as LinesMesh).color) {\r\n                                (m as LinesMesh).color = cache.material.diffuseColor;\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n            }\r\n        });\r\n\r\n        return pointerObserver!;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the gizmo\r\n     */\r\n    public dispose() {\r\n        this._rootMesh.dispose();\r\n        if (this._beforeRenderObserver) {\r\n            this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.remove(this._beforeRenderObserver);\r\n        }\r\n    }\r\n}\r\n"]}