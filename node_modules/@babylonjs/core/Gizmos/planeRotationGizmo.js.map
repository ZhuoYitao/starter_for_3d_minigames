{"version":3,"file":"planeRotationGizmo.js","sourceRoot":"","sources":["../../../../../lts/core/generated/Gizmos/planeRotationGizmo.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport { Quaternion, Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport \"../Meshes/Builders/linesBuilder\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { Node } from \"../node\";\r\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior\";\r\nimport type { GizmoAxisCache } from \"./gizmo\";\r\nimport { Gizmo } from \"./gizmo\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport type { RotationGizmo } from \"./rotationGizmo\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { CreatePlane } from \"../Meshes/Builders/planeBuilder\";\r\nimport { CreateTorus } from \"../Meshes/Builders/torusBuilder\";\r\n\r\n/**\r\n * Single plane rotation gizmo\r\n */\r\nexport class PlaneRotationGizmo extends Gizmo {\r\n    /**\r\n     * Drag behavior responsible for the gizmos dragging interactions\r\n     */\r\n    public dragBehavior: PointerDragBehavior;\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>> = null;\r\n\r\n    /**\r\n     * Rotation distance in radians that the gizmo will snap to (Default: 0)\r\n     */\r\n    public snapDistance = 0;\r\n    /**\r\n     * Event that fires each time the gizmo snaps to a new location.\r\n     * * snapDistance is the the change in distance\r\n     */\r\n    public onSnapObservable = new Observable<{ snapDistance: number }>();\r\n\r\n    /**\r\n     * The maximum angle between the camera and the rotation allowed for interaction\r\n     * If a rotation plane appears 'flat', a lower value allows interaction.\r\n     */\r\n    public static MaxDragAngle: number = (Math.PI * 9) / 20;\r\n\r\n    /**\r\n     * Accumulated relative angle value for rotation on the axis. Reset to 0 when a dragStart occurs\r\n     */\r\n    public angle: number = 0;\r\n\r\n    private _isEnabled: boolean = true;\r\n    private _parent: Nullable<RotationGizmo> = null;\r\n    private _coloredMaterial: StandardMaterial;\r\n    private _hoverMaterial: StandardMaterial;\r\n    private _disableMaterial: StandardMaterial;\r\n    private _gizmoMesh: Mesh;\r\n    private _rotationDisplayPlane: Mesh;\r\n    private _dragging: boolean = false;\r\n    private _angles = new Vector3();\r\n\r\n    private static _RotationGizmoVertexShader = `\r\n        precision highp float;\r\n        attribute vec3 position;\r\n        attribute vec2 uv;\r\n        uniform mat4 worldViewProjection;\r\n        varying vec3 vPosition;\r\n        varying vec2 vUV;\r\n        void main(void) {\r\n            gl_Position = worldViewProjection * vec4(position, 1.0);\r\n            vUV = uv;\r\n        }`;\r\n\r\n    private static _RotationGizmoFragmentShader = `\r\n        precision highp float;\r\n        varying vec2 vUV;\r\n        varying vec3 vPosition;\r\n        uniform vec3 angles;\r\n        #define twopi 6.283185307\r\n        void main(void) {\r\n            vec2 uv = vUV - vec2(0.5);\r\n            float angle = atan(uv.y, uv.x) + 3.141592;\r\n            float delta = gl_FrontFacing ? angles.y : -angles.y;\r\n            float begin = angles.x - delta * angles.z;\r\n            float start = (begin < (begin + delta)) ? begin : (begin + delta);\r\n            float end = (begin > (begin + delta)) ? begin : (begin + delta);\r\n            float len = sqrt(dot(uv,uv));\r\n            float opacity = 1. - step(0.5, len);\r\n\r\n            float base = abs(floor(start / twopi)) * twopi;\r\n            start += base;\r\n            end += base;\r\n\r\n            float intensity = 0.;\r\n            for (int i = 0; i < 5; i++)\r\n            {\r\n                intensity += max(step(start, angle) - step(end, angle), 0.);\r\n                angle += twopi;\r\n            }\r\n            gl_FragColor = vec4(1.,1.,0., min(intensity * 0.25, 0.8)) * opacity;\r\n        }`;\r\n\r\n    private _rotationShaderMaterial: ShaderMaterial;\r\n\r\n    /**\r\n     * Creates a PlaneRotationGizmo\r\n     * @param planeNormal The normal of the plane which the gizmo will be able to rotate on\r\n     * @param color The color of the gizmo\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     * @param tessellation Amount of tessellation to be used when creating rotation circles\r\n     * @param parent\r\n     * @param useEulerRotation Use and update Euler angle instead of quaternion\r\n     * @param thickness display gizmo axis thickness\r\n     */\r\n    constructor(\r\n        planeNormal: Vector3,\r\n        color: Color3 = Color3.Gray(),\r\n        gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer,\r\n        tessellation = 32,\r\n        parent: Nullable<RotationGizmo> = null,\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        useEulerRotation = false,\r\n        thickness: number = 1\r\n    ) {\r\n        super(gizmoLayer);\r\n        this._parent = parent;\r\n        // Create Material\r\n        this._coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\r\n        this._coloredMaterial.diffuseColor = color;\r\n        this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));\r\n\r\n        this._hoverMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\r\n        this._hoverMaterial.diffuseColor = Color3.Yellow();\r\n\r\n        this._disableMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\r\n        this._disableMaterial.diffuseColor = Color3.Gray();\r\n        this._disableMaterial.alpha = 0.4;\r\n\r\n        // Build mesh on root node\r\n        this._gizmoMesh = new Mesh(\"\", gizmoLayer.utilityLayerScene);\r\n        const { rotationMesh, collider } = this._createGizmoMesh(this._gizmoMesh, thickness, tessellation);\r\n\r\n        // Setup Rotation Circle\r\n        this._rotationDisplayPlane = CreatePlane(\"rotationDisplay\", { size: 0.6, updatable: false }, this.gizmoLayer.utilityLayerScene);\r\n        this._rotationDisplayPlane.rotation.z = Math.PI * 0.5;\r\n        this._rotationDisplayPlane.parent = this._gizmoMesh;\r\n        this._rotationDisplayPlane.setEnabled(false);\r\n\r\n        Effect.ShadersStore[\"rotationGizmoVertexShader\"] = PlaneRotationGizmo._RotationGizmoVertexShader;\r\n        Effect.ShadersStore[\"rotationGizmoFragmentShader\"] = PlaneRotationGizmo._RotationGizmoFragmentShader;\r\n        this._rotationShaderMaterial = new ShaderMaterial(\r\n            \"shader\",\r\n            this.gizmoLayer.utilityLayerScene,\r\n            {\r\n                vertex: \"rotationGizmo\",\r\n                fragment: \"rotationGizmo\",\r\n            },\r\n            {\r\n                attributes: [\"position\", \"uv\"],\r\n                uniforms: [\"worldViewProjection\", \"angles\"],\r\n            }\r\n        );\r\n        this._rotationShaderMaterial.backFaceCulling = false;\r\n\r\n        this._rotationDisplayPlane.material = this._rotationShaderMaterial;\r\n        this._rotationDisplayPlane.visibility = 0.999;\r\n\r\n        this._gizmoMesh.lookAt(this._rootMesh.position.add(planeNormal));\r\n        this._rootMesh.addChild(this._gizmoMesh, Gizmo.PreserveScaling);\r\n        this._gizmoMesh.scaling.scaleInPlace(1 / 3);\r\n        // Add drag behavior to handle events when the gizmo is dragged\r\n        this.dragBehavior = new PointerDragBehavior({ dragPlaneNormal: planeNormal });\r\n        this.dragBehavior.moveAttached = false;\r\n        this.dragBehavior.maxDragAngle = PlaneRotationGizmo.MaxDragAngle;\r\n        this.dragBehavior._useAlternatePickedPointAboveMaxDragAngle = true;\r\n        this._rootMesh.addBehavior(this.dragBehavior);\r\n\r\n        // Closures for drag logic\r\n        const lastDragPosition = new Vector3();\r\n\r\n        const rotationMatrix = new Matrix();\r\n        const planeNormalTowardsCamera = new Vector3();\r\n        let localPlaneNormalTowardsCamera = new Vector3();\r\n\r\n        this.dragBehavior.onDragStartObservable.add((e) => {\r\n            if (this.attachedNode) {\r\n                lastDragPosition.copyFrom(e.dragPlanePoint);\r\n                this._rotationDisplayPlane.setEnabled(true);\r\n\r\n                this._rotationDisplayPlane.getWorldMatrix().invertToRef(rotationMatrix);\r\n                Vector3.TransformCoordinatesToRef(e.dragPlanePoint, rotationMatrix, lastDragPosition);\r\n\r\n                this._angles.x = Math.atan2(lastDragPosition.y, lastDragPosition.x) + Math.PI;\r\n                this._angles.y = 0;\r\n                this._angles.z = this.updateGizmoRotationToMatchAttachedMesh ? 1 : 0;\r\n                this._dragging = true;\r\n                lastDragPosition.copyFrom(e.dragPlanePoint);\r\n                this._rotationShaderMaterial.setVector3(\"angles\", this._angles);\r\n                this.angle = 0;\r\n            }\r\n        });\r\n\r\n        this.dragBehavior.onDragEndObservable.add(() => {\r\n            this._dragging = false;\r\n            this._rotationDisplayPlane.setEnabled(false);\r\n        });\r\n\r\n        const tmpSnapEvent = { snapDistance: 0 };\r\n        let currentSnapDragDistance = 0;\r\n        const tmpMatrix = new Matrix();\r\n        const amountToRotate = new Quaternion();\r\n        this.dragBehavior.onDragObservable.add((event) => {\r\n            if (this.attachedNode) {\r\n                // Calc angle over full 360 degree (https://stackoverflow.com/questions/43493711/the-angle-between-two-3d-vectors-with-a-result-range-0-360)\r\n                const nodeScale = new Vector3(1, 1, 1);\r\n                const nodeQuaternion = new Quaternion(0, 0, 0, 1);\r\n                const nodeTranslation = new Vector3(0, 0, 0);\r\n                this._handlePivot();\r\n                this.attachedNode.getWorldMatrix().decompose(nodeScale, nodeQuaternion, nodeTranslation);\r\n\r\n                const newVector = event.dragPlanePoint.subtract(nodeTranslation).normalize();\r\n                const originalVector = lastDragPosition.subtract(nodeTranslation).normalize();\r\n                const cross = Vector3.Cross(newVector, originalVector);\r\n                const dot = Vector3.Dot(newVector, originalVector);\r\n                let angle = Math.atan2(cross.length(), dot);\r\n                planeNormalTowardsCamera.copyFrom(planeNormal);\r\n                localPlaneNormalTowardsCamera.copyFrom(planeNormal);\r\n                if (this.updateGizmoRotationToMatchAttachedMesh) {\r\n                    nodeQuaternion.toRotationMatrix(rotationMatrix);\r\n                    localPlaneNormalTowardsCamera = Vector3.TransformCoordinates(planeNormalTowardsCamera, rotationMatrix);\r\n                }\r\n                // Flip up vector depending on which side the camera is on\r\n                let cameraFlipped = false;\r\n                if (gizmoLayer.utilityLayerScene.activeCamera) {\r\n                    const camVec = gizmoLayer.utilityLayerScene.activeCamera.position.subtract(nodeTranslation).normalize();\r\n                    if (Vector3.Dot(camVec, localPlaneNormalTowardsCamera) > 0) {\r\n                        planeNormalTowardsCamera.scaleInPlace(-1);\r\n                        localPlaneNormalTowardsCamera.scaleInPlace(-1);\r\n                        cameraFlipped = true;\r\n                    }\r\n                }\r\n                const halfCircleSide = Vector3.Dot(localPlaneNormalTowardsCamera, cross) > 0.0;\r\n                if (halfCircleSide) {\r\n                    angle = -angle;\r\n                }\r\n\r\n                // Snapping logic\r\n                let snapped = false;\r\n                if (this.snapDistance != 0) {\r\n                    currentSnapDragDistance += angle;\r\n                    if (Math.abs(currentSnapDragDistance) > this.snapDistance) {\r\n                        let dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / this.snapDistance);\r\n                        if (currentSnapDragDistance < 0) {\r\n                            dragSteps *= -1;\r\n                        }\r\n                        currentSnapDragDistance = currentSnapDragDistance % this.snapDistance;\r\n                        angle = this.snapDistance * dragSteps;\r\n                        snapped = true;\r\n                    } else {\r\n                        angle = 0;\r\n                    }\r\n                }\r\n\r\n                // Convert angle and axis to quaternion (http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm)\r\n                const quaternionCoefficient = Math.sin(angle / 2);\r\n                amountToRotate.set(\r\n                    planeNormalTowardsCamera.x * quaternionCoefficient,\r\n                    planeNormalTowardsCamera.y * quaternionCoefficient,\r\n                    planeNormalTowardsCamera.z * quaternionCoefficient,\r\n                    Math.cos(angle / 2)\r\n                );\r\n\r\n                // If the meshes local scale is inverted (eg. loaded gltf file parent with z scale of -1) the rotation needs to be inverted on the y axis\r\n                if (tmpMatrix.determinant() > 0) {\r\n                    const tmpVector = new Vector3();\r\n                    amountToRotate.toEulerAnglesToRef(tmpVector);\r\n                    Quaternion.RotationYawPitchRollToRef(tmpVector.y, -tmpVector.x, -tmpVector.z, amountToRotate);\r\n                }\r\n\r\n                if (this.updateGizmoRotationToMatchAttachedMesh) {\r\n                    // Rotate selected mesh quaternion over fixed axis\r\n                    nodeQuaternion.multiplyToRef(amountToRotate, nodeQuaternion);\r\n                } else {\r\n                    // Rotate selected mesh quaternion over rotated axis\r\n                    amountToRotate.multiplyToRef(nodeQuaternion, nodeQuaternion);\r\n                }\r\n\r\n                // recompose matrix\r\n                this.attachedNode.getWorldMatrix().copyFrom(Matrix.Compose(nodeScale, nodeQuaternion, nodeTranslation));\r\n\r\n                lastDragPosition.copyFrom(event.dragPlanePoint);\r\n                if (snapped) {\r\n                    tmpSnapEvent.snapDistance = angle;\r\n                    this.onSnapObservable.notifyObservers(tmpSnapEvent);\r\n                }\r\n                this._angles.y += angle;\r\n                this.angle += cameraFlipped ? -angle : angle;\r\n                this._rotationShaderMaterial.setVector3(\"angles\", this._angles);\r\n                this._matrixChanged();\r\n            }\r\n        });\r\n\r\n        const light = gizmoLayer._getSharedGizmoLight();\r\n        light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._rootMesh.getChildMeshes(false));\r\n\r\n        const cache: GizmoAxisCache = {\r\n            colliderMeshes: [collider],\r\n            gizmoMeshes: [rotationMesh],\r\n            material: this._coloredMaterial,\r\n            hoverMaterial: this._hoverMaterial,\r\n            disableMaterial: this._disableMaterial,\r\n            active: false,\r\n            dragBehavior: this.dragBehavior,\r\n        };\r\n        this._parent?.addToAxisCache(this._gizmoMesh, cache);\r\n\r\n        this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {\r\n            if (this._customMeshSet) {\r\n                return;\r\n            }\r\n            // updating here the maxangle because ondragstart is too late (value already used) and the updated value is not taken into account\r\n            this.dragBehavior.maxDragAngle = PlaneRotationGizmo.MaxDragAngle;\r\n            this._isHovered = !!(cache.colliderMeshes.indexOf(<Mesh>pointerInfo?.pickInfo?.pickedMesh) != -1);\r\n            if (!this._parent) {\r\n                const material = cache.dragBehavior.enabled ? (this._isHovered || this._dragging ? this._hoverMaterial : this._coloredMaterial) : this._disableMaterial;\r\n                this._setGizmoMeshMaterial(cache.gizmoMeshes, material);\r\n            }\r\n        });\r\n\r\n        this.dragBehavior.onEnabledObservable.add((newState) => {\r\n            this._setGizmoMeshMaterial(cache.gizmoMeshes, newState ? this._coloredMaterial : this._disableMaterial);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create Geometry for Gizmo\r\n     * @param parentMesh\r\n     * @param thickness\r\n     * @param tessellation\r\n     */\r\n    private _createGizmoMesh(parentMesh: AbstractMesh, thickness: number, tessellation: number) {\r\n        const collider = CreateTorus(\r\n            \"ignore\",\r\n            {\r\n                diameter: 0.6,\r\n                thickness: 0.03 * thickness,\r\n                tessellation,\r\n            },\r\n            this.gizmoLayer.utilityLayerScene\r\n        );\r\n        collider.visibility = 0;\r\n        const rotationMesh = CreateTorus(\r\n            \"\",\r\n            {\r\n                diameter: 0.6,\r\n                thickness: 0.005 * thickness,\r\n                tessellation,\r\n            },\r\n            this.gizmoLayer.utilityLayerScene\r\n        );\r\n        rotationMesh.material = this._coloredMaterial;\r\n\r\n        // Position arrow pointing in its drag axis\r\n        rotationMesh.rotation.x = Math.PI / 2;\r\n        collider.rotation.x = Math.PI / 2;\r\n\r\n        parentMesh.addChild(rotationMesh, Gizmo.PreserveScaling);\r\n        parentMesh.addChild(collider, Gizmo.PreserveScaling);\r\n        return { rotationMesh, collider };\r\n    }\r\n\r\n    protected _attachedNodeChanged(value: Nullable<Node>) {\r\n        if (this.dragBehavior) {\r\n            this.dragBehavior.enabled = value ? true : false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If the gizmo is enabled\r\n     */\r\n    public set isEnabled(value: boolean) {\r\n        this._isEnabled = value;\r\n        if (!value) {\r\n            this.attachedMesh = null;\r\n        } else {\r\n            if (this._parent) {\r\n                this.attachedMesh = this._parent.attachedMesh;\r\n            }\r\n        }\r\n    }\r\n    public get isEnabled(): boolean {\r\n        return this._isEnabled;\r\n    }\r\n    /**\r\n     * Disposes of the gizmo\r\n     */\r\n    public dispose() {\r\n        this.onSnapObservable.clear();\r\n        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\r\n        this.dragBehavior.detach();\r\n        if (this._gizmoMesh) {\r\n            this._gizmoMesh.dispose();\r\n        }\r\n        if (this._rotationDisplayPlane) {\r\n            this._rotationDisplayPlane.dispose();\r\n        }\r\n        if (this._rotationShaderMaterial) {\r\n            this._rotationShaderMaterial.dispose();\r\n        }\r\n        [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach((matl) => {\r\n            if (matl) {\r\n                matl.dispose();\r\n            }\r\n        });\r\n        super.dispose();\r\n    }\r\n}\r\n"]}