{"version":3,"file":"screenSpaceReflection.fragment.js","sourceRoot":"","sources":["../../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts"],"names":[],"mappings":"AAAA,eAAe;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AAErD,IAAM,IAAI,GAAG,kCAAkC,CAAC;AAChD,IAAM,MAAM,GAAG,khIAqId,CAAC;AACF,aAAa;AACb,WAAW,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AACxC,cAAc;AACd,MAAM,CAAC,IAAM,gCAAgC,GAAG,EAAE,IAAI,MAAA,EAAE,MAAM,QAAA,EAAE,CAAC","sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"screenSpaceReflectionPixelShader\";\nconst shader = `uniform sampler2D textureSampler;\r#ifdef SSR_SUPPORTED\nuniform sampler2D reflectivitySampler;\runiform sampler2D normalSampler;\runiform sampler2D positionSampler;\r#endif\nuniform mat4 view;\runiform mat4 projection;\runiform float stepSize;\runiform float strength;\runiform float threshold;\runiform float roughnessFactor;\runiform float reflectionSpecularFalloffExponent;\rvarying vec2 vUV;\r#ifdef SSR_SUPPORTED\nstruct ReflectionInfo {\rvec3 color;\rvec4 coords;\r};\r/**\r* According to specular,see https:\r*/\rvec3 fresnelSchlick(float cosTheta,vec3 F0)\r{\rreturn F0+(1.0-F0)*pow(1.0-cosTheta,5.0);\r}\r/**\r* Once the pixel's coordinates has been found,let's adjust (smooth) a little bit\r* by sampling multiple reflection pixels.\r*/\rReflectionInfo smoothReflectionInfo(vec3 dir,vec3 hitCoord)\r{\rReflectionInfo info;\rinfo.color=vec3(0.0);\rvec4 projectedCoord;\rfloat sampledDepth;\rfor(int i=0; i<SMOOTH_STEPS; i++)\r{\rprojectedCoord=projection*vec4(hitCoord,1.0);\rprojectedCoord.xy/=projectedCoord.w;\rprojectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);\rsampledDepth=(view*texture2D(positionSampler,projectedCoord.xy)).z;\rfloat depth=sampledDepth-hitCoord.z;\rdir*=0.5;\rif(depth>0.0)\rhitCoord-=dir;\relse\rhitCoord+=dir;\rinfo.color+=texture2D(textureSampler,projectedCoord.xy).rgb;\r}\rprojectedCoord=projection*vec4(hitCoord,1.0);\rprojectedCoord.xy/=projectedCoord.w;\rprojectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);\rinfo.coords=vec4(projectedCoord.xy,sampledDepth,1.0);\rinfo.color+=texture2D(textureSampler,projectedCoord.xy).rgb;\rinfo.color/=float(SMOOTH_STEPS+1);\rreturn info;\r}\r/**\r* Tests the given world position (hitCoord) according to the given reflection vector (dir)\r* until it finds a collision (means that depth is enough close to say \"it's the pixel to sample!\").\r*/\rReflectionInfo getReflectionInfo(vec3 dir,vec3 hitCoord)\r{\rReflectionInfo info;\rvec4 projectedCoord;\rfloat sampledDepth;\rdir*=stepSize;\rfor(int i=0; i<REFLECTION_SAMPLES; i++)\r{\rhitCoord+=dir;\rprojectedCoord=projection*vec4(hitCoord,1.0);\rprojectedCoord.xy/=projectedCoord.w;\rprojectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);\rsampledDepth=(view*texture2D(positionSampler,projectedCoord.xy)).z;\rfloat depth=sampledDepth-hitCoord.z;\r#ifdef RIGHT_HANDED_SCENE\ndepth*=-1.0;\r#endif\nif(((depth-dir.z)<threshold) && depth<=0.0)\r{\r#ifdef ENABLE_SMOOTH_REFLECTIONS\nreturn smoothReflectionInfo(dir,hitCoord);\r#else\ninfo.color=texture2D(textureSampler,projectedCoord.xy).rgb;\rinfo.coords=vec4(projectedCoord.xy,sampledDepth,0.0);\rreturn info;\r#endif\n}\r}\rinfo.color=texture2D(textureSampler,projectedCoord.xy).rgb;\rinfo.coords=vec4(projectedCoord.xy,sampledDepth,0.0);\rreturn info;\r}\rvec3 hash(vec3 a)\r{\ra=fract(a*0.8);\ra+=dot(a,a.yxz+19.19);\rreturn fract((a.xxy+a.yxx)*a.zyx);\r}\r#endif\nvoid main()\r{\r#ifdef SSR_SUPPORTED\nvec4 albedoFull=texture2D(textureSampler,vUV);\rvec3 albedo=albedoFull.rgb;\rfloat spec=texture2D(reflectivitySampler,vUV).r;\rif (spec==0.0) {\rgl_FragColor=albedoFull;\rreturn;\r}\rvec3 normal=(texture2D(normalSampler,vUV)).xyz;\rvec3 position=(view*texture2D(positionSampler,vUV)).xyz;\rvec3 reflected=normalize(reflect(normalize(position),normalize(normal)));\rfloat roughness=1.0-texture2D(reflectivitySampler,vUV).a;\rvec3 jitt=mix(vec3(0.0),hash(position),roughness)*roughnessFactor;\rReflectionInfo info=getReflectionInfo(jitt+reflected,position);\rvec2 dCoords=smoothstep(0.2,0.6,abs(vec2(0.5,0.5)-info.coords.xy));\rfloat screenEdgefactor=clamp(1.0-(dCoords.x+dCoords.y),0.0,1.0);\rvec3 F0=vec3(0.04);\rF0 =mix(F0,albedo,spec);\rvec3 fresnel=fresnelSchlick(max(dot(normalize(normal),normalize(position)),0.0),F0);\r#ifdef RIGHT_HANDED_SCENE\nreflected.z*=-1.0;\r#endif\nfloat reflectionMultiplier=clamp(pow(spec*strength,reflectionSpecularFalloffExponent)*screenEdgefactor*reflected.z,0.0,0.9);\rfloat albedoMultiplier=1.0-reflectionMultiplier;\rvec3 SSR=info.color*fresnel;\rgl_FragColor=vec4((albedo*albedoMultiplier)+(SSR*reflectionMultiplier),albedoFull.a);\r#else\ngl_FragColor=texture2D(textureSampler,vUV);\r#endif\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport const screenSpaceReflectionPixelShader = { name, shader };\n"]}