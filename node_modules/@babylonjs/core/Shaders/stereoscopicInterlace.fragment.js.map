{"version":3,"file":"stereoscopicInterlace.fragment.js","sourceRoot":"","sources":["../../../../../lts/core/generated/Shaders/stereoscopicInterlace.fragment.ts"],"names":[],"mappings":"AAAA,eAAe;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AAErD,IAAM,IAAI,GAAG,kCAAkC,CAAC;AAChD,IAAM,MAAM,GAAG,knCA4Cd,CAAC;AACF,aAAa;AACb,WAAW,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AACxC,cAAc;AACd,MAAM,CAAC,IAAM,gCAAgC,GAAG,EAAE,IAAI,MAAA,EAAE,MAAM,QAAA,EAAE,CAAC","sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"stereoscopicInterlacePixelShader\";\nconst shader = `const vec3 TWO=vec3(2.0,2.0,2.0);\rvarying vec2 vUV;\runiform sampler2D camASampler;\runiform sampler2D textureSampler;\runiform vec2 stepSize;\r#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\r{\rbool useCamA;\rbool useCamB;\rvec2 texCoord1;\rvec2 texCoord2;\rvec3 frag1;\rvec3 frag2;\r#ifdef IS_STEREOSCOPIC_HORIZ\nuseCamB=vUV.x>0.5;\ruseCamA=!useCamB;\rtexCoord1=vec2(useCamB ? (vUV.x-0.5)*2.0 : vUV.x*2.0,vUV.y);\rtexCoord2=vec2(texCoord1.x+stepSize.x,vUV.y);\r#else\n#ifdef IS_STEREOSCOPIC_INTERLACED\nfloat rowNum=floor(vUV.y/stepSize.y);\ruseCamA=mod(rowNum,2.0)==1.0;\ruseCamB=mod(rowNum,2.0)==0.0;\rtexCoord1=vec2(vUV.x,vUV.y);\rtexCoord2=vec2(vUV.x,vUV.y);\r#else\nuseCamB=vUV.y>0.5;\ruseCamA=!useCamB;\rtexCoord1=vec2(vUV.x,useCamB ? (vUV.y-0.5)*2.0 : vUV.y*2.0);\rtexCoord2=vec2(vUV.x,texCoord1.y+stepSize.y);\r#endif\n#endif\nif (useCamB){\rfrag1=texture2D(textureSampler,texCoord1).rgb;\rfrag2=texture2D(textureSampler,texCoord2).rgb;\r}else if (useCamA){\rfrag1=texture2D(camASampler ,texCoord1).rgb;\rfrag2=texture2D(camASampler ,texCoord2).rgb;\r}else {\rdiscard;\r}\rgl_FragColor=vec4((frag1+frag2)/TWO,1.0);\r}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport const stereoscopicInterlacePixelShader = { name, shader };\n"]}