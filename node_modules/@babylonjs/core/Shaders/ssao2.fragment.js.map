{"version":3,"file":"ssao2.fragment.js","sourceRoot":"","sources":["../../../../../lts/core/generated/Shaders/ssao2.fragment.ts"],"names":[],"mappings":"AAAA,eAAe;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AAErD,IAAM,IAAI,GAAG,kBAAkB,CAAC;AAChC,IAAM,MAAM,GAAG,8rNAkMd,CAAC;AACF,aAAa;AACb,WAAW,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AACxC,cAAc;AACd,MAAM,CAAC,IAAM,gBAAgB,GAAG,EAAE,IAAI,MAAA,EAAE,MAAM,QAAA,EAAE,CAAC","sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"ssao2PixelShader\";\nconst shader = `precision highp float;\runiform sampler2D textureSampler;\runiform float near;\runiform float far;\runiform float radius;\rfloat scales[16]=float[16](\r0.1,\r0.11406250000000001,\r0.131640625,\r0.15625,\r0.187890625,\r0.2265625,\r0.272265625,\r0.325,\r0.384765625,\r0.4515625,\r0.525390625,\r0.60625,\r0.694140625,\r0.7890625,\r0.891015625,\r1.0\r);\rvarying vec2 vUV;\rfloat perspectiveDepthToViewZ(in float invClipZ,in float near,in float far ) {\rreturn ( near*far )/( ( far-near )*invClipZ-far );\r}\rfloat viewZToPerspectiveDepth( in float viewZ,in float near,in float far ) {\rreturn ( near*far/viewZ+far)/( far-near );\r}\rfloat viewZToOrthographicDepth( in float viewZ,in float near,in float far ) {\rreturn ( viewZ+near )/( near-far );\r}\r#ifdef SSAO\nuniform sampler2D randomSampler;\runiform sampler2D depthSampler;\runiform sampler2D normalSampler;\runiform float randTextureTiles;\runiform float samplesFactor;\runiform vec3 sampleSphere[SAMPLES];\runiform float totalStrength;\runiform float base;\runiform float xViewport;\runiform float yViewport;\runiform mat3 depthProjection;\runiform float maxZ;\runiform float minZAspect;\runiform vec2 texelSize;\runiform mat4 projection;\rvoid main()\r{\rvec3 random=texture2D(randomSampler,vUV*randTextureTiles).rgb;\rfloat depth=texture2D(depthSampler,vUV).r;\rfloat depthSign=depth/abs(depth);\rdepth=depth*depthSign;\rvec3 normal=texture2D(normalSampler,vUV).rgb;\rfloat occlusion=0.0;\rfloat correctedRadius=min(radius,minZAspect*depth/near);\rvec3 vViewRay=vec3((vUV.x*2.0-1.0)*xViewport,(vUV.y*2.0-1.0)*yViewport,depthSign);\rvec3 vDepthFactor=depthProjection*vec3(1.0,1.0,depth);\rvec3 origin=vViewRay*vDepthFactor;\rvec3 rvec=random*2.0-1.0;\rrvec.z=0.0;\rfloat dotProduct=dot(rvec,normal);\rrvec=1.0-abs(dotProduct)>1e-2 ? rvec : vec3(-rvec.y,0.0,rvec.x);\rvec3 tangent=normalize(rvec-normal*dot(rvec,normal));\rvec3 bitangent=cross(normal,tangent);\rmat3 tbn=mat3(tangent,bitangent,normal);\rfloat difference;\rfor (int i=0; i<SAMPLES; ++i) {\rvec3 samplePosition=scales[(i+int(random.x*16.0)) % 16]*tbn*sampleSphere[(i+int(random.y*16.0)) % 16];\rsamplePosition=samplePosition*correctedRadius+origin;\rvec4 offset=vec4(samplePosition,1.0);\roffset=projection*offset;\roffset.xyz/=offset.w;\roffset.xy=offset.xy*0.5+0.5;\rif (offset.x<0.0 || offset.y<0.0 || offset.x>1.0 || offset.y>1.0) {\rcontinue;\r}\rfloat sampleDepth=abs(texture2D(depthSampler,offset.xy).r);\rdifference=depthSign*samplePosition.z-sampleDepth;\rfloat rangeCheck=1.0-smoothstep(correctedRadius*0.5,correctedRadius,difference);\rocclusion+=(difference>=0.0 ? 1.0 : 0.0)*rangeCheck;\r}\rocclusion=occlusion*(1.0-smoothstep(maxZ*0.75,maxZ,depth));\rfloat ao=1.0-totalStrength*occlusion*samplesFactor;\rfloat result=clamp(ao+base,0.0,1.0);\rgl_FragColor=vec4(vec3(result),1.0);\r}\r#endif\n#ifdef BILATERAL_BLUR\nuniform sampler2D depthSampler;\runiform float outSize;\runiform float samplerOffsets[SAMPLES];\rvec4 blur9(sampler2D image,vec2 uv,float resolution,vec2 direction) {\rvec4 color=vec4(0.0);\rvec2 off1=vec2(1.3846153846)*direction;\rvec2 off2=vec2(3.2307692308)*direction;\rcolor+=texture2D(image,uv)*0.2270270270;\rcolor+=texture2D(image,uv+(off1/resolution))*0.3162162162;\rcolor+=texture2D(image,uv-(off1/resolution))*0.3162162162;\rcolor+=texture2D(image,uv+(off2/resolution))*0.0702702703;\rcolor+=texture2D(image,uv-(off2/resolution))*0.0702702703;\rreturn color;\r}\rvec4 blur13(sampler2D image,vec2 uv,float resolution,vec2 direction) {\rvec4 color=vec4(0.0);\rvec2 off1=vec2(1.411764705882353)*direction;\rvec2 off2=vec2(3.2941176470588234)*direction;\rvec2 off3=vec2(5.176470588235294)*direction;\rcolor+=texture2D(image,uv)*0.1964825501511404;\rcolor+=texture2D(image,uv+(off1/resolution))*0.2969069646728344;\rcolor+=texture2D(image,uv-(off1/resolution))*0.2969069646728344;\rcolor+=texture2D(image,uv+(off2/resolution))*0.09447039785044732;\rcolor+=texture2D(image,uv-(off2/resolution))*0.09447039785044732;\rcolor+=texture2D(image,uv+(off3/resolution))*0.010381362401148057;\rcolor+=texture2D(image,uv-(off3/resolution))*0.010381362401148057;\rreturn color;\r}\rvec4 blur13Bilateral(sampler2D image,vec2 uv,float resolution,vec2 direction) {\rvec4 color=vec4(0.0);\rvec2 off1=vec2(1.411764705882353)*direction;\rvec2 off2=vec2(3.2941176470588234)*direction;\rvec2 off3=vec2(5.176470588235294)*direction;\rfloat compareDepth=abs(texture2D(depthSampler,uv).r);\rfloat sampleDepth;\rfloat weight;\rfloat weightSum=30.0;\rcolor+=texture2D(image,uv)*30.0;\rsampleDepth=abs(texture2D(depthSampler,uv+(off1/resolution)).r);\rweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\rweightSum+= weight;\rcolor+=texture2D(image,uv+(off1/resolution))*weight;\rsampleDepth=abs(texture2D(depthSampler,uv-(off1/resolution)).r);\rweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\rweightSum+= weight;\rcolor+=texture2D(image,uv-(off1/resolution))*weight;\rsampleDepth=abs(texture2D(depthSampler,uv+(off2/resolution)).r);\rweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\rweightSum+=weight;\rcolor+=texture2D(image,uv+(off2/resolution))*weight;\rsampleDepth=abs(texture2D(depthSampler,uv-(off2/resolution)).r);\rweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\rweightSum+=weight;\rcolor+=texture2D(image,uv-(off2/resolution))*weight;\rsampleDepth=abs(texture2D(depthSampler,uv+(off3/resolution)).r);\rweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\rweightSum+=weight;\rcolor+=texture2D(image,uv+(off3/resolution))*weight;\rsampleDepth=abs(texture2D(depthSampler,uv-(off3/resolution)).r);\rweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\rweightSum+=weight;\rcolor+=texture2D(image,uv-(off3/resolution))*weight;\rreturn color/weightSum;\r}\rvoid main()\r{\r#if EXPENSIVE\nfloat compareDepth=abs(texture2D(depthSampler,vUV).r);\rfloat texelsize=1.0/outSize;\rfloat result=0.0;\rfloat weightSum=0.0;\rfor (int i=0; i<SAMPLES; ++i)\r{\r#ifdef BILATERAL_BLUR_H\nvec2 direction=vec2(1.0,0.0);\rvec2 sampleOffset=vec2(texelsize*samplerOffsets[i],0.0);\r#else\nvec2 direction=vec2(0.0,1.0);\rvec2 sampleOffset=vec2(0.0,texelsize*samplerOffsets[i]);\r#endif\nvec2 samplePos=vUV+sampleOffset;\rfloat sampleDepth=abs(texture2D(depthSampler,samplePos).r);\rfloat weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30000.0);\rresult+=texture2D(textureSampler,samplePos).r*weight;\rweightSum+=weight;\r}\rresult/=weightSum;\rgl_FragColor.rgb=vec3(result);\rgl_FragColor.a=1.0;\r#else\nvec4 color;\r#ifdef BILATERAL_BLUR_H\nvec2 direction=vec2(1.0,0.0);\rcolor=blur13Bilateral(textureSampler,vUV,outSize,direction);\r#else\nvec2 direction=vec2(0.0,1.0);\rcolor=blur13Bilateral(textureSampler,vUV,outSize,direction);\r#endif\ngl_FragColor.rgb=vec3(color.r);\rgl_FragColor.a=1.0;\r#endif\n}\r#endif\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport const ssao2PixelShader = { name, shader };\n"]}