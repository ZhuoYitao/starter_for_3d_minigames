{"version":3,"file":"background.fragment.js","sourceRoot":"","sources":["../../../../../lts/core/generated/Shaders/background.fragment.ts"],"names":[],"mappings":"AAAA,eAAe;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,gDAAgD,CAAC;AACxD,OAAO,2CAA2C,CAAC;AACnD,OAAO,kCAAkC,CAAC;AAC1C,OAAO,qCAAqC,CAAC;AAC7C,OAAO,6CAA6C,CAAC;AACrD,OAAO,2CAA2C,CAAC;AACnD,OAAO,sCAAsC,CAAC;AAC9C,OAAO,0CAA0C,CAAC;AAClD,OAAO,2CAA2C,CAAC;AACnD,OAAO,2CAA2C,CAAC;AACnD,OAAO,+CAA+C,CAAC;AACvD,OAAO,yCAAyC,CAAC;AACjD,OAAO,oCAAoC,CAAC;AAC5C,OAAO,gCAAgC,CAAC;AACxC,OAAO,8BAA8B,CAAC;AAEtC,IAAM,IAAI,GAAG,uBAAuB,CAAC;AACrC,IAAM,MAAM,GAAG,ulNAgOd,CAAC;AACF,aAAa;AACb,WAAW,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AACxC,cAAc;AACd,MAAM,CAAC,IAAM,qBAAqB,GAAG,EAAE,IAAI,MAAA,EAAE,MAAM,QAAA,EAAE,CAAC","sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/backgroundFragmentDeclaration\";\nimport \"./ShadersInclude/backgroundUboDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/reflectionFunction\";\nimport \"./ShadersInclude/imageProcessingDeclaration\";\nimport \"./ShadersInclude/lightFragmentDeclaration\";\nimport \"./ShadersInclude/lightUboDeclaration\";\nimport \"./ShadersInclude/lightsFragmentFunctions\";\nimport \"./ShadersInclude/shadowsFragmentFunctions\";\nimport \"./ShadersInclude/imageProcessingFunctions\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/lightFragment\";\nimport \"./ShadersInclude/fogFragment\";\n\nconst name = \"backgroundPixelShader\";\nconst shader = `#ifdef TEXTURELODSUPPORT\n#extension GL_EXT_shader_texture_lod : enable\n#endif\nprecision highp float;\r#include<__decl__backgroundFragment>\n#include<helperFunctions>\n#define RECIPROCAL_PI2 0.15915494\nvarying vec3 vPositionW;\r#ifdef MAINUV1\nvarying vec2 vMainUV1;\r#endif \n#ifdef MAINUV2 \nvarying vec2 vMainUV2; \r#endif \n#ifdef NORMAL\nvarying vec3 vNormalW;\r#endif\n#ifdef DIFFUSE\n#if DIFFUSEDIRECTUV==1\n#define vDiffuseUV vMainUV1\n#elif DIFFUSEDIRECTUV==2\n#define vDiffuseUV vMainUV2\n#else\nvarying vec2 vDiffuseUV;\r#endif\nuniform sampler2D diffuseSampler;\r#endif\n#ifdef REFLECTION\n#ifdef REFLECTIONMAP_3D\n#define sampleReflection(s,c) textureCube(s,c)\nuniform samplerCube reflectionSampler;\r#ifdef TEXTURELODSUPPORT\n#define sampleReflectionLod(s,c,l) textureCubeLodEXT(s,c,l)\n#else\nuniform samplerCube reflectionSamplerLow;\runiform samplerCube reflectionSamplerHigh;\r#endif\n#else\n#define sampleReflection(s,c) texture2D(s,c)\nuniform sampler2D reflectionSampler;\r#ifdef TEXTURELODSUPPORT\n#define sampleReflectionLod(s,c,l) texture2DLodEXT(s,c,l)\n#else\nuniform samplerCube reflectionSamplerLow;\runiform samplerCube reflectionSamplerHigh;\r#endif\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\r#else\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\r#endif\n#endif\n#include<reflectionFunction>\n#endif\n#ifndef FROMLINEARSPACE\n#define FROMLINEARSPACE;\n#endif\n#ifndef SHADOWONLY\n#define SHADOWONLY;\n#endif\n#include<imageProcessingDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<imageProcessingFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<fogFragmentDeclaration>\n#ifdef REFLECTIONFRESNEL\n#define FRESNEL_MAXIMUM_ON_ROUGH 0.25\nvec3 fresnelSchlickEnvironmentGGX(float VdotN,vec3 reflectance0,vec3 reflectance90,float smoothness)\r{\rfloat weight=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);\rreturn reflectance0+weight*(reflectance90-reflectance0)*pow5(saturate(1.0-VdotN));\r}\r#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\r#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\r#else\nvec3 normalW=vec3(0.0,1.0,0.0);\r#endif\nfloat shadow=1.;\rfloat globalShadow=0.;\rfloat shadowLightCount=0.;\r#include<lightFragment>[0..maxSimultaneousLights]\n#ifdef SHADOWINUSE\nglobalShadow/=shadowLightCount;\r#else\nglobalShadow=1.0;\r#endif\n#ifndef BACKMAT_SHADOWONLY\nvec4 reflectionColor=vec4(1.,1.,1.,1.);\r#ifdef REFLECTION\nvec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\r#ifdef REFLECTIONMAP_OPPOSITEZ\nreflectionVector.z*=-1.0;\r#endif\n#ifdef REFLECTIONMAP_3D\nvec3 reflectionCoords=reflectionVector;\r#else\nvec2 reflectionCoords=reflectionVector.xy;\r#ifdef REFLECTIONMAP_PROJECTION\nreflectionCoords/=reflectionVector.z;\r#endif\nreflectionCoords.y=1.0-reflectionCoords.y;\r#endif\n#ifdef REFLECTIONBLUR\nfloat reflectionLOD=vReflectionInfos.y;\r#ifdef TEXTURELODSUPPORT\nreflectionLOD=reflectionLOD*log2(vReflectionMicrosurfaceInfos.x)*vReflectionMicrosurfaceInfos.y+vReflectionMicrosurfaceInfos.z;\rreflectionColor=sampleReflectionLod(reflectionSampler,reflectionCoords,reflectionLOD);\r#else\nfloat lodReflectionNormalized=saturate(reflectionLOD);\rfloat lodReflectionNormalizedDoubled=lodReflectionNormalized*2.0;\rvec4 reflectionSpecularMid=sampleReflection(reflectionSampler,reflectionCoords);\rif(lodReflectionNormalizedDoubled<1.0){\rreflectionColor=mix(\rsampleReflection(reflectionSamplerHigh,reflectionCoords),\rreflectionSpecularMid,\rlodReflectionNormalizedDoubled\r);\r} else {\rreflectionColor=mix(\rreflectionSpecularMid,\rsampleReflection(reflectionSamplerLow,reflectionCoords),\rlodReflectionNormalizedDoubled-1.0\r);\r}\r#endif\n#else\nvec4 reflectionSample=sampleReflection(reflectionSampler,reflectionCoords);\rreflectionColor=reflectionSample;\r#endif\n#ifdef RGBDREFLECTION\nreflectionColor.rgb=fromRGBD(reflectionColor);\r#endif\n#ifdef GAMMAREFLECTION\nreflectionColor.rgb=toLinearSpace(reflectionColor.rgb);\r#endif\n#ifdef REFLECTIONBGR\nreflectionColor.rgb=reflectionColor.bgr;\r#endif\nreflectionColor.rgb*=vReflectionInfos.x;\r#endif\nvec3 diffuseColor=vec3(1.,1.,1.);\rfloat finalAlpha=alpha;\r#ifdef DIFFUSE\nvec4 diffuseMap=texture2D(diffuseSampler,vDiffuseUV);\r#ifdef GAMMADIFFUSE\ndiffuseMap.rgb=toLinearSpace(diffuseMap.rgb);\r#endif\ndiffuseMap.rgb*=vDiffuseInfos.y;\r#ifdef DIFFUSEHASALPHA\nfinalAlpha*=diffuseMap.a;\r#endif\ndiffuseColor=diffuseMap.rgb;\r#endif\n#ifdef REFLECTIONFRESNEL\nvec3 colorBase=diffuseColor;\r#else\nvec3 colorBase=reflectionColor.rgb*diffuseColor;\r#endif\ncolorBase=max(colorBase,0.0);\r#ifdef USERGBCOLOR\nvec3 finalColor=colorBase;\r#else\n#ifdef USEHIGHLIGHTANDSHADOWCOLORS\nvec3 mainColor=mix(vPrimaryColorShadow.rgb,vPrimaryColor.rgb,colorBase);\r#else\nvec3 mainColor=vPrimaryColor.rgb;\r#endif\nvec3 finalColor=colorBase*mainColor;\r#endif\n#ifdef REFLECTIONFRESNEL\nvec3 reflectionAmount=vReflectionControl.xxx;\rvec3 reflectionReflectance0=vReflectionControl.yyy;\rvec3 reflectionReflectance90=vReflectionControl.zzz;\rfloat VdotN=dot(normalize(vEyePosition.xyz),normalW);\rvec3 planarReflectionFresnel=fresnelSchlickEnvironmentGGX(saturate(VdotN),reflectionReflectance0,reflectionReflectance90,1.0);\rreflectionAmount*=planarReflectionFresnel;\r#ifdef REFLECTIONFALLOFF\nfloat reflectionDistanceFalloff=1.0-saturate(length(vPositionW.xyz-vBackgroundCenter)*vReflectionControl.w);\rreflectionDistanceFalloff*=reflectionDistanceFalloff;\rreflectionAmount*=reflectionDistanceFalloff;\r#endif\nfinalColor=mix(finalColor,reflectionColor.rgb,saturate(reflectionAmount));\r#endif\n#ifdef OPACITYFRESNEL\nfloat viewAngleToFloor=dot(normalW,normalize(vEyePosition.xyz-vBackgroundCenter));\rconst float startAngle=0.1;\rfloat fadeFactor=saturate(viewAngleToFloor/startAngle);\rfinalAlpha*=fadeFactor*fadeFactor;\r#endif\n#ifdef SHADOWINUSE\nfinalColor=mix(finalColor*shadowLevel,finalColor,globalShadow);\r#endif\nvec4 color=vec4(finalColor,finalAlpha);\r#else\nvec4 color=vec4(vPrimaryColor.rgb,(1.0-clamp(globalShadow,0.,1.))*alpha);\r#endif\n#include<fogFragment>\n#ifdef IMAGEPROCESSINGPOSTPROCESS\n#if !defined(SKIPFINALCOLORCLAMP)\ncolor.rgb=clamp(color.rgb,0.,30.0);\r#endif\n#else\ncolor=applyImageProcessing(color);\r#endif\n#ifdef PREMULTIPLYALPHA\ncolor.rgb*=color.a;\r#endif\n#ifdef NOISE\ncolor.rgb+=dither(vPositionW.xy,0.5);\rcolor=max(color,0.0);\r#endif\ngl_FragColor=color;\r#define CUSTOM_FRAGMENT_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport const backgroundPixelShader = { name, shader };\n"]}