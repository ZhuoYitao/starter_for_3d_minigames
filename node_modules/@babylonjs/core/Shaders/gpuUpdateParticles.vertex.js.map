{"version":3,"file":"gpuUpdateParticles.vertex.js","sourceRoot":"","sources":["../../../../../lts/core/generated/Shaders/gpuUpdateParticles.vertex.ts"],"names":[],"mappings":"AAAA,eAAe;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AAErD,IAAM,IAAI,GAAG,gCAAgC,CAAC;AAC9C,IAAM,MAAM,GAAG,q9TA4Wb,CAAC;AACH,aAAa;AACb,WAAW,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AACxC,cAAc;AACd,MAAM,CAAC,IAAM,8BAA8B,GAAG,EAAE,IAAI,MAAA,EAAE,MAAM,QAAA,EAAE,CAAC","sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"gpuUpdateParticlesVertexShader\";\nconst shader = `#version 300 es\n#define PI 3.14159\nuniform float currentCount;\runiform float timeDelta;\runiform float stopFactor;\r#ifndef LOCAL\nuniform mat4 emitterWM;\r#endif\nuniform vec2 lifeTime;\runiform vec2 emitPower;\runiform vec2 sizeRange;\runiform vec4 scaleRange;\r#ifndef COLORGRADIENTS\nuniform vec4 color1;\runiform vec4 color2;\r#endif\nuniform vec3 gravity;\runiform sampler2D randomSampler;\runiform sampler2D randomSampler2;\runiform vec4 angleRange;\r#ifdef BOXEMITTER\nuniform vec3 direction1;\runiform vec3 direction2;\runiform vec3 minEmitBox;\runiform vec3 maxEmitBox;\r#endif\n#ifdef POINTEMITTER\nuniform vec3 direction1;\runiform vec3 direction2;\r#endif\n#ifdef HEMISPHERICEMITTER\nuniform float radius;\runiform float radiusRange;\runiform float directionRandomizer;\r#endif\n#ifdef SPHEREEMITTER\nuniform float radius;\runiform float radiusRange;\r#ifdef DIRECTEDSPHEREEMITTER\nuniform vec3 direction1;\runiform vec3 direction2;\r#else\nuniform float directionRandomizer;\r#endif\n#endif\n#ifdef CYLINDEREMITTER\nuniform float radius;\runiform float height;\runiform float radiusRange;\r#ifdef DIRECTEDCYLINDEREMITTER\nuniform vec3 direction1;\runiform vec3 direction2;\r#else\nuniform float directionRandomizer;\r#endif\n#endif\n#ifdef CONEEMITTER\nuniform vec2 radius;\runiform float coneAngle;\runiform vec2 height;\runiform float directionRandomizer;\r#endif\nin vec3 position;\r#ifdef CUSTOMEMITTER\nin vec3 initialPosition;\r#endif\nin float age;\rin float life;\rin vec4 seed;\rin vec3 size;\r#ifndef COLORGRADIENTS\nin vec4 color;\r#endif\nin vec3 direction;\r#ifndef BILLBOARD\nin vec3 initialDirection;\r#endif\n#ifdef ANGULARSPEEDGRADIENTS\nin float angle;\r#else\nin vec2 angle;\r#endif\n#ifdef ANIMATESHEET\nin float cellIndex;\r#ifdef ANIMATESHEETRANDOMSTART\nin float cellStartOffset;\r#endif\n#endif\n#ifdef NOISE\nin vec3 noiseCoordinates1;\rin vec3 noiseCoordinates2;\r#endif\nout vec3 outPosition;\r#ifdef CUSTOMEMITTER\nout vec3 outInitialPosition;\r#endif\nout float outAge;\rout float outLife;\rout vec4 outSeed;\rout vec3 outSize;\r#ifndef COLORGRADIENTS\nout vec4 outColor;\r#endif\nout vec3 outDirection;\r#ifndef BILLBOARD\nout vec3 outInitialDirection;\r#endif\n#ifdef ANGULARSPEEDGRADIENTS\nout float outAngle;\r#else\nout vec2 outAngle;\r#endif\n#ifdef ANIMATESHEET\nout float outCellIndex;\r#ifdef ANIMATESHEETRANDOMSTART\nout float outCellStartOffset;\r#endif\n#endif\n#ifdef NOISE\nout vec3 outNoiseCoordinates1;\rout vec3 outNoiseCoordinates2;\r#endif\n#ifdef SIZEGRADIENTS\nuniform sampler2D sizeGradientSampler;\r#endif \n#ifdef ANGULARSPEEDGRADIENTS\nuniform sampler2D angularSpeedGradientSampler;\r#endif \n#ifdef VELOCITYGRADIENTS\nuniform sampler2D velocityGradientSampler;\r#endif\n#ifdef LIMITVELOCITYGRADIENTS\nuniform sampler2D limitVelocityGradientSampler;\runiform float limitVelocityDamping;\r#endif\n#ifdef DRAGGRADIENTS\nuniform sampler2D dragGradientSampler;\r#endif\n#ifdef NOISE\nuniform vec3 noiseStrength;\runiform sampler2D noiseSampler;\r#endif\n#ifdef ANIMATESHEET\nuniform vec4 cellInfos;\r#endif\nvec3 getRandomVec3(float offset) {\rreturn texture(randomSampler2,vec2(float(gl_VertexID)*offset/currentCount,0)).rgb;\r}\rvec4 getRandomVec4(float offset) {\rreturn texture(randomSampler,vec2(float(gl_VertexID)*offset/currentCount,0));\r}\rvoid main() {\rfloat newAge=age+timeDelta; \rif (newAge>=life && stopFactor != 0.) {\rvec3 newPosition;\rvec3 newDirection;\rvec4 randoms=getRandomVec4(seed.x);\routLife=lifeTime.x+(lifeTime.y-lifeTime.x)*randoms.r;\routAge=newAge-life;\routSeed=seed;\r#ifdef SIZEGRADIENTS \noutSize.x=texture(sizeGradientSampler,vec2(0,0)).r;\r#else\noutSize.x=sizeRange.x+(sizeRange.y-sizeRange.x)*randoms.g;\r#endif\noutSize.y=scaleRange.x+(scaleRange.y-scaleRange.x)*randoms.b;\routSize.z=scaleRange.z+(scaleRange.w-scaleRange.z)*randoms.a; \r#ifndef COLORGRADIENTS\noutColor=color1+(color2-color1)*randoms.b;\r#endif\n#ifndef ANGULARSPEEDGRADIENTS \noutAngle.y=angleRange.x+(angleRange.y-angleRange.x)*randoms.a;\routAngle.x=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;\r#else\noutAngle=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;\r#endif \n#ifdef POINTEMITTER\nvec3 randoms2=getRandomVec3(seed.y);\rvec3 randoms3=getRandomVec3(seed.z);\rnewPosition=vec3(0,0,0);\rnewDirection=direction1+(direction2-direction1)*randoms3;\r#elif defined(BOXEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\rvec3 randoms3=getRandomVec3(seed.z);\rnewPosition=minEmitBox+(maxEmitBox-minEmitBox)*randoms2;\rnewDirection=direction1+(direction2-direction1)*randoms3; \r#elif defined(HEMISPHERICEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\rvec3 randoms3=getRandomVec3(seed.z);\rfloat phi=2.0*PI*randoms2.x;\rfloat theta=acos(2.0*randoms2.y-1.0);\rfloat randX=cos(phi)*sin(theta);\rfloat randY=cos(theta);\rfloat randZ=sin(phi)*sin(theta);\rnewPosition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,abs(randY),randZ);\rnewDirection=newPosition+directionRandomizer*randoms3; \r#elif defined(SPHEREEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\rvec3 randoms3=getRandomVec3(seed.z);\rfloat phi=2.0*PI*randoms2.x;\rfloat theta=acos(2.0*randoms2.y-1.0);\rfloat randX=cos(phi)*sin(theta);\rfloat randY=cos(theta);\rfloat randZ=sin(phi)*sin(theta);\rnewPosition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,randY,randZ);\r#ifdef DIRECTEDSPHEREEMITTER\nnewDirection=normalize(direction1+(direction2-direction1)*randoms3);\r#else\nnewDirection=normalize(newPosition+directionRandomizer*randoms3);\r#endif\n#elif defined(CYLINDEREMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\rvec3 randoms3=getRandomVec3(seed.z);\rfloat yPos=(randoms2.x-0.5)*height;\rfloat angle=randoms2.y*PI*2.;\rfloat inverseRadiusRangeSquared=((1.-radiusRange)*(1.-radiusRange));\rfloat positionRadius=radius*sqrt(inverseRadiusRangeSquared+(randoms2.z*(1.-inverseRadiusRangeSquared)));\rfloat xPos=positionRadius*cos(angle);\rfloat zPos=positionRadius*sin(angle);\rnewPosition=vec3(xPos,yPos,zPos);\r#ifdef DIRECTEDCYLINDEREMITTER\nnewDirection=direction1+(direction2-direction1)*randoms3;\r#else\nangle=angle+((randoms3.x-0.5)*PI)*directionRandomizer;\rnewDirection=vec3(cos(angle),(randoms3.y-0.5)*directionRandomizer,sin(angle));\rnewDirection=normalize(newDirection);\r#endif\n#elif defined(CONEEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\rfloat s=2.0*PI*randoms2.x;\r#ifdef CONEEMITTERSPAWNPOINT\nfloat h=0.0001;\r#else\nfloat h=randoms2.y*height.y;\rh=1.-h*h; \r#endif\nfloat lRadius=radius.x-radius.x*randoms2.z*radius.y;\rlRadius=lRadius*h;\rfloat randX=lRadius*sin(s);\rfloat randZ=lRadius*cos(s);\rfloat randY=h *height.x;\rnewPosition=vec3(randX,randY,randZ); \rif (abs(cos(coneAngle))==1.0) {\rnewDirection=vec3(0.,1.0,0.);\r} else {\rvec3 randoms3=getRandomVec3(seed.z);\rnewDirection=normalize(newPosition+directionRandomizer*randoms3); \r}\r#elif defined(CUSTOMEMITTER)\nnewPosition=initialPosition;\routInitialPosition=initialPosition;\r#else \nnewPosition=vec3(0.,0.,0.);\rnewDirection=2.0*(getRandomVec3(seed.w)-vec3(0.5,0.5,0.5));\r#endif\nfloat power=emitPower.x+(emitPower.y-emitPower.x)*randoms.a;\r#ifdef LOCAL\noutPosition=newPosition;\r#else\noutPosition=(emitterWM*vec4(newPosition,1.)).xyz;\r#endif\n#ifdef CUSTOMEMITTER\noutDirection=direction;\r#ifndef BILLBOARD \noutInitialDirection=direction;\r#endif\n#else\n#ifdef LOCAL\nvec3 initial=newDirection;\r#else \nvec3 initial=(emitterWM*vec4(newDirection,0.)).xyz;\r#endif\noutDirection=initial*power;\r#ifndef BILLBOARD \noutInitialDirection=initial;\r#endif\n#endif\n#ifdef ANIMATESHEET \noutCellIndex=cellInfos.x;\r#ifdef ANIMATESHEETRANDOMSTART\noutCellStartOffset=randoms.a*outLife;\r#endif \n#endif\n#ifdef NOISE\noutNoiseCoordinates1=noiseCoordinates1;\routNoiseCoordinates2=noiseCoordinates2;\r#endif\n} else {\rfloat directionScale=timeDelta;\routAge=newAge;\rfloat ageGradient=newAge/life;\r#ifdef VELOCITYGRADIENTS\ndirectionScale*=texture(velocityGradientSampler,vec2(ageGradient,0)).r;\r#endif\n#ifdef DRAGGRADIENTS\ndirectionScale*=1.0-texture(dragGradientSampler,vec2(ageGradient,0)).r;\r#endif\n#if defined(CUSTOMEMITTER)\noutPosition=position+(direction-position)*ageGradient; \routInitialPosition=initialPosition;\r#else\noutPosition=position+direction*directionScale;\r#endif\noutLife=life;\routSeed=seed;\r#ifndef COLORGRADIENTS \noutColor=color;\r#endif\n#ifdef SIZEGRADIENTS\noutSize.x=texture(sizeGradientSampler,vec2(ageGradient,0)).r;\routSize.yz=size.yz;\r#else\noutSize=size;\r#endif \n#ifndef BILLBOARD \noutInitialDirection=initialDirection;\r#endif\n#ifdef CUSTOMEMITTER\noutDirection=direction;\r#else\nvec3 updatedDirection=direction+gravity*timeDelta;\r#ifdef LIMITVELOCITYGRADIENTS\nfloat limitVelocity=texture(limitVelocityGradientSampler,vec2(ageGradient,0)).r;\rfloat currentVelocity=length(updatedDirection);\rif (currentVelocity>limitVelocity) {\rupdatedDirection=updatedDirection*limitVelocityDamping;\r}\r#endif\noutDirection=updatedDirection;\r#ifdef NOISE\nfloat fetchedR=texture(noiseSampler,vec2(noiseCoordinates1.x,noiseCoordinates1.y)*vec2(0.5)+vec2(0.5)).r;\rfloat fetchedG=texture(noiseSampler,vec2(noiseCoordinates1.z,noiseCoordinates2.x)*vec2(0.5)+vec2(0.5)).r;\rfloat fetchedB=texture(noiseSampler,vec2(noiseCoordinates2.y,noiseCoordinates2.z)*vec2(0.5)+vec2(0.5)).r;\rvec3 force=vec3(2.*fetchedR-1.,2.*fetchedG-1.,2.*fetchedB-1.)*noiseStrength;\routDirection=outDirection+force*timeDelta;\routNoiseCoordinates1=noiseCoordinates1;\routNoiseCoordinates2=noiseCoordinates2;\r#endif \n#endif \n#ifdef ANGULARSPEEDGRADIENTS\nfloat angularSpeed=texture(angularSpeedGradientSampler,vec2(ageGradient,0)).r;\routAngle=angle+angularSpeed*timeDelta;\r#else\noutAngle=vec2(angle.x+angle.y*timeDelta,angle.y);\r#endif\n#ifdef ANIMATESHEET \nfloat offsetAge=outAge;\rfloat dist=cellInfos.y-cellInfos.x;\r#ifdef ANIMATESHEETRANDOMSTART\noutCellStartOffset=cellStartOffset;\roffsetAge+=cellStartOffset;\r#else\nfloat cellStartOffset=0.;\r#endif \nfloat ratio=0.;\rif (cellInfos.w==1.0) {\rratio=clamp(mod(cellStartOffset+cellInfos.z*offsetAge,life)/life,0.,1.0);\r}\relse {\rratio=clamp(cellStartOffset+cellInfos.z*offsetAge/life,0.,1.0);\r}\routCellIndex=float(int(cellInfos.x+ratio*dist));\r#endif\n}\r}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport const gpuUpdateParticlesVertexShader = { name, shader };\n"]}