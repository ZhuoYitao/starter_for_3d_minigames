{"version":3,"file":"geometry.fragment.js","sourceRoot":"","sources":["../../../../../lts/core/generated/Shaders/geometry.fragment.ts"],"names":[],"mappings":"AAAA,eAAe;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,yCAAyC,CAAC;AACjD,OAAO,4CAA4C,CAAC;AACpD,OAAO,wCAAwC,CAAC;AAChD,OAAO,+BAA+B,CAAC;AAEvC,IAAM,IAAI,GAAG,qBAAqB,CAAC;AACnC,IAAM,MAAM,GAAG,+rEAiFd,CAAC;AACF,aAAa;AACb,WAAW,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AACxC,cAAc;AACd,MAAM,CAAC,IAAM,mBAAmB,GAAG,EAAE,IAAI,MAAA,EAAE,MAAM,QAAA,EAAE,CAAC","sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/mrtFragmentDeclaration\";\nimport \"./ShadersInclude/bumpFragmentMainFunctions\";\nimport \"./ShadersInclude/bumpFragmentFunctions\";\nimport \"./ShadersInclude/bumpFragment\";\n\nconst name = \"geometryPixelShader\";\nconst shader = `#extension GL_EXT_draw_buffers : require\n#if defined(BUMP) || !defined(NORMAL)\n#extension GL_OES_standard_derivatives : enable\n#endif\nprecision highp float;\r#ifdef BUMP\nvarying mat4 vWorldView;\rvarying vec3 vNormalW;\r#else\nvarying vec3 vNormalV;\r#endif\nvarying vec4 vViewPos;\r#if defined(POSITION) || defined(BUMP)\nvarying vec3 vPositionW;\r#endif\n#ifdef VELOCITY\nvarying vec4 vCurrentPosition;\rvarying vec4 vPreviousPosition;\r#endif\n#ifdef NEED_UV\nvarying vec2 vUV;\r#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;\runiform vec2 vTangentSpaceParams;\r#endif\n#if defined(REFLECTIVITY) && (defined(HAS_SPECULAR) || defined(HAS_REFLECTIVITY))\nvarying vec2 vReflectivityUV;\runiform sampler2D reflectivitySampler;\r#endif\n#ifdef ALPHATEST\nuniform sampler2D diffuseSampler;\r#endif\n#include<mrtFragmentDeclaration>[RENDER_TARGET_COUNT]\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\nvoid main() {\r#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\rdiscard;\r#endif\nvec3 normalOutput;\r#ifdef BUMP\nvec3 normalW=normalize(vNormalW);\r#include<bumpFragment>\nnormalOutput=normalize(vec3(vWorldView*vec4(normalW,0.0)));\r#else\nnormalOutput=normalize(vNormalV);\r#endif\n#ifdef PREPASS\n#ifdef PREPASS_DEPTH\ngl_FragData[DEPTH_INDEX]=vec4(vViewPos.z/vViewPos.w,0.0,0.0,1.0);\r#endif\n#ifdef PREPASS_NORMAL\ngl_FragData[NORMAL_INDEX]=vec4(normalOutput,1.0);\r#endif\n#else\ngl_FragData[0]=vec4(vViewPos.z/vViewPos.w,0.0,0.0,1.0);\rgl_FragData[1]=vec4(normalOutput,1.0);\r#endif\n#ifdef POSITION\ngl_FragData[POSITION_INDEX]=vec4(vPositionW,1.0);\r#endif\n#ifdef VELOCITY\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;\rvec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;\rvec2 velocity=abs(a-b);\rvelocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;\rgl_FragData[VELOCITY_INDEX]=vec4(velocity,0.0,1.0);\r#endif\n#ifdef REFLECTIVITY\n#ifdef HAS_SPECULAR\nvec4 reflectivity=texture2D(reflectivitySampler,vReflectivityUV);\r#elif HAS_REFLECTIVITY\nvec4 reflectivity=vec4(texture2D(reflectivitySampler,vReflectivityUV).rgb,1.0);\r#else\nvec4 reflectivity=vec4(0.0,0.0,0.0,1.0);\r#endif\ngl_FragData[REFLECTIVITY_INDEX]=reflectivity;\r#endif\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport const geometryPixelShader = { name, shader };\n"]}