{"version":3,"file":"pbrHelperFunctions.js","sourceRoot":"","sources":["../../../../../../lts/core/generated/Shaders/ShadersInclude/pbrHelperFunctions.ts"],"names":[],"mappings":"AAAA,eAAe;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,2BAA2B,CAAC;AAExD,IAAM,IAAI,GAAG,oBAAoB,CAAC;AAClC,IAAM,MAAM,GAAG,kiFAiEd,CAAC;AACF,aAAa;AACb,WAAW,CAAC,oBAAoB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,cAAc;AACd,MAAM,CAAC,IAAM,kBAAkB,GAAG,EAAE,IAAI,MAAA,EAAE,MAAM,QAAA,EAAE,CAAC","sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrHelperFunctions\";\nconst shader = `#define RECIPROCAL_PI2 0.15915494\n#define RECIPROCAL_PI 0.31830988618\n#define MINIMUMVARIANCE 0.0005\nfloat convertRoughnessToAverageSlope(float roughness)\r{\rreturn square(roughness)+MINIMUMVARIANCE;\r}\rfloat fresnelGrazingReflectance(float reflectance0) {\rfloat reflectance90=saturate(reflectance0*25.0);\rreturn reflectance90;\r}\rvec2 getAARoughnessFactors(vec3 normalVector) {\r#ifdef SPECULARAA\nvec3 nDfdx=dFdx(normalVector.xyz);\rvec3 nDfdy=dFdy(normalVector.xyz);\rfloat slopeSquare=max(dot(nDfdx,nDfdx),dot(nDfdy,nDfdy));\rfloat geometricRoughnessFactor=pow(saturate(slopeSquare),0.333);\rfloat geometricAlphaGFactor=sqrt(slopeSquare);\rgeometricAlphaGFactor*=0.75;\rreturn vec2(geometricRoughnessFactor,geometricAlphaGFactor);\r#else\nreturn vec2(0.);\r#endif\n}\r#ifdef ANISOTROPIC\nvec2 getAnisotropicRoughness(float alphaG,float anisotropy) {\rfloat alphaT=max(alphaG*(1.0+anisotropy),MINIMUMVARIANCE);\rfloat alphaB=max(alphaG*(1.0-anisotropy),MINIMUMVARIANCE);\rreturn vec2(alphaT,alphaB);\r}\rvec3 getAnisotropicBentNormals(const vec3 T,const vec3 B,const vec3 N,const vec3 V,float anisotropy) {\rvec3 anisotropicFrameDirection=anisotropy>=0.0 ? B : T;\rvec3 anisotropicFrameTangent=cross(normalize(anisotropicFrameDirection),V);\rvec3 anisotropicFrameNormal=cross(anisotropicFrameTangent,anisotropicFrameDirection);\rvec3 anisotropicNormal=normalize(mix(N,anisotropicFrameNormal,abs(anisotropy)));\rreturn anisotropicNormal;\r}\r#endif\n#if defined(CLEARCOAT) || defined(SS_REFRACTION)\nvec3 cocaLambert(vec3 alpha,float distance) {\rreturn exp(-alpha*distance);\r}\rvec3 cocaLambert(float NdotVRefract,float NdotLRefract,vec3 alpha,float thickness) {\rreturn cocaLambert(alpha,(thickness*((NdotLRefract+NdotVRefract)/(NdotLRefract*NdotVRefract))));\r}\rvec3 computeColorAtDistanceInMedia(vec3 color,float distance) {\rreturn -log(color)/distance;\r}\rvec3 computeClearCoatAbsorption(float NdotVRefract,float NdotLRefract,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {\rvec3 clearCoatAbsorption=mix(vec3(1.0),\rcocaLambert(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness),\rclearCoatIntensity);\rreturn clearCoatAbsorption;\r}\r#endif\n#ifdef MICROSURFACEAUTOMATIC\nfloat computeDefaultMicroSurface(float microSurface,vec3 reflectivityColor)\r{\rconst float kReflectivityNoAlphaWorkflow_SmoothnessMax=0.95;\rfloat reflectivityLuminance=getLuminance(reflectivityColor);\rfloat reflectivityLuma=sqrt(reflectivityLuminance);\rmicroSurface=reflectivityLuma*kReflectivityNoAlphaWorkflow_SmoothnessMax;\rreturn microSurface;\r}\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport const pbrHelperFunctions = { name, shader };\n"]}