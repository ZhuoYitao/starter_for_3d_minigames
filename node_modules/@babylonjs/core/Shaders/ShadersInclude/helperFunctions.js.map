{"version":3,"file":"helperFunctions.js","sourceRoot":"","sources":["../../../../../../lts/core/generated/Shaders/ShadersInclude/helperFunctions.ts"],"names":[],"mappings":"AAAA,eAAe;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,2BAA2B,CAAC;AAExD,IAAM,IAAI,GAAG,iBAAiB,CAAC;AAC/B,IAAM,MAAM,GAAG,ykGAwGd,CAAC;AACF,aAAa;AACb,WAAW,CAAC,oBAAoB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,cAAc;AACd,MAAM,CAAC,IAAM,eAAe,GAAG,EAAE,IAAI,MAAA,EAAE,MAAM,QAAA,EAAE,CAAC","sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"helperFunctions\";\nconst shader = `const float PI=3.1415926535897932384626433832795;\rconst float HALF_MIN=5.96046448e-08; \rconst float LinearEncodePowerApprox=2.2;\rconst float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;\rconst vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);\rconst float Epsilon=0.0000001;\r#define saturate(x) clamp(x,0.0,1.0)\n#define absEps(x) abs(x)+Epsilon\n#define maxEps(x) max(x,Epsilon)\n#define saturateEps(x) clamp(x,Epsilon,1.0)\nmat3 transposeMat3(mat3 inMatrix) {\rvec3 i0=inMatrix[0];\rvec3 i1=inMatrix[1];\rvec3 i2=inMatrix[2];\rmat3 outMatrix=mat3(\rvec3(i0.x,i1.x,i2.x),\rvec3(i0.y,i1.y,i2.y),\rvec3(i0.z,i1.z,i2.z)\r);\rreturn outMatrix;\r}\rmat3 inverseMat3(mat3 inMatrix) {\rfloat a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];\rfloat a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];\rfloat a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];\rfloat b01=a22*a11-a12*a21;\rfloat b11=-a22*a10+a12*a20;\rfloat b21=a21*a10-a11*a20;\rfloat det=a00*b01+a01*b11+a02*b21;\rreturn mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),\rb11,(a22*a00-a02*a20),(-a12*a00+a02*a10),\rb21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;\r}\rfloat toLinearSpace(float color)\r{\rreturn pow(color,LinearEncodePowerApprox);\r}\rvec3 toLinearSpace(vec3 color)\r{\rreturn pow(color,vec3(LinearEncodePowerApprox));\r}\rvec4 toLinearSpace(vec4 color)\r{\rreturn vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);\r}\rvec3 toGammaSpace(vec3 color)\r{\rreturn pow(color,vec3(GammaEncodePowerApprox));\r}\rvec4 toGammaSpace(vec4 color)\r{\rreturn vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);\r}\rfloat toGammaSpace(float color)\r{\rreturn pow(color,GammaEncodePowerApprox);\r}\rfloat square(float value)\r{\rreturn value*value;\r}\rvec3 square(vec3 value)\r{\rreturn value*value;\r}\rfloat pow5(float value) {\rfloat sq=value*value;\rreturn sq*sq*value;\r}\rfloat getLuminance(vec3 color)\r{\rreturn clamp(dot(color,LuminanceEncodeApprox),0.,1.);\r}\rfloat getRand(vec2 seed) {\rreturn fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);\r}\rfloat dither(vec2 seed,float varianceAmount) {\rfloat rand=getRand(seed);\rfloat dither=mix(-varianceAmount/255.0,varianceAmount/255.0,rand);\rreturn dither;\r}\rconst float rgbdMaxRange=255.0;\rvec4 toRGBD(vec3 color) {\rfloat maxRGB=maxEps(max(color.r,max(color.g,color.b)));\rfloat D =max(rgbdMaxRange/maxRGB,1.);\rD =clamp(floor(D)/255.0,0.,1.);\rvec3 rgb=color.rgb*D;\rrgb=toGammaSpace(rgb);\rreturn vec4(clamp(rgb,0.,1.),D); \r}\rvec3 fromRGBD(vec4 rgbd) {\rrgbd.rgb=toLinearSpace(rgbd.rgb);\rreturn rgbd.rgb/rgbd.a;\r}\rvec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {\rvec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;\rvec3 halfSize=cubeSize*0.5;\rvec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;\rvec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;\rvec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);\rfloat distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);\rvec3 intersectPositionWS=vertexPos+origVec*distance;\rreturn intersectPositionWS-cubePos;\r}\r`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport const helperFunctions = { name, shader };\n"]}