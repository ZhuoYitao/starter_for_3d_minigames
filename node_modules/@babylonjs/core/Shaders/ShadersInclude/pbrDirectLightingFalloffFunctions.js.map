{"version":3,"file":"pbrDirectLightingFalloffFunctions.js","sourceRoot":"","sources":["../../../../../../lts/core/generated/Shaders/ShadersInclude/pbrDirectLightingFalloffFunctions.ts"],"names":[],"mappings":"AAAA,eAAe;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,2BAA2B,CAAC;AAExD,IAAM,IAAI,GAAG,mCAAmC,CAAC;AACjD,IAAM,MAAM,GAAG,ooFA6Db,CAAC;AACH,aAAa;AACb,WAAW,CAAC,oBAAoB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,cAAc;AACd,MAAM,CAAC,IAAM,iCAAiC,GAAG,EAAE,IAAI,MAAA,EAAE,MAAM,QAAA,EAAE,CAAC","sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrDirectLightingFalloffFunctions\";\nconst shader = `float computeDistanceLightFalloff_Standard(vec3 lightOffset,float range)\r{\rreturn max(0.,1.0-length(lightOffset)/range);\r}\rfloat computeDistanceLightFalloff_Physical(float lightDistanceSquared)\r{\rreturn 1.0/maxEps(lightDistanceSquared);\r}\rfloat computeDistanceLightFalloff_GLTF(float lightDistanceSquared,float inverseSquaredRange)\r{\rfloat lightDistanceFalloff=1.0/maxEps(lightDistanceSquared);\rfloat factor=lightDistanceSquared*inverseSquaredRange;\rfloat attenuation=saturate(1.0-factor*factor);\rattenuation*=attenuation;\rlightDistanceFalloff*=attenuation;\rreturn lightDistanceFalloff;\r}\rfloat computeDistanceLightFalloff(vec3 lightOffset,float lightDistanceSquared,float range,float inverseSquaredRange)\r{\r#ifdef USEPHYSICALLIGHTFALLOFF\nreturn computeDistanceLightFalloff_Physical(lightDistanceSquared);\r#elif defined(USEGLTFLIGHTFALLOFF)\nreturn computeDistanceLightFalloff_GLTF(lightDistanceSquared,inverseSquaredRange);\r#else\nreturn computeDistanceLightFalloff_Standard(lightOffset,range);\r#endif\n}\rfloat computeDirectionalLightFalloff_Standard(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent)\r{\rfloat falloff=0.0;\rfloat cosAngle=maxEps(dot(-lightDirection,directionToLightCenterW));\rif (cosAngle>=cosHalfAngle)\r{\rfalloff=max(0.,pow(cosAngle,exponent));\r}\rreturn falloff;\r}\rfloat computeDirectionalLightFalloff_Physical(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle)\r{\rconst float kMinusLog2ConeAngleIntensityRatio=6.64385618977; \rfloat concentrationKappa=kMinusLog2ConeAngleIntensityRatio/(1.0-cosHalfAngle);\rvec4 lightDirectionSpreadSG=vec4(-lightDirection*concentrationKappa,-concentrationKappa);\rfloat falloff=exp2(dot(vec4(directionToLightCenterW,1.0),lightDirectionSpreadSG));\rreturn falloff;\r}\rfloat computeDirectionalLightFalloff_GLTF(vec3 lightDirection,vec3 directionToLightCenterW,float lightAngleScale,float lightAngleOffset)\r{\rfloat cd=dot(-lightDirection,directionToLightCenterW);\rfloat falloff=saturate(cd*lightAngleScale+lightAngleOffset);\rfalloff*=falloff;\rreturn falloff;\r}\rfloat computeDirectionalLightFalloff(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent,float lightAngleScale,float lightAngleOffset)\r{\r#ifdef USEPHYSICALLIGHTFALLOFF\nreturn computeDirectionalLightFalloff_Physical(lightDirection,directionToLightCenterW,cosHalfAngle);\r#elif defined(USEGLTFLIGHTFALLOFF)\nreturn computeDirectionalLightFalloff_GLTF(lightDirection,directionToLightCenterW,lightAngleScale,lightAngleOffset);\r#else\nreturn computeDirectionalLightFalloff_Standard(lightDirection,directionToLightCenterW,cosHalfAngle,exponent);\r#endif\n}`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport const pbrDirectLightingFalloffFunctions = { name, shader };\n"]}