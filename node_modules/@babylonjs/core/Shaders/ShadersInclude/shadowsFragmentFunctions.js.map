{"version":3,"file":"shadowsFragmentFunctions.js","sourceRoot":"","sources":["../../../../../../lts/core/generated/Shaders/ShadersInclude/shadowsFragmentFunctions.ts"],"names":[],"mappings":"AAAA,eAAe;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,2BAA2B,CAAC;AAExD,IAAM,IAAI,GAAG,0BAA0B,CAAC;AACxC,IAAM,MAAM,GAAG,4kyBA8lBd,CAAC;AACF,aAAa;AACb,WAAW,CAAC,oBAAoB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,cAAc;AACd,MAAM,CAAC,IAAM,wBAAwB,GAAG,EAAE,IAAI,MAAA,EAAE,MAAM,QAAA,EAAE,CAAC","sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"shadowsFragmentFunctions\";\nconst shader = `#ifdef SHADOWS\n#ifndef SHADOWFLOAT\nfloat unpack(vec4 color)\r{\rconst vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\rreturn dot(color,bit_shift);\r}\r#endif\nfloat computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)\r{\rfloat mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));\rreturn mix(value,1.0,mask);\r}\r#define inline\nfloat computeShadowCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)\r{\rvec3 directionToLight=vPositionW-lightPosition;\rfloat depth=length(directionToLight);\rdepth=(depth+depthValues.x)/(depthValues.y);\rdepth=clamp(depth,0.,1.0);\rdirectionToLight=normalize(directionToLight);\rdirectionToLight.y=-directionToLight.y;\r#ifndef SHADOWFLOAT\nfloat shadow=unpack(textureCube(shadowSampler,directionToLight));\r#else\nfloat shadow=textureCube(shadowSampler,directionToLight).x;\r#endif\nreturn depth>shadow ? darkness : 1.0;\r}\r#define inline\nfloat computeShadowWithPoissonSamplingCube(vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)\r{\rvec3 directionToLight=vPositionW-lightPosition;\rfloat depth=length(directionToLight);\rdepth=(depth+depthValues.x)/(depthValues.y);\rdepth=clamp(depth,0.,1.0);\rdirectionToLight=normalize(directionToLight);\rdirectionToLight.y=-directionToLight.y;\rfloat visibility=1.;\rvec3 poissonDisk[4];\rpoissonDisk[0]=vec3(-1.0,1.0,-1.0);\rpoissonDisk[1]=vec3(1.0,-1.0,-1.0);\rpoissonDisk[2]=vec3(-1.0,-1.0,-1.0);\rpoissonDisk[3]=vec3(1.0,-1.0,1.0);\r#ifndef SHADOWFLOAT\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;\rif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;\rif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;\rif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;\r#else\nif (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;\rif (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;\rif (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;\rif (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;\r#endif\nreturn min(1.0,visibility+darkness);\r}\r#define inline\nfloat computeShadowWithESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\r{\rvec3 directionToLight=vPositionW-lightPosition;\rfloat depth=length(directionToLight);\rdepth=(depth+depthValues.x)/(depthValues.y);\rfloat shadowPixelDepth=clamp(depth,0.,1.0);\rdirectionToLight=normalize(directionToLight);\rdirectionToLight.y=-directionToLight.y;\r#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\r#else\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\r#endif\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness); \rreturn esm;\r}\r#define inline\nfloat computeShadowWithCloseESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\r{\rvec3 directionToLight=vPositionW-lightPosition;\rfloat depth=length(directionToLight);\rdepth=(depth+depthValues.x)/(depthValues.y);\rfloat shadowPixelDepth=clamp(depth,0.,1.0);\rdirectionToLight=normalize(directionToLight);\rdirectionToLight.y=-directionToLight.y;\r#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\r#else\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\r#endif\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);\rreturn esm;\r}\r#if defined(WEBGL2) || defined(WEBGPU)\n#define inline\nfloat computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec2 uv=0.5*clipSpace.xy+vec2(0.5);\rvec3 uvLayer=vec3(uv.x,uv.y,layer);\rfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\r#ifndef SHADOWFLOAT\nfloat shadow=unpack(texture2D(shadowSampler,uvLayer));\r#else\nfloat shadow=texture2D(shadowSampler,uvLayer).x;\r#endif\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;\r}\r#endif\n#define inline\nfloat computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec2 uv=0.5*clipSpace.xy+vec2(0.5);\rif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\r{\rreturn 1.0;\r}\relse\r{\rfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\r#ifndef SHADOWFLOAT\nfloat shadow=unpack(texture2D(shadowSampler,uv));\r#else\nfloat shadow=texture2D(shadowSampler,uv).x;\r#endif\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;\r}\r}\r#define inline\nfloat computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec2 uv=0.5*clipSpace.xy+vec2(0.5);\rif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\r{\rreturn 1.0;\r}\relse\r{\rfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\rfloat visibility=1.;\rvec2 poissonDisk[4];\rpoissonDisk[0]=vec2(-0.94201624,-0.39906216);\rpoissonDisk[1]=vec2(0.94558609,-0.76890725);\rpoissonDisk[2]=vec2(-0.094184101,-0.92938870);\rpoissonDisk[3]=vec2(0.34495938,0.29387760);\r#ifndef SHADOWFLOAT\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[0]*mapSize))<shadowPixelDepth) visibility-=0.25;\rif (unpack(texture2D(shadowSampler,uv+poissonDisk[1]*mapSize))<shadowPixelDepth) visibility-=0.25;\rif (unpack(texture2D(shadowSampler,uv+poissonDisk[2]*mapSize))<shadowPixelDepth) visibility-=0.25;\rif (unpack(texture2D(shadowSampler,uv+poissonDisk[3]*mapSize))<shadowPixelDepth) visibility-=0.25;\r#else\nif (texture2D(shadowSampler,uv+poissonDisk[0]*mapSize).x<shadowPixelDepth) visibility-=0.25;\rif (texture2D(shadowSampler,uv+poissonDisk[1]*mapSize).x<shadowPixelDepth) visibility-=0.25;\rif (texture2D(shadowSampler,uv+poissonDisk[2]*mapSize).x<shadowPixelDepth) visibility-=0.25;\rif (texture2D(shadowSampler,uv+poissonDisk[3]*mapSize).x<shadowPixelDepth) visibility-=0.25;\r#endif\nreturn computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);\r}\r}\r#define inline\nfloat computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec2 uv=0.5*clipSpace.xy+vec2(0.5);\rif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\r{\rreturn 1.0;\r}\relse\r{\rfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\r#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(texture2D(shadowSampler,uv));\r#else\nfloat shadowMapSample=texture2D(shadowSampler,uv).x;\r#endif\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);\rreturn computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);\r}\r}\r#define inline\nfloat computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec2 uv=0.5*clipSpace.xy+vec2(0.5);\rif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\r{\rreturn 1.0;\r}\relse\r{\rfloat shadowPixelDepth=clamp(depthMetric,0.,1.0); \r#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(texture2D(shadowSampler,uv));\r#else\nfloat shadowMapSample=texture2D(shadowSampler,uv).x;\r#endif\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);\rreturn computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);\r}\r}\r#ifdef IS_NDC_HALF_ZRANGE\n#define ZINCLIP clipSpace.z\n#else\n#define ZINCLIP uvDepth.z\n#endif\n#if defined(WEBGL2) || defined(WEBGPU)\n#define GREATEST_LESS_THAN_ONE 0.99999994\n#define inline\nfloat computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\ruvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\rvec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);\rfloat shadow=texture2D(shadowSampler,uvDepthLayer);\rshadow=mix(darkness,1.,shadow);\rreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\r}\r#define inline\nfloat computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\ruvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\rvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \ruv+=0.5; \rvec2 st=fract(uv); \rvec2 base_uv=floor(uv)-0.5; \rbase_uv*=shadowMapSizeAndInverse.y; \rvec2 uvw0=3.-2.*st;\rvec2 uvw1=1.+2.*st;\rvec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;\rvec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;\rfloat shadow=0.;\rshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));\rshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));\rshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));\rshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));\rshadow=shadow/16.;\rshadow=mix(darkness,1.,shadow);\rreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\r}\r#define inline\nfloat computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\ruvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\rvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \ruv+=0.5; \rvec2 st=fract(uv); \rvec2 base_uv=floor(uv)-0.5; \rbase_uv*=shadowMapSizeAndInverse.y; \rvec2 uvw0=4.-3.*st;\rvec2 uvw1=vec2(7.);\rvec2 uvw2=1.+3.*st;\rvec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;\rvec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;\rfloat shadow=0.;\rshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));\rshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));\rshadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));\rshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));\rshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));\rshadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));\rshadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));\rshadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));\rshadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));\rshadow=shadow/144.;\rshadow=mix(darkness,1.,shadow);\rreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\r}\r#define inline\nfloat computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)\r{\rif (depthMetric>1.0 || depthMetric<0.0) {\rreturn 1.0;\r}\relse\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\ruvDepth.z=ZINCLIP;\rfloat shadow=texture2D(shadowSampler,uvDepth);\rshadow=mix(darkness,1.,shadow);\rreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\r}\r}\r#define inline\nfloat computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\r{\rif (depthMetric>1.0 || depthMetric<0.0) {\rreturn 1.0;\r}\relse\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\ruvDepth.z=ZINCLIP;\rvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \ruv+=0.5; \rvec2 st=fract(uv); \rvec2 base_uv=floor(uv)-0.5; \rbase_uv*=shadowMapSizeAndInverse.y; \rvec2 uvw0=3.-2.*st;\rvec2 uvw1=1.+2.*st;\rvec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;\rvec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;\rfloat shadow=0.;\rshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z));\rshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z));\rshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z));\rshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z));\rshadow=shadow/16.;\rshadow=mix(darkness,1.,shadow);\rreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\r}\r}\r#define inline\nfloat computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\r{\rif (depthMetric>1.0 || depthMetric<0.0) {\rreturn 1.0;\r}\relse\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\ruvDepth.z=ZINCLIP;\rvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \ruv+=0.5; \rvec2 st=fract(uv); \rvec2 base_uv=floor(uv)-0.5; \rbase_uv*=shadowMapSizeAndInverse.y; \rvec2 uvw0=4.-3.*st;\rvec2 uvw1=vec2(7.);\rvec2 uvw2=1.+3.*st;\rvec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;\rvec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;\rfloat shadow=0.;\rshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z));\rshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z));\rshadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z));\rshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z));\rshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z));\rshadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z));\rshadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z));\rshadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z));\rshadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z));\rshadow=shadow/144.;\rshadow=mix(darkness,1.,shadow);\rreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\r}\r}\rconst vec3 PoissonSamplers32[64]=vec3[64](\rvec3(0.06407013,0.05409927,0.),\rvec3(0.7366577,0.5789394,0.),\rvec3(-0.6270542,-0.5320278,0.),\rvec3(-0.4096107,0.8411095,0.),\rvec3(0.6849564,-0.4990818,0.),\rvec3(-0.874181,-0.04579735,0.),\rvec3(0.9989998,0.0009880066,0.),\rvec3(-0.004920578,-0.9151649,0.),\rvec3(0.1805763,0.9747483,0.),\rvec3(-0.2138451,0.2635818,0.),\rvec3(0.109845,0.3884785,0.),\rvec3(0.06876755,-0.3581074,0.),\rvec3(0.374073,-0.7661266,0.),\rvec3(0.3079132,-0.1216763,0.),\rvec3(-0.3794335,-0.8271583,0.),\rvec3(-0.203878,-0.07715034,0.),\rvec3(0.5912697,0.1469799,0.),\rvec3(-0.88069,0.3031784,0.),\rvec3(0.5040108,0.8283722,0.),\rvec3(-0.5844124,0.5494877,0.),\rvec3(0.6017799,-0.1726654,0.),\rvec3(-0.5554981,0.1559997,0.),\rvec3(-0.3016369,-0.3900928,0.),\rvec3(-0.5550632,-0.1723762,0.),\rvec3(0.925029,0.2995041,0.),\rvec3(-0.2473137,0.5538505,0.),\rvec3(0.9183037,-0.2862392,0.),\rvec3(0.2469421,0.6718712,0.),\rvec3(0.3916397,-0.4328209,0.),\rvec3(-0.03576927,-0.6220032,0.),\rvec3(-0.04661255,0.7995201,0.),\rvec3(0.4402924,0.3640312,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.)\r);\rconst vec3 PoissonSamplers64[64]=vec3[64](\rvec3(-0.613392,0.617481,0.),\rvec3(0.170019,-0.040254,0.),\rvec3(-0.299417,0.791925,0.),\rvec3(0.645680,0.493210,0.),\rvec3(-0.651784,0.717887,0.),\rvec3(0.421003,0.027070,0.),\rvec3(-0.817194,-0.271096,0.),\rvec3(-0.705374,-0.668203,0.),\rvec3(0.977050,-0.108615,0.),\rvec3(0.063326,0.142369,0.),\rvec3(0.203528,0.214331,0.),\rvec3(-0.667531,0.326090,0.),\rvec3(-0.098422,-0.295755,0.),\rvec3(-0.885922,0.215369,0.),\rvec3(0.566637,0.605213,0.),\rvec3(0.039766,-0.396100,0.),\rvec3(0.751946,0.453352,0.),\rvec3(0.078707,-0.715323,0.),\rvec3(-0.075838,-0.529344,0.),\rvec3(0.724479,-0.580798,0.),\rvec3(0.222999,-0.215125,0.),\rvec3(-0.467574,-0.405438,0.),\rvec3(-0.248268,-0.814753,0.),\rvec3(0.354411,-0.887570,0.),\rvec3(0.175817,0.382366,0.),\rvec3(0.487472,-0.063082,0.),\rvec3(-0.084078,0.898312,0.),\rvec3(0.488876,-0.783441,0.),\rvec3(0.470016,0.217933,0.),\rvec3(-0.696890,-0.549791,0.),\rvec3(-0.149693,0.605762,0.),\rvec3(0.034211,0.979980,0.),\rvec3(0.503098,-0.308878,0.),\rvec3(-0.016205,-0.872921,0.),\rvec3(0.385784,-0.393902,0.),\rvec3(-0.146886,-0.859249,0.),\rvec3(0.643361,0.164098,0.),\rvec3(0.634388,-0.049471,0.),\rvec3(-0.688894,0.007843,0.),\rvec3(0.464034,-0.188818,0.),\rvec3(-0.440840,0.137486,0.),\rvec3(0.364483,0.511704,0.),\rvec3(0.034028,0.325968,0.),\rvec3(0.099094,-0.308023,0.),\rvec3(0.693960,-0.366253,0.),\rvec3(0.678884,-0.204688,0.),\rvec3(0.001801,0.780328,0.),\rvec3(0.145177,-0.898984,0.),\rvec3(0.062655,-0.611866,0.),\rvec3(0.315226,-0.604297,0.),\rvec3(-0.780145,0.486251,0.),\rvec3(-0.371868,0.882138,0.),\rvec3(0.200476,0.494430,0.),\rvec3(-0.494552,-0.711051,0.),\rvec3(0.612476,0.705252,0.),\rvec3(-0.578845,-0.768792,0.),\rvec3(-0.772454,-0.090976,0.),\rvec3(0.504440,0.372295,0.),\rvec3(0.155736,0.065157,0.),\rvec3(0.391522,0.849605,0.),\rvec3(-0.620106,-0.328104,0.),\rvec3(0.789239,-0.419965,0.),\rvec3(-0.545396,0.538133,0.),\rvec3(-0.178564,-0.596057,0.)\r);\r#define inline\nfloat computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\ruvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\rvec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);\rfloat blockerDepth=0.0;\rfloat sumBlockerDepth=0.0;\rfloat numBlocker=0.0;\rfor (int i=0; i<searchTapCount; i ++) {\rblockerDepth=texture2D(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;\rif (blockerDepth<depthMetric) {\rsumBlockerDepth+=blockerDepth;\rnumBlocker++;\r}\r}\rif (numBlocker<1.0) {\rreturn 1.0;\r}\relse\r{\rfloat avgBlockerDepth=sumBlockerDepth/numBlocker;\rfloat AAOffset=shadowMapSizeInverse*10.;\rfloat penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);\rvec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);\rfloat random=getRand(vPositionFromLight.xy);\rfloat rotationAngle=random*3.1415926;\rvec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));\rfloat shadow=0.;\rfor (int i=0; i<pcfTapCount; i++) {\rvec4 offset=vec4(poissonSamplers[i],0.);\roffset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);\rshadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);\r}\rshadow/=float(pcfTapCount);\rshadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));\rshadow=mix(darkness,1.,shadow);\rreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\r}\r}\r#define inline\nfloat computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)\r{\rif (depthMetric>1.0 || depthMetric<0.0) {\rreturn 1.0;\r}\relse\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\ruvDepth.z=ZINCLIP;\rfloat blockerDepth=0.0;\rfloat sumBlockerDepth=0.0;\rfloat numBlocker=0.0;\rfor (int i=0; i<searchTapCount; i ++) {\rblockerDepth=texture2D(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy)).r;\rif (blockerDepth<depthMetric) {\rsumBlockerDepth+=blockerDepth;\rnumBlocker++;\r}\r}\rif (numBlocker<1.0) {\rreturn 1.0;\r}\relse\r{\rfloat avgBlockerDepth=sumBlockerDepth/numBlocker;\rfloat AAOffset=shadowMapSizeInverse*10.;\rfloat penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);\rfloat filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;\rfloat random=getRand(vPositionFromLight.xy);\rfloat rotationAngle=random*3.1415926;\rvec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));\rfloat shadow=0.;\rfor (int i=0; i<pcfTapCount; i++) {\rvec3 offset=poissonSamplers[i];\roffset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);\rshadow+=texture2D(shadowSampler,uvDepth+offset*filterRadius);\r}\rshadow/=float(pcfTapCount);\rshadow=mix(shadow,1.,depthMetric-avgBlockerDepth);\rshadow=mix(darkness,1.,shadow);\rreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\r}\r}\r}\r#define inline\nfloat computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\r{\rreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);\r}\r#define inline\nfloat computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\r{\rreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);\r}\r#define inline\nfloat computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\r{\rreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);\r}\r#define inline\nfloat computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\r{\rreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\r}\r#define inline\nfloat computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\r{\rreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\r}\r#define inline\nfloat computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\r{\rreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\r}\r#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport const shadowsFragmentFunctions = { name, shader };\n"]}