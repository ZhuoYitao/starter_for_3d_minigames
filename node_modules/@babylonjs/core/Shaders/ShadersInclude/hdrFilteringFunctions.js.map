{"version":3,"file":"hdrFilteringFunctions.js","sourceRoot":"","sources":["../../../../../../lts/core/generated/Shaders/ShadersInclude/hdrFilteringFunctions.ts"],"names":[],"mappings":"AAAA,eAAe;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,2BAA2B,CAAC;AAExD,IAAM,IAAI,GAAG,uBAAuB,CAAC;AACrC,IAAM,MAAM,GAAG,m8GAwId,CAAC;AACF,aAAa;AACb,WAAW,CAAC,oBAAoB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,cAAc;AACd,MAAM,CAAC,IAAM,qBAAqB,GAAG,EAAE,IAAI,MAAA,EAAE,MAAM,QAAA,EAAE,CAAC","sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"hdrFilteringFunctions\";\nconst shader = `#ifdef NUM_SAMPLES\n#if NUM_SAMPLES>0\n#if defined(WEBGL2) || defined(WEBGPU)\nfloat radicalInverse_VdC(uint bits) \r{\rbits=(bits<<16u) | (bits>>16u);\rbits=((bits & 0x55555555u)<<1u) | ((bits & 0xAAAAAAAAu)>>1u);\rbits=((bits & 0x33333333u)<<2u) | ((bits & 0xCCCCCCCCu)>>2u);\rbits=((bits & 0x0F0F0F0Fu)<<4u) | ((bits & 0xF0F0F0F0u)>>4u);\rbits=((bits & 0x00FF00FFu)<<8u) | ((bits & 0xFF00FF00u)>>8u);\rreturn float(bits)*2.3283064365386963e-10; \r}\rvec2 hammersley(uint i,uint N)\r{\rreturn vec2(float(i)/float(N),radicalInverse_VdC(i));\r}\r#else\nfloat vanDerCorpus(int n,int base)\r{\rfloat invBase=1.0/float(base);\rfloat denom =1.0;\rfloat result =0.0;\rfor(int i=0; i<32; ++i)\r{\rif(n>0)\r{\rdenom =mod(float(n),2.0);\rresult+=denom*invBase;\rinvBase=invBase/2.0;\rn =int(float(n)/2.0);\r}\r}\rreturn result;\r}\rvec2 hammersley(int i,int N)\r{\rreturn vec2(float(i)/float(N),vanDerCorpus(i,2));\r}\r#endif\nfloat log4(float x) {\rreturn log2(x)/2.;\r}\rconst float NUM_SAMPLES_FLOAT=float(NUM_SAMPLES);\rconst float NUM_SAMPLES_FLOAT_INVERSED=1./NUM_SAMPLES_FLOAT;\rconst float K=4.;\r#define inline\nvec3 irradiance(samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)\r{\rvec3 n=normalize(inputN);\rvec3 result=vec3(0.0);\rvec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);\rtangent=normalize(cross(tangent,n));\rvec3 bitangent=cross(n,tangent);\rmat3 tbn=mat3(tangent,bitangent,n);\rfloat maxLevel=filteringInfo.y;\rfloat dim0=filteringInfo.x;\rfloat omegaP=(4.*PI)/(6.*dim0*dim0);\r#if defined(WEBGL2) || defined(WEBGPU)\nfor(uint i=0u; i<NUM_SAMPLES; ++i)\r#else\nfor(int i=0; i<NUM_SAMPLES; ++i)\r#endif\n{\rvec2 Xi=hammersley(i,NUM_SAMPLES);\rvec3 Ls=hemisphereCosSample(Xi);\rLs=normalize(Ls);\rvec3 Ns=vec3(0.,0.,1.);\rfloat NoL=dot(Ns,Ls);\rif (NoL>0.) {\rfloat pdf_inversed=PI/NoL;\rfloat omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;\rfloat l=log4(omegaS)-log4(omegaP)+log4(K);\rfloat mipLevel=clamp(l,0.0,maxLevel);\rvec3 c=textureCubeLodEXT(inputTexture,tbn*Ls,mipLevel).rgb;\r#ifdef GAMMA_INPUT\nc=toLinearSpace(c);\r#endif\nresult+=c;\r}\r}\rresult=result*NUM_SAMPLES_FLOAT_INVERSED;\rreturn result;\r}\r#define inline\nvec3 radiance(float alphaG,samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)\r{\rvec3 n=normalize(inputN);\rif (alphaG==0.) {\rvec3 c=textureCube(inputTexture,n).rgb;\r#ifdef GAMMA_INPUT\nc=toLinearSpace(c);\r#endif\nreturn c;\r} else {\rvec3 result=vec3(0.);\rvec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);\rtangent=normalize(cross(tangent,n));\rvec3 bitangent=cross(n,tangent);\rmat3 tbn=mat3(tangent,bitangent,n);\rfloat maxLevel=filteringInfo.y;\rfloat dim0=filteringInfo.x;\rfloat omegaP=(4.*PI)/(6.*dim0*dim0);\rfloat weight=0.;\r#if defined(WEBGL2) || defined(WEBGPU)\nfor(uint i=0u; i<NUM_SAMPLES; ++i)\r#else\nfor(int i=0; i<NUM_SAMPLES; ++i)\r#endif\n{\rvec2 Xi=hammersley(i,NUM_SAMPLES);\rvec3 H=hemisphereImportanceSampleDggx(Xi,alphaG);\rfloat NoV=1.;\rfloat NoH=H.z;\rfloat NoH2=H.z*H.z;\rfloat NoL=2.*NoH2-1.;\rvec3 L=vec3(2.*NoH*H.x,2.*NoH*H.y,NoL);\rL=normalize(L);\rif (NoL>0.) {\rfloat pdf_inversed=4./normalDistributionFunction_TrowbridgeReitzGGX(NoH,alphaG);\rfloat omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;\rfloat l=log4(omegaS)-log4(omegaP)+log4(K);\rfloat mipLevel=clamp(float(l),0.0,maxLevel);\rweight+=NoL;\rvec3 c=textureCubeLodEXT(inputTexture,tbn*L,mipLevel).rgb;\r#ifdef GAMMA_INPUT\nc=toLinearSpace(c);\r#endif\nresult+=c*NoL;\r}\r}\rresult=result/weight;\rreturn result;\r}\r}\r#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport const hdrFilteringFunctions = { name, shader };\n"]}