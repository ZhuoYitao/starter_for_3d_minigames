{"version":3,"file":"webgpuMaterialContext.js","sourceRoot":"","sources":["../../../../../../lts/core/generated/Engines/WebGPU/webgpuMaterialContext.ts"],"names":[],"mappings":"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","sourcesContent":["import { ExternalTexture } from \"../../Materials/Textures/externalTexture\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { TextureSampler } from \"../../Materials/Textures/textureSampler\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../constants\";\r\nimport type { IMaterialContext } from \"../IMaterialContext\";\r\nimport { WebGPUCacheSampler } from \"./webgpuCacheSampler\";\r\n\r\n/** @hidden */\r\ninterface IWebGPUMaterialContextSamplerCache {\r\n    sampler: Nullable<TextureSampler>;\r\n    hashCode: number;\r\n}\r\n\r\n/** @hidden */\r\ninterface IWebGPUMaterialContextTextureCache {\r\n    texture: Nullable<InternalTexture | ExternalTexture>;\r\n    isFloatTexture: boolean;\r\n    isExternalTexture: boolean;\r\n}\r\n\r\n/** @hidden */\r\nexport class WebGPUMaterialContext implements IMaterialContext {\r\n    private static _Counter = 0;\r\n\r\n    public uniqueId: number;\r\n    public updateId: number;\r\n    public isDirty: boolean;\r\n    public samplers: { [name: string]: Nullable<IWebGPUMaterialContextSamplerCache> };\r\n    public textures: { [name: string]: Nullable<IWebGPUMaterialContextTextureCache> };\r\n\r\n    public get forceBindGroupCreation() {\r\n        // If there is at least one external texture to bind, we must recreate the bind groups each time\r\n        // because we need to retrieve a new texture each frame (by calling device.importExternalTexture)\r\n        return this._numExternalTextures > 0;\r\n    }\r\n\r\n    public get hasFloatTextures() {\r\n        return this._numFloatTextures > 0;\r\n    }\r\n\r\n    protected _numFloatTextures: number;\r\n    protected _numExternalTextures: number;\r\n\r\n    constructor() {\r\n        this.uniqueId = WebGPUMaterialContext._Counter++;\r\n        this.updateId = 0;\r\n        this.reset();\r\n    }\r\n\r\n    public reset(): void {\r\n        this.samplers = {};\r\n        this.textures = {};\r\n        this.isDirty = true;\r\n        this._numFloatTextures = 0;\r\n        this._numExternalTextures = 0;\r\n    }\r\n\r\n    public setSampler(name: string, sampler: Nullable<TextureSampler>): void {\r\n        let samplerCache = this.samplers[name];\r\n        let currentHashCode = -1;\r\n        if (!samplerCache) {\r\n            this.samplers[name] = samplerCache = { sampler, hashCode: 0 };\r\n        } else {\r\n            currentHashCode = samplerCache.hashCode;\r\n        }\r\n\r\n        samplerCache.sampler = sampler;\r\n        samplerCache.hashCode = sampler ? WebGPUCacheSampler.GetSamplerHashCode(sampler) : 0;\r\n\r\n        const isDirty = currentHashCode !== samplerCache.hashCode;\r\n        if (isDirty) {\r\n            this.updateId++;\r\n        }\r\n\r\n        this.isDirty ||= isDirty;\r\n    }\r\n\r\n    public setTexture(name: string, texture: Nullable<InternalTexture | ExternalTexture>): void {\r\n        let textureCache = this.textures[name];\r\n        let currentTextureId = -1;\r\n        if (!textureCache) {\r\n            this.textures[name] = textureCache = { texture, isFloatTexture: false, isExternalTexture: false };\r\n        } else {\r\n            currentTextureId = textureCache.texture?.uniqueId ?? -1;\r\n        }\r\n\r\n        if (textureCache.isExternalTexture) {\r\n            this._numExternalTextures--;\r\n        }\r\n        if (textureCache.isFloatTexture) {\r\n            this._numFloatTextures--;\r\n        }\r\n\r\n        if (texture) {\r\n            textureCache.isFloatTexture = texture.type === Constants.TEXTURETYPE_FLOAT;\r\n            textureCache.isExternalTexture = ExternalTexture.IsExternalTexture(texture);\r\n            if (textureCache.isFloatTexture) {\r\n                this._numFloatTextures++;\r\n            }\r\n            if (textureCache.isExternalTexture) {\r\n                this._numExternalTextures++;\r\n            }\r\n        } else {\r\n            textureCache.isFloatTexture = false;\r\n            textureCache.isExternalTexture = false;\r\n        }\r\n\r\n        textureCache.texture = texture;\r\n\r\n        const isDirty = currentTextureId !== (texture?.uniqueId ?? -1);\r\n        if (isDirty) {\r\n            this.updateId++;\r\n        }\r\n\r\n        this.isDirty ||= isDirty;\r\n    }\r\n}\r\n"]}