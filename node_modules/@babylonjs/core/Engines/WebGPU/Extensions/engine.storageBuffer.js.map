{"version":3,"file":"engine.storageBuffer.js","sourceRoot":"","sources":["../../../../../../../lts/core/generated/Engines/WebGPU/Extensions/engine.storageBuffer.ts"],"names":[],"mappings":"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","sourcesContent":["import type { DataBuffer } from \"../../../Buffers/dataBuffer\";\r\nimport type { WebGPUDataBuffer } from \"../../../Meshes/WebGPU/webgpuDataBuffer\";\r\nimport type { DataArray, Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport * as WebGPUConstants from \"../webgpuConstants\";\r\nimport { Effect } from \"../../../Materials/effect\";\r\n\r\ndeclare type StorageBuffer = import(\"../../../Buffers/storageBuffer\").StorageBuffer;\r\n\r\ndeclare module \"../../../Materials/effect\" {\r\n    export interface Effect {\r\n        /**\r\n         * Sets a storage buffer on the engine to be used in the shader.\r\n         * @param name Name of the storage buffer variable.\r\n         * @param buffer Storage buffer to set.\r\n         */\r\n        setStorageBuffer(name: string, buffer: Nullable<StorageBuffer>): void;\r\n    }\r\n}\r\n\r\nEffect.prototype.setStorageBuffer = function (name: string, buffer: Nullable<StorageBuffer>): void {\r\n    this._engine.setStorageBuffer(name, buffer);\r\n};\r\n\r\nWebGPUEngine.prototype.createStorageBuffer = function (data: DataArray | number, creationFlags: number): DataBuffer {\r\n    return this._createBuffer(data, creationFlags | Constants.BUFFER_CREATIONFLAG_STORAGE);\r\n};\r\n\r\nWebGPUEngine.prototype.updateStorageBuffer = function (buffer: DataBuffer, data: DataArray, byteOffset?: number, byteLength?: number): void {\r\n    const dataBuffer = buffer as WebGPUDataBuffer;\r\n    if (byteOffset === undefined) {\r\n        byteOffset = 0;\r\n    }\r\n\r\n    let view: ArrayBufferView;\r\n    if (byteLength === undefined) {\r\n        if (data instanceof Array) {\r\n            view = new Float32Array(data);\r\n        } else if (data instanceof ArrayBuffer) {\r\n            view = new Uint8Array(data);\r\n        } else {\r\n            view = data;\r\n        }\r\n        byteLength = view.byteLength;\r\n    } else {\r\n        if (data instanceof Array) {\r\n            view = new Float32Array(data);\r\n        } else if (data instanceof ArrayBuffer) {\r\n            view = new Uint8Array(data);\r\n        } else {\r\n            view = data;\r\n        }\r\n    }\r\n\r\n    this._bufferManager.setSubData(dataBuffer, byteOffset, view, 0, byteLength);\r\n};\r\n\r\nWebGPUEngine.prototype.readFromStorageBuffer = function (storageBuffer: DataBuffer, offset?: number, size?: number, buffer?: ArrayBufferView): Promise<ArrayBufferView> {\r\n    size = size || storageBuffer.capacity;\r\n\r\n    const gpuBuffer = this._bufferManager.createRawBuffer(size, WebGPUConstants.BufferUsage.MapRead | WebGPUConstants.BufferUsage.CopyDst);\r\n\r\n    this._renderTargetEncoder.copyBufferToBuffer(storageBuffer.underlyingResource, offset ?? 0, gpuBuffer, 0, size);\r\n\r\n    return new Promise((resolve, reject) => {\r\n        // we are using onEndFrameObservable because we need to map the gpuBuffer AFTER the command buffers\r\n        // have been submitted, else we get the error: \"Buffer used in a submit while mapped\"\r\n        this.onEndFrameObservable.addOnce(() => {\r\n            gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read, 0, size).then(\r\n                () => {\r\n                    const copyArrayBuffer = gpuBuffer.getMappedRange(0, size);\r\n                    let data: ArrayBufferView | undefined = buffer;\r\n                    if (data === undefined) {\r\n                        data = new Uint8Array(size!);\r\n                        (data as Uint8Array).set(new Uint8Array(copyArrayBuffer));\r\n                    } else {\r\n                        const ctor = data.constructor as any; // we want to create result data with the same type as buffer (Uint8Array, Float32Array, ...)\r\n                        data = new ctor(data.buffer);\r\n                        (data as any).set(new ctor(copyArrayBuffer));\r\n                    }\r\n                    gpuBuffer.unmap();\r\n                    this._bufferManager.releaseBuffer(gpuBuffer);\r\n                    resolve(data!);\r\n                },\r\n                (reason) => reject(reason)\r\n            );\r\n        });\r\n    });\r\n};\r\n\r\nWebGPUEngine.prototype.setStorageBuffer = function (name: string, buffer: Nullable<StorageBuffer>): void {\r\n    this._currentDrawContext?.setBuffer(name, (buffer?.getBuffer() as WebGPUDataBuffer) ?? null);\r\n};\r\n"]}