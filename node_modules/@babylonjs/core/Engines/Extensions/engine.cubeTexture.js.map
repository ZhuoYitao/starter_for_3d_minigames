{"version":3,"file":"engine.cubeTexture.js","sourceRoot":"","sources":["../../../../../../lts/core/generated/Engines/Extensions/engine.cubeTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { IInternalTextureLoader } from \"../../Materials/Textures/internalTextureLoader\";\r\nimport { LoadImage } from \"../../Misc/fileTools\";\r\nimport { RandomGUID } from \"../../Misc/guid\";\r\nimport type { IWebRequest } from \"../../Misc/interfaces/iWebRequest\";\r\nimport { Constants } from \"../constants\";\r\nimport type { DepthTextureCreationOptions } from \"../../Materials/Textures/textureCreationOptions\";\r\nimport type { RenderTargetWrapper } from \"../renderTargetWrapper\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates a depth stencil cube texture.\r\n         * This is only available in WebGL 2.\r\n         * @param size The size of face edge in the cube texture.\r\n         * @param options The options defining the cube texture.\r\n         * @param rtWrapper The render target wrapper for which the depth/stencil texture must be created\r\n         * @returns The cube texture\r\n         */\r\n        _createDepthStencilCubeTexture(size: number, options: DepthTextureCreationOptions, rtWrapper: RenderTargetWrapper): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @param createPolynomials if a polynomial sphere should be created for the cube texture\r\n         * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n         * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n         * @param fallback defines texture to use while falling back when (compressed) texture file not found.\r\n         * @param loaderOptions options to be passed to the loader\r\n         * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean | undefined,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number,\r\n            fallback: Nullable<InternalTexture>,\r\n            loaderOptions: any,\r\n            useSRGBBuffer: boolean\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @param createPolynomials if a polynomial sphere should be created for the cube texture\r\n         * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n         * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number\r\n        ): InternalTexture;\r\n\r\n        /** @hidden */\r\n        createCubeTextureBase(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number,\r\n            fallback: Nullable<InternalTexture>,\r\n            beforeLoadCubeDataCallback: Nullable<(texture: InternalTexture, data: ArrayBufferView | ArrayBufferView[]) => void>,\r\n            imageHandler: Nullable<(texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            useSRGBBuffer: boolean\r\n        ): InternalTexture;\r\n\r\n        /** @hidden */\r\n        _partialLoadFile(\r\n            url: string,\r\n            index: number,\r\n            loadedFiles: ArrayBuffer[],\r\n            onfinish: (files: ArrayBuffer[]) => void,\r\n            onErrorCallBack: Nullable<(message?: string, exception?: any) => void>\r\n        ): void;\r\n\r\n        /** @hidden */\r\n        _cascadeLoadFiles(scene: Nullable<Scene>, onfinish: (images: ArrayBuffer[]) => void, files: string[], onError: Nullable<(message?: string, exception?: any) => void>): void;\r\n\r\n        /** @hidden */\r\n        _cascadeLoadImgs(\r\n            scene: Nullable<Scene>,\r\n            texture: InternalTexture,\r\n            onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            files: string[],\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            mimeType?: string\r\n        ): void;\r\n\r\n        /** @hidden */\r\n        _partialLoadImg(\r\n            url: string,\r\n            index: number,\r\n            loadedImages: HTMLImageElement[] | ImageBitmap[],\r\n            scene: Nullable<Scene>,\r\n            texture: InternalTexture,\r\n            onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            onErrorCallBack: Nullable<(message?: string, exception?: any) => void>,\r\n            mimeType?: string\r\n        ): void;\r\n\r\n        /**\r\n         * @hidden\r\n         */\r\n        _setCubeMapTextureParams(texture: InternalTexture, loadMipmap: boolean, maxLevel?: number): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype._createDepthStencilCubeTexture = function (size: number, options: DepthTextureCreationOptions, rtWrapper: RenderTargetWrapper): InternalTexture {\r\n    const internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);\r\n    internalTexture.isCube = true;\r\n\r\n    if (this.webGLVersion === 1) {\r\n        Logger.Error(\"Depth cube texture is not supported by WebGL 1.\");\r\n        return internalTexture;\r\n    }\r\n\r\n    const internalOptions = {\r\n        bilinearFiltering: false,\r\n        comparisonFunction: 0,\r\n        generateStencil: false,\r\n        ...options,\r\n    };\r\n\r\n    const gl = this._gl;\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, internalTexture, true);\r\n\r\n    this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.bilinearFiltering, internalOptions.comparisonFunction);\r\n\r\n    rtWrapper._depthStencilTexture = internalTexture;\r\n    rtWrapper._depthStencilTextureWithStencil = internalOptions.generateStencil;\r\n\r\n    // Create the depth/stencil buffer\r\n    for (let face = 0; face < 6; face++) {\r\n        if (internalOptions.generateStencil) {\r\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH24_STENCIL8, size, size, 0, gl.DEPTH_STENCIL, gl.UNSIGNED_INT_24_8, null);\r\n        } else {\r\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH_COMPONENT24, size, size, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);\r\n        }\r\n    }\r\n\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n\r\n    this._internalTexturesCache.push(internalTexture);\r\n\r\n    return internalTexture;\r\n};\r\n\r\nThinEngine.prototype._partialLoadFile = function (\r\n    url: string,\r\n    index: number,\r\n    loadedFiles: ArrayBuffer[],\r\n    onfinish: (files: ArrayBuffer[]) => void,\r\n    onErrorCallBack: Nullable<(message?: string, exception?: any) => void> = null\r\n): void {\r\n    const onload = (data: ArrayBuffer) => {\r\n        loadedFiles[index] = data;\r\n        (<any>loadedFiles)._internalCount++;\r\n\r\n        if ((<any>loadedFiles)._internalCount === 6) {\r\n            onfinish(loadedFiles);\r\n        }\r\n    };\r\n\r\n    const onerror = (request?: IWebRequest, exception?: any) => {\r\n        if (onErrorCallBack && request) {\r\n            onErrorCallBack(request.status + \" \" + request.statusText, exception);\r\n        }\r\n    };\r\n\r\n    this._loadFile(url, onload as (data: string | ArrayBuffer) => void, undefined, undefined, true, onerror);\r\n};\r\n\r\nThinEngine.prototype._cascadeLoadFiles = function (\r\n    scene: Nullable<Scene>,\r\n    onfinish: (images: ArrayBuffer[]) => void,\r\n    files: string[],\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null\r\n): void {\r\n    const loadedFiles: ArrayBuffer[] = [];\r\n    (<any>loadedFiles)._internalCount = 0;\r\n\r\n    for (let index = 0; index < 6; index++) {\r\n        this._partialLoadFile(files[index], index, loadedFiles, onfinish, onError);\r\n    }\r\n};\r\n\r\nThinEngine.prototype._cascadeLoadImgs = function (\r\n    scene: Nullable<Scene>,\r\n    texture: InternalTexture,\r\n    onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n    files: string[],\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    mimeType?: string\r\n) {\r\n    const loadedImages: HTMLImageElement[] | ImageBitmap[] = [];\r\n    (<any>loadedImages)._internalCount = 0;\r\n\r\n    for (let index = 0; index < 6; index++) {\r\n        this._partialLoadImg(files[index], index, loadedImages, scene, texture, onfinish, onError, mimeType);\r\n    }\r\n};\r\n\r\nThinEngine.prototype._partialLoadImg = function (\r\n    url: string,\r\n    index: number,\r\n    loadedImages: HTMLImageElement[] | ImageBitmap[],\r\n    scene: Nullable<Scene>,\r\n    texture: InternalTexture,\r\n    onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n    onErrorCallBack: Nullable<(message?: string, exception?: any) => void> = null,\r\n    mimeType?: string\r\n) {\r\n    const tokenPendingData = RandomGUID();\r\n\r\n    const onload = (img: HTMLImageElement | ImageBitmap) => {\r\n        loadedImages[index] = img;\r\n        (<any>loadedImages)._internalCount++;\r\n\r\n        if (scene) {\r\n            scene._removePendingData(tokenPendingData);\r\n        }\r\n\r\n        if ((<any>loadedImages)._internalCount === 6 && onfinish) {\r\n            onfinish(texture, loadedImages);\r\n        }\r\n    };\r\n\r\n    const onerror = (message?: string, exception?: any) => {\r\n        if (scene) {\r\n            scene._removePendingData(tokenPendingData);\r\n        }\r\n\r\n        if (onErrorCallBack) {\r\n            onErrorCallBack(message, exception);\r\n        }\r\n    };\r\n\r\n    LoadImage(url, onload, onerror, scene ? scene.offlineProvider : null, mimeType);\r\n    if (scene) {\r\n        scene._addPendingData(tokenPendingData);\r\n    }\r\n};\r\n\r\nThinEngine.prototype._setCubeMapTextureParams = function (texture: InternalTexture, loadMipmap: boolean, maxLevel?: number): void {\r\n    const gl = this._gl;\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, loadMipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    texture.samplingMode = loadMipmap ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : Constants.TEXTURE_LINEAR_LINEAR;\r\n\r\n    if (loadMipmap && this.getCaps().textureMaxLevel && maxLevel !== undefined && maxLevel > 0) {\r\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAX_LEVEL, maxLevel);\r\n        texture._maxLodLevel = maxLevel;\r\n    }\r\n\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n};\r\n\r\nThinEngine.prototype.createCubeTextureBase = function (\r\n    rootUrl: string,\r\n    scene: Nullable<Scene>,\r\n    files: Nullable<string[]>,\r\n    noMipmap?: boolean,\r\n    onLoad: Nullable<(data?: any) => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    format?: number,\r\n    forcedExtension: any = null,\r\n    createPolynomials: boolean = false,\r\n    lodScale: number = 0,\r\n    lodOffset: number = 0,\r\n    fallback: Nullable<InternalTexture> = null,\r\n    beforeLoadCubeDataCallback: Nullable<(texture: InternalTexture, data: ArrayBufferView | ArrayBufferView[]) => void> = null,\r\n    imageHandler: Nullable<(texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => void> = null,\r\n    useSRGBBuffer = false\r\n): InternalTexture {\r\n    const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);\r\n    texture.isCube = true;\r\n    texture.url = rootUrl;\r\n    texture.generateMipMaps = !noMipmap;\r\n    texture._lodGenerationScale = lodScale;\r\n    texture._lodGenerationOffset = lodOffset;\r\n    texture._useSRGBBuffer = !!useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU || !!noMipmap);\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._extension = forcedExtension;\r\n        texture._files = files;\r\n    }\r\n\r\n    const originalRootUrl = rootUrl;\r\n    if (this._transformTextureUrl && !fallback) {\r\n        rootUrl = this._transformTextureUrl(rootUrl);\r\n    }\r\n\r\n    const lastDot = rootUrl.lastIndexOf(\".\");\r\n    const extension = forcedExtension ? forcedExtension : lastDot > -1 ? rootUrl.substring(lastDot).toLowerCase() : \"\";\r\n\r\n    let loader: Nullable<IInternalTextureLoader> = null;\r\n    for (const availableLoader of ThinEngine._TextureLoaders) {\r\n        if (availableLoader.canLoad(extension)) {\r\n            loader = availableLoader;\r\n            break;\r\n        }\r\n    }\r\n\r\n    const onInternalError = (request?: IWebRequest, exception?: any) => {\r\n        if (rootUrl === originalRootUrl) {\r\n            if (onError && request) {\r\n                onError(request.status + \" \" + request.statusText, exception);\r\n            }\r\n        } else {\r\n            // fall back to the original url if the transformed url fails to load\r\n            Logger.Warn(`Failed to load ${rootUrl}, falling back to the ${originalRootUrl}`);\r\n            this.createCubeTextureBase(\r\n                originalRootUrl,\r\n                scene,\r\n                files,\r\n                !!noMipmap,\r\n                onLoad,\r\n                onError,\r\n                format,\r\n                forcedExtension,\r\n                createPolynomials,\r\n                lodScale,\r\n                lodOffset,\r\n                texture,\r\n                beforeLoadCubeDataCallback,\r\n                imageHandler,\r\n                useSRGBBuffer\r\n            );\r\n        }\r\n    };\r\n\r\n    if (loader) {\r\n        const onloaddata = (data: ArrayBufferView | ArrayBufferView[]) => {\r\n            if (beforeLoadCubeDataCallback) {\r\n                beforeLoadCubeDataCallback(texture, data);\r\n            }\r\n            loader!.loadCubeData(data, texture, createPolynomials, onLoad, onError);\r\n        };\r\n        if (files && files.length === 6) {\r\n            if (loader.supportCascades) {\r\n                this._cascadeLoadFiles(scene, (images) => onloaddata(images.map((image) => new Uint8Array(image))), files, onError);\r\n            } else {\r\n                if (onError) {\r\n                    onError(\"Textures type does not support cascades.\");\r\n                } else {\r\n                    Logger.Warn(\"Texture loader does not support cascades.\");\r\n                }\r\n            }\r\n        } else {\r\n            this._loadFile(rootUrl, (data) => onloaddata(new Uint8Array(data as ArrayBuffer)), undefined, undefined, true, onInternalError);\r\n        }\r\n    } else {\r\n        if (!files) {\r\n            throw new Error(\"Cannot load cubemap because files were not defined\");\r\n        }\r\n\r\n        this._cascadeLoadImgs(\r\n            scene,\r\n            texture,\r\n            (texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => {\r\n                if (imageHandler) {\r\n                    imageHandler(texture, imgs);\r\n                }\r\n            },\r\n            files,\r\n            onError\r\n        );\r\n    }\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.createCubeTexture = function (\r\n    rootUrl: string,\r\n    scene: Nullable<Scene>,\r\n    files: Nullable<string[]>,\r\n    noMipmap?: boolean,\r\n    onLoad: Nullable<(data?: any) => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    format?: number,\r\n    forcedExtension: any = null,\r\n    createPolynomials: boolean = false,\r\n    lodScale: number = 0,\r\n    lodOffset: number = 0,\r\n    fallback: Nullable<InternalTexture> = null,\r\n    loaderOptions?: any,\r\n    useSRGBBuffer = false\r\n): InternalTexture {\r\n    const gl = this._gl;\r\n\r\n    return this.createCubeTextureBase(\r\n        rootUrl,\r\n        scene,\r\n        files,\r\n        !!noMipmap,\r\n        onLoad,\r\n        onError,\r\n        format,\r\n        forcedExtension,\r\n        createPolynomials,\r\n        lodScale,\r\n        lodOffset,\r\n        fallback,\r\n        (texture: InternalTexture) => this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true),\r\n        (texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => {\r\n            const width = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(imgs[0].width, this._caps.maxCubemapTextureSize) : imgs[0].width;\r\n            const height = width;\r\n\r\n            const faces = [\r\n                gl.TEXTURE_CUBE_MAP_POSITIVE_X,\r\n                gl.TEXTURE_CUBE_MAP_POSITIVE_Y,\r\n                gl.TEXTURE_CUBE_MAP_POSITIVE_Z,\r\n                gl.TEXTURE_CUBE_MAP_NEGATIVE_X,\r\n                gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,\r\n                gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,\r\n            ];\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n            this._unpackFlipY(false);\r\n\r\n            const internalFormat = format ? this._getInternalFormat(format, texture._useSRGBBuffer) : texture._useSRGBBuffer ? gl.SRGB8_ALPHA8 : gl.RGBA;\r\n            let texelFormat = format ? this._getInternalFormat(format) : gl.RGBA;\r\n\r\n            if (texture._useSRGBBuffer && this.webGLVersion === 1) {\r\n                texelFormat = internalFormat;\r\n            }\r\n\r\n            for (let index = 0; index < faces.length; index++) {\r\n                if (imgs[index].width !== width || imgs[index].height !== height) {\r\n                    this._prepareWorkingCanvas();\r\n\r\n                    if (!this._workingCanvas || !this._workingContext) {\r\n                        Logger.Warn(\"Cannot create canvas to resize texture.\");\r\n                        return;\r\n                    }\r\n                    this._workingCanvas.width = width;\r\n                    this._workingCanvas.height = height;\r\n\r\n                    this._workingContext.drawImage(imgs[index], 0, 0, imgs[index].width, imgs[index].height, 0, 0, width, height);\r\n                    gl.texImage2D(faces[index], 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, this._workingCanvas as TexImageSource);\r\n                } else {\r\n                    gl.texImage2D(faces[index], 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, imgs[index]);\r\n                }\r\n            }\r\n\r\n            if (!noMipmap) {\r\n                gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\r\n            }\r\n\r\n            this._setCubeMapTextureParams(texture, !noMipmap);\r\n\r\n            texture.width = width;\r\n            texture.height = height;\r\n            texture.isReady = true;\r\n            if (format) {\r\n                texture.format = format;\r\n            }\r\n\r\n            texture.onLoadedObservable.notifyObservers(texture);\r\n            texture.onLoadedObservable.clear();\r\n\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n        },\r\n        !!useSRGBBuffer\r\n    );\r\n};\r\n"]}