import { __assign } from "tslib";
import { Matrix, Vector3, Vector2 } from "../../Maths/math.vector.js";
import { Color4 } from "../../Maths/math.color.js";
import { VertexBuffer } from "../../Buffers/buffer.js";
import { Light } from "../../Lights/light.js";
import { MaterialHelper } from "../../Materials/materialHelper.js";
import { Texture } from "../../Materials/Textures/texture.js";
import { RenderTargetTexture } from "../../Materials/Textures/renderTargetTexture.js";
import { PostProcess } from "../../PostProcesses/postProcess.js";
import { BlurPostProcess } from "../../PostProcesses/blurPostProcess.js";

import { Observable } from "../../Misc/observable.js";
import { _WarnImport } from "../../Misc/devTools.js";
import { EffectFallbacks } from "../../Materials/effectFallbacks.js";
import { RenderingManager } from "../../Rendering/renderingManager.js";
import { DrawWrapper } from "../../Materials/drawWrapper.js";
import "../../Shaders/shadowMap.fragment.js";
import "../../Shaders/shadowMap.vertex.js";
import "../../Shaders/depthBoxBlur.fragment.js";
import "../../Shaders/ShadersInclude/shadowMapFragmentSoftTransparentShadow.js";
/**
 * Default implementation IShadowGenerator.
 * This is the main object responsible of generating shadows in the framework.
 * Documentation: https://doc.babylonjs.com/babylon101/shadows
 */
var ShadowGenerator = /** @class */ (function () {
    /**
     * Creates a ShadowGenerator object.
     * A ShadowGenerator is the required tool to use the shadows.
     * Each light casting shadows needs to use its own ShadowGenerator.
     * Documentation : https://doc.babylonjs.com/babylon101/shadows
     * @param mapSize The size of the texture what stores the shadows. Example : 1024.
     * @param light The light object generating the shadows.
     * @param usefullFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.
     */
    function ShadowGenerator(mapSize, light, usefullFloatFirst) {
        /**
         * Observable triggered before the shadow is rendered. Can be used to update internal effect state
         */
        this.onBeforeShadowMapRenderObservable = new Observable();
        /**
         * Observable triggered after the shadow is rendered. Can be used to restore internal effect state
         */
        this.onAfterShadowMapRenderObservable = new Observable();
        /**
         * Observable triggered before a mesh is rendered in the shadow map.
         * Can be used to update internal effect state (that you can get from the onBeforeShadowMapRenderObservable)
         */
        this.onBeforeShadowMapRenderMeshObservable = new Observable();
        /**
         * Observable triggered after a mesh is rendered in the shadow map.
         * Can be used to update internal effect state (that you can get from the onAfterShadowMapRenderObservable)
         */
        this.onAfterShadowMapRenderMeshObservable = new Observable();
        this._bias = 0.00005;
        this._normalBias = 0;
        this._blurBoxOffset = 1;
        this._blurScale = 2;
        this._blurKernel = 1;
        this._useKernelBlur = false;
        this._filter = ShadowGenerator.FILTER_NONE;
        this._filteringQuality = ShadowGenerator.QUALITY_HIGH;
        this._contactHardeningLightSizeUVRatio = 0.1;
        this._darkness = 0;
        this._transparencyShadow = false;
        /**
         * Enables or disables shadows with varying strength based on the transparency
         * When it is enabled, the strength of the shadow is taken equal to mesh.visibility
         * If you enabled an alpha texture on your material, the alpha value red from the texture is also combined to compute the strength:
         *          mesh.visibility * alphaTexture.a
         * The texture used is the diffuse by default, but it can be set to the opacity by setting useOpacityTextureForTransparentShadow
         * Note that by definition transparencyShadow must be set to true for enableSoftTransparentShadow to work!
         */
        this.enableSoftTransparentShadow = false;
        /**
         * If this is true, use the opacity texture's alpha channel for transparent shadows instead of the diffuse one
         */
        this.useOpacityTextureForTransparentShadow = false;
        /**
         * Controls the extent to which the shadows fade out at the edge of the frustum
         */
        this.frustumEdgeFalloff = 0;
        /**
         * If true the shadow map is generated by rendering the back face of the mesh instead of the front face.
         * This can help with self-shadowing as the geometry making up the back of objects is slightly offset.
         * It might on the other hand introduce peter panning.
         */
        this.forceBackFacesOnly = false;
        this._lightDirection = Vector3.Zero();
        this._viewMatrix = Matrix.Zero();
        this._projectionMatrix = Matrix.Zero();
        this._transformMatrix = Matrix.Zero();
        this._cachedPosition = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._cachedDirection = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._currentFaceIndex = 0;
        this._currentFaceIndexCache = 0;
        this._defaultTextureMatrix = Matrix.Identity();
        this._mapSize = mapSize;
        this._light = light;
        this._scene = light.getScene();
        light._shadowGenerator = this;
        this.id = light.id;
        this._useUBO = this._scene.getEngine().supportsUniformBuffers;
        if (this._useUBO) {
            this._sceneUBOs = [];
            this._sceneUBOs.push(this._scene.createSceneUniformBuffer("Scene for Shadow Generator (light \"".concat(this._light.name, "\")")));
        }
        ShadowGenerator._SceneComponentInitialization(this._scene);
        // Texture type fallback from float to int if not supported.
        var caps = this._scene.getEngine().getCaps();
        if (!usefullFloatFirst) {
            if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
                this._textureType = 2;
            }
            else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
                this._textureType = 1;
            }
            else {
                this._textureType = 0;
            }
        }
        else {
            if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
                this._textureType = 1;
            }
            else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
                this._textureType = 2;
            }
            else {
                this._textureType = 0;
            }
        }
        this._initializeGenerator();
        this._applyFilterValues();
    }
    Object.defineProperty(ShadowGenerator.prototype, "bias", {
        /**
         * Gets the bias: offset applied on the depth preventing acnea (in light direction).
         */
        get: function () {
            return this._bias;
        },
        /**
         * Sets the bias: offset applied on the depth preventing acnea (in light direction).
         */
        set: function (bias) {
            this._bias = bias;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "normalBias", {
        /**
         * Gets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportional to the light/normal angle).
         */
        get: function () {
            return this._normalBias;
        },
        /**
         * Sets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportional to the light/normal angle).
         */
        set: function (normalBias) {
            this._normalBias = normalBias;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "blurBoxOffset", {
        /**
         * Gets the blur box offset: offset applied during the blur pass.
         * Only useful if useKernelBlur = false
         */
        get: function () {
            return this._blurBoxOffset;
        },
        /**
         * Sets the blur box offset: offset applied during the blur pass.
         * Only useful if useKernelBlur = false
         */
        set: function (value) {
            if (this._blurBoxOffset === value) {
                return;
            }
            this._blurBoxOffset = value;
            this._disposeBlurPostProcesses();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "blurScale", {
        /**
         * Gets the blur scale: scale of the blurred texture compared to the main shadow map.
         * 2 means half of the size.
         */
        get: function () {
            return this._blurScale;
        },
        /**
         * Sets the blur scale: scale of the blurred texture compared to the main shadow map.
         * 2 means half of the size.
         */
        set: function (value) {
            if (this._blurScale === value) {
                return;
            }
            this._blurScale = value;
            this._disposeBlurPostProcesses();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "blurKernel", {
        /**
         * Gets the blur kernel: kernel size of the blur pass.
         * Only useful if useKernelBlur = true
         */
        get: function () {
            return this._blurKernel;
        },
        /**
         * Sets the blur kernel: kernel size of the blur pass.
         * Only useful if useKernelBlur = true
         */
        set: function (value) {
            if (this._blurKernel === value) {
                return;
            }
            this._blurKernel = value;
            this._disposeBlurPostProcesses();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "useKernelBlur", {
        /**
         * Gets whether the blur pass is a kernel blur (if true) or box blur.
         * Only useful in filtered mode (useBlurExponentialShadowMap...)
         */
        get: function () {
            return this._useKernelBlur;
        },
        /**
         * Sets whether the blur pass is a kernel blur (if true) or box blur.
         * Only useful in filtered mode (useBlurExponentialShadowMap...)
         */
        set: function (value) {
            if (this._useKernelBlur === value) {
                return;
            }
            this._useKernelBlur = value;
            this._disposeBlurPostProcesses();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "depthScale", {
        /**
         * Gets the depth scale used in ESM mode.
         */
        get: function () {
            return this._depthScale !== undefined ? this._depthScale : this._light.getDepthScale();
        },
        /**
         * Sets the depth scale used in ESM mode.
         * This can override the scale stored on the light.
         */
        set: function (value) {
            this._depthScale = value;
        },
        enumerable: false,
        configurable: true
    });
    ShadowGenerator.prototype._validateFilter = function (filter) {
        return filter;
    };
    Object.defineProperty(ShadowGenerator.prototype, "filter", {
        /**
         * Gets the current mode of the shadow generator (normal, PCF, ESM...).
         * The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE
         */
        get: function () {
            return this._filter;
        },
        /**
         * Sets the current mode of the shadow generator (normal, PCF, ESM...).
         * The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE
         */
        set: function (value) {
            value = this._validateFilter(value);
            // Blurring the cubemap is going to be too expensive. Reverting to unblurred version
            if (this._light.needCube()) {
                if (value === ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP) {
                    this.useExponentialShadowMap = true;
                    return;
                }
                else if (value === ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {
                    this.useCloseExponentialShadowMap = true;
                    return;
                }
                // PCF on cubemap would also be expensive
                else if (value === ShadowGenerator.FILTER_PCF || value === ShadowGenerator.FILTER_PCSS) {
                    this.usePoissonSampling = true;
                    return;
                }
            }
            // Weblg1 fallback for PCF.
            if (value === ShadowGenerator.FILTER_PCF || value === ShadowGenerator.FILTER_PCSS) {
                if (!this._scene.getEngine()._features.supportShadowSamplers) {
                    this.usePoissonSampling = true;
                    return;
                }
            }
            if (this._filter === value) {
                return;
            }
            this._filter = value;
            this._disposeBlurPostProcesses();
            this._applyFilterValues();
            this._light._markMeshesAsLightDirty();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "usePoissonSampling", {
        /**
         * Gets if the current filter is set to Poisson Sampling.
         */
        get: function () {
            return this.filter === ShadowGenerator.FILTER_POISSONSAMPLING;
        },
        /**
         * Sets the current filter to Poisson Sampling.
         */
        set: function (value) {
            var filter = this._validateFilter(ShadowGenerator.FILTER_POISSONSAMPLING);
            if (!value && this.filter !== ShadowGenerator.FILTER_POISSONSAMPLING) {
                return;
            }
            this.filter = value ? filter : ShadowGenerator.FILTER_NONE;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "useExponentialShadowMap", {
        /**
         * Gets if the current filter is set to ESM.
         */
        get: function () {
            return this.filter === ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP;
        },
        /**
         * Sets the current filter is to ESM.
         */
        set: function (value) {
            var filter = this._validateFilter(ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP);
            if (!value && this.filter !== ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP) {
                return;
            }
            this.filter = value ? filter : ShadowGenerator.FILTER_NONE;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "useBlurExponentialShadowMap", {
        /**
         * Gets if the current filter is set to filtered ESM.
         */
        get: function () {
            return this.filter === ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP;
        },
        /**
         * Gets if the current filter is set to filtered  ESM.
         */
        set: function (value) {
            var filter = this._validateFilter(ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP);
            if (!value && this.filter !== ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP) {
                return;
            }
            this.filter = value ? filter : ShadowGenerator.FILTER_NONE;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "useCloseExponentialShadowMap", {
        /**
         * Gets if the current filter is set to "close ESM" (using the inverse of the
         * exponential to prevent steep falloff artifacts).
         */
        get: function () {
            return this.filter === ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP;
        },
        /**
         * Sets the current filter to "close ESM" (using the inverse of the
         * exponential to prevent steep falloff artifacts).
         */
        set: function (value) {
            var filter = this._validateFilter(ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP);
            if (!value && this.filter !== ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP) {
                return;
            }
            this.filter = value ? filter : ShadowGenerator.FILTER_NONE;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "useBlurCloseExponentialShadowMap", {
        /**
         * Gets if the current filter is set to filtered "close ESM" (using the inverse of the
         * exponential to prevent steep falloff artifacts).
         */
        get: function () {
            return this.filter === ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP;
        },
        /**
         * Sets the current filter to filtered "close ESM" (using the inverse of the
         * exponential to prevent steep falloff artifacts).
         */
        set: function (value) {
            var filter = this._validateFilter(ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP);
            if (!value && this.filter !== ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {
                return;
            }
            this.filter = value ? filter : ShadowGenerator.FILTER_NONE;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "usePercentageCloserFiltering", {
        /**
         * Gets if the current filter is set to "PCF" (percentage closer filtering).
         */
        get: function () {
            return this.filter === ShadowGenerator.FILTER_PCF;
        },
        /**
         * Sets the current filter to "PCF" (percentage closer filtering).
         */
        set: function (value) {
            var filter = this._validateFilter(ShadowGenerator.FILTER_PCF);
            if (!value && this.filter !== ShadowGenerator.FILTER_PCF) {
                return;
            }
            this.filter = value ? filter : ShadowGenerator.FILTER_NONE;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "filteringQuality", {
        /**
         * Gets the PCF or PCSS Quality.
         * Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.
         */
        get: function () {
            return this._filteringQuality;
        },
        /**
         * Sets the PCF or PCSS Quality.
         * Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.
         */
        set: function (filteringQuality) {
            if (this._filteringQuality === filteringQuality) {
                return;
            }
            this._filteringQuality = filteringQuality;
            this._disposeBlurPostProcesses();
            this._applyFilterValues();
            this._light._markMeshesAsLightDirty();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "useContactHardeningShadow", {
        /**
         * Gets if the current filter is set to "PCSS" (contact hardening).
         */
        get: function () {
            return this.filter === ShadowGenerator.FILTER_PCSS;
        },
        /**
         * Sets the current filter to "PCSS" (contact hardening).
         */
        set: function (value) {
            var filter = this._validateFilter(ShadowGenerator.FILTER_PCSS);
            if (!value && this.filter !== ShadowGenerator.FILTER_PCSS) {
                return;
            }
            this.filter = value ? filter : ShadowGenerator.FILTER_NONE;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "contactHardeningLightSizeUVRatio", {
        /**
         * Gets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.
         * Using a ratio helps keeping shape stability independently of the map size.
         *
         * It does not account for the light projection as it was having too much
         * instability during the light setup or during light position changes.
         *
         * Only valid if useContactHardeningShadow is true.
         */
        get: function () {
            return this._contactHardeningLightSizeUVRatio;
        },
        /**
         * Sets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.
         * Using a ratio helps keeping shape stability independently of the map size.
         *
         * It does not account for the light projection as it was having too much
         * instability during the light setup or during light position changes.
         *
         * Only valid if useContactHardeningShadow is true.
         */
        set: function (contactHardeningLightSizeUVRatio) {
            this._contactHardeningLightSizeUVRatio = contactHardeningLightSizeUVRatio;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "darkness", {
        /** Gets or sets the actual darkness of a shadow */
        get: function () {
            return this._darkness;
        },
        set: function (value) {
            this.setDarkness(value);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns the darkness value (float). This can only decrease the actual darkness of a shadow.
     * 0 means strongest and 1 would means no shadow.
     * @returns the darkness.
     */
    ShadowGenerator.prototype.getDarkness = function () {
        return this._darkness;
    };
    /**
     * Sets the darkness value (float). This can only decrease the actual darkness of a shadow.
     * @param darkness The darkness value 0 means strongest and 1 would means no shadow.
     * @returns the shadow generator allowing fluent coding.
     */
    ShadowGenerator.prototype.setDarkness = function (darkness) {
        if (darkness >= 1.0) {
            this._darkness = 1.0;
        }
        else if (darkness <= 0.0) {
            this._darkness = 0.0;
        }
        else {
            this._darkness = darkness;
        }
        return this;
    };
    Object.defineProperty(ShadowGenerator.prototype, "transparencyShadow", {
        /** Gets or sets the ability to have transparent shadow  */
        get: function () {
            return this._transparencyShadow;
        },
        set: function (value) {
            this.setTransparencyShadow(value);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Sets the ability to have transparent shadow (boolean).
     * @param transparent True if transparent else False
     * @returns the shadow generator allowing fluent coding
     */
    ShadowGenerator.prototype.setTransparencyShadow = function (transparent) {
        this._transparencyShadow = transparent;
        return this;
    };
    /**
     * Gets the main RTT containing the shadow map (usually storing depth from the light point of view).
     * @returns The render target texture if present otherwise, null
     */
    ShadowGenerator.prototype.getShadowMap = function () {
        return this._shadowMap;
    };
    /**
     * Gets the RTT used during rendering (can be a blurred version of the shadow map or the shadow map itself).
     * @returns The render target texture if the shadow map is present otherwise, null
     */
    ShadowGenerator.prototype.getShadowMapForRendering = function () {
        if (this._shadowMap2) {
            return this._shadowMap2;
        }
        return this._shadowMap;
    };
    /**
     * Gets the class name of that object
     * @returns "ShadowGenerator"
     */
    ShadowGenerator.prototype.getClassName = function () {
        return ShadowGenerator.CLASSNAME;
    };
    /**
     * Helper function to add a mesh and its descendants to the list of shadow casters.
     * @param mesh Mesh to add
     * @param includeDescendants boolean indicating if the descendants should be added. Default to true
     * @returns the Shadow Generator itself
     */
    ShadowGenerator.prototype.addShadowCaster = function (mesh, includeDescendants) {
        if (includeDescendants === void 0) { includeDescendants = true; }
        if (!this._shadowMap) {
            return this;
        }
        if (!this._shadowMap.renderList) {
            this._shadowMap.renderList = [];
        }
        if (this._shadowMap.renderList.indexOf(mesh) === -1) {
            this._shadowMap.renderList.push(mesh);
        }
        if (includeDescendants) {
            for (var _i = 0, _a = mesh.getChildMeshes(); _i < _a.length; _i++) {
                var childMesh = _a[_i];
                if (this._shadowMap.renderList.indexOf(childMesh) === -1) {
                    this._shadowMap.renderList.push(childMesh);
                }
            }
        }
        return this;
    };
    /**
     * Helper function to remove a mesh and its descendants from the list of shadow casters
     * @param mesh Mesh to remove
     * @param includeDescendants boolean indicating if the descendants should be removed. Default to true
     * @returns the Shadow Generator itself
     */
    ShadowGenerator.prototype.removeShadowCaster = function (mesh, includeDescendants) {
        if (includeDescendants === void 0) { includeDescendants = true; }
        if (!this._shadowMap || !this._shadowMap.renderList) {
            return this;
        }
        var index = this._shadowMap.renderList.indexOf(mesh);
        if (index !== -1) {
            this._shadowMap.renderList.splice(index, 1);
        }
        if (includeDescendants) {
            for (var _i = 0, _a = mesh.getChildren(); _i < _a.length; _i++) {
                var child = _a[_i];
                this.removeShadowCaster(child);
            }
        }
        return this;
    };
    /**
     * Returns the associated light object.
     * @returns the light generating the shadow
     */
    ShadowGenerator.prototype.getLight = function () {
        return this._light;
    };
    Object.defineProperty(ShadowGenerator.prototype, "mapSize", {
        /**
         * Gets or sets the size of the texture what stores the shadows
         */
        get: function () {
            return this._mapSize;
        },
        set: function (size) {
            this._mapSize = size;
            this._light._markMeshesAsLightDirty();
            this.recreateShadowMap();
        },
        enumerable: false,
        configurable: true
    });
    ShadowGenerator.prototype._initializeGenerator = function () {
        this._light._markMeshesAsLightDirty();
        this._initializeShadowMap();
    };
    ShadowGenerator.prototype._createTargetRenderTexture = function () {
        var engine = this._scene.getEngine();
        if (engine._features.supportDepthStencilTexture) {
            this._shadowMap = new RenderTargetTexture(this._light.name + "_shadowMap", this._mapSize, this._scene, false, true, this._textureType, this._light.needCube(), undefined, false, false);
            this._shadowMap.createDepthStencilTexture(engine.useReverseDepthBuffer ? 516 : 513, true);
        }
        else {
            this._shadowMap = new RenderTargetTexture(this._light.name + "_shadowMap", this._mapSize, this._scene, false, true, this._textureType, this._light.needCube());
        }
    };
    ShadowGenerator.prototype._initializeShadowMap = function () {
        var _this = this;
        this._createTargetRenderTexture();
        if (this._shadowMap === null) {
            return;
        }
        this._shadowMap.wrapU = Texture.CLAMP_ADDRESSMODE;
        this._shadowMap.wrapV = Texture.CLAMP_ADDRESSMODE;
        this._shadowMap.anisotropicFilteringLevel = 1;
        this._shadowMap.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
        this._shadowMap.renderParticles = false;
        this._shadowMap.ignoreCameraViewport = true;
        if (this._storedUniqueId) {
            this._shadowMap.uniqueId = this._storedUniqueId;
        }
        // Custom render function.
        this._shadowMap.customRenderFunction = this._renderForShadowMap.bind(this);
        // Force the mesh is ready function to true as we are double checking it
        // in the custom render function. Also it prevents side effects and useless
        // shader variations in DEPTHPREPASS mode.
        this._shadowMap.customIsReadyFunction = function () {
            return true;
        };
        var engine = this._scene.getEngine();
        this._shadowMap.onBeforeBindObservable.add(function () {
            var _a;
            _this._currentSceneUBO = _this._scene.getSceneUniformBuffer();
            (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, "shadow map generation for pass id ".concat(engine.currentRenderPassId), 1);
        });
        // Record Face Index before render.
        this._shadowMap.onBeforeRenderObservable.add(function (faceIndex) {
            if (_this._sceneUBOs) {
                _this._scene.setSceneUniformBuffer(_this._sceneUBOs[0]);
            }
            _this._currentFaceIndex = faceIndex;
            if (_this._filter === ShadowGenerator.FILTER_PCF) {
                engine.setColorWrite(false);
            }
            _this.getTransformMatrix(); // generate the view/projection matrix
            _this._scene.setTransformMatrix(_this._viewMatrix, _this._projectionMatrix);
            if (_this._useUBO) {
                _this._scene.getSceneUniformBuffer().unbindEffect();
                _this._scene.finalizeSceneUbo();
            }
        });
        // Blur if required after render.
        this._shadowMap.onAfterUnbindObservable.add(function () {
            var _a, _b;
            if (_this._sceneUBOs) {
                _this._scene.setSceneUniformBuffer(_this._currentSceneUBO);
            }
            _this._scene.updateTransformMatrix(); // restore the view/projection matrices of the active camera
            if (_this._filter === ShadowGenerator.FILTER_PCF) {
                engine.setColorWrite(true);
            }
            if (!_this.useBlurExponentialShadowMap && !_this.useBlurCloseExponentialShadowMap) {
                (_a = engine._debugPopGroup) === null || _a === void 0 ? void 0 : _a.call(engine, 1);
                return;
            }
            var shadowMap = _this.getShadowMapForRendering();
            if (shadowMap) {
                _this._scene.postProcessManager.directRender(_this._blurPostProcesses, shadowMap.renderTarget, true);
                engine.unBindFramebuffer(shadowMap.renderTarget, true);
                (_b = engine._debugPopGroup) === null || _b === void 0 ? void 0 : _b.call(engine, 1);
            }
        });
        // Clear according to the chosen filter.
        var clearZero = new Color4(0, 0, 0, 0);
        var clearOne = new Color4(1.0, 1.0, 1.0, 1.0);
        this._shadowMap.onClearObservable.add(function (engine) {
            if (_this._filter === ShadowGenerator.FILTER_PCF) {
                engine.clear(clearOne, false, true, false);
            }
            else if (_this.useExponentialShadowMap || _this.useBlurExponentialShadowMap) {
                engine.clear(clearZero, true, true, false);
            }
            else {
                engine.clear(clearOne, true, true, false);
            }
        });
        // Recreate on resize.
        this._shadowMap.onResizeObservable.add(function (rtt) {
            _this._storedUniqueId = _this._shadowMap.uniqueId;
            _this._mapSize = rtt.getRenderSize();
            _this._light._markMeshesAsLightDirty();
            _this.recreateShadowMap();
        });
        // Ensures rendering groupids do not erase the depth buffer
        // or we would lose the shadows information.
        for (var i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {
            this._shadowMap.setRenderingAutoClearDepthStencil(i, false);
        }
    };
    ShadowGenerator.prototype._initializeBlurRTTAndPostProcesses = function () {
        var _this = this;
        var engine = this._scene.getEngine();
        var targetSize = this._mapSize / this.blurScale;
        if (!this.useKernelBlur || this.blurScale !== 1.0) {
            this._shadowMap2 = new RenderTargetTexture(this._light.name + "_shadowMap2", targetSize, this._scene, false, true, this._textureType, undefined, undefined, false);
            this._shadowMap2.wrapU = Texture.CLAMP_ADDRESSMODE;
            this._shadowMap2.wrapV = Texture.CLAMP_ADDRESSMODE;
            this._shadowMap2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
        }
        if (this.useKernelBlur) {
            this._kernelBlurXPostprocess = new BlurPostProcess(this._light.name + "KernelBlurX", new Vector2(1, 0), this.blurKernel, 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._textureType);
            this._kernelBlurXPostprocess.width = targetSize;
            this._kernelBlurXPostprocess.height = targetSize;
            this._kernelBlurXPostprocess.externalTextureSamplerBinding = true;
            this._kernelBlurXPostprocess.onApplyObservable.add(function (effect) {
                effect.setTexture("textureSampler", _this._shadowMap);
            });
            this._kernelBlurYPostprocess = new BlurPostProcess(this._light.name + "KernelBlurY", new Vector2(0, 1), this.blurKernel, 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._textureType);
            this._kernelBlurXPostprocess.autoClear = false;
            this._kernelBlurYPostprocess.autoClear = false;
            if (this._textureType === 0) {
                this._kernelBlurXPostprocess.packedFloat = true;
                this._kernelBlurYPostprocess.packedFloat = true;
            }
            this._blurPostProcesses = [this._kernelBlurXPostprocess, this._kernelBlurYPostprocess];
        }
        else {
            this._boxBlurPostprocess = new PostProcess(this._light.name + "DepthBoxBlur", "depthBoxBlur", ["screenSize", "boxOffset"], [], 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, "#define OFFSET " + this._blurBoxOffset, this._textureType);
            this._boxBlurPostprocess.externalTextureSamplerBinding = true;
            this._boxBlurPostprocess.onApplyObservable.add(function (effect) {
                effect.setFloat2("screenSize", targetSize, targetSize);
                effect.setTexture("textureSampler", _this._shadowMap);
            });
            this._boxBlurPostprocess.autoClear = false;
            this._blurPostProcesses = [this._boxBlurPostprocess];
        }
    };
    ShadowGenerator.prototype._renderForShadowMap = function (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {
        var index;
        if (depthOnlySubMeshes.length) {
            for (index = 0; index < depthOnlySubMeshes.length; index++) {
                this._renderSubMeshForShadowMap(depthOnlySubMeshes.data[index]);
            }
        }
        for (index = 0; index < opaqueSubMeshes.length; index++) {
            this._renderSubMeshForShadowMap(opaqueSubMeshes.data[index]);
        }
        for (index = 0; index < alphaTestSubMeshes.length; index++) {
            this._renderSubMeshForShadowMap(alphaTestSubMeshes.data[index]);
        }
        if (this._transparencyShadow) {
            for (index = 0; index < transparentSubMeshes.length; index++) {
                this._renderSubMeshForShadowMap(transparentSubMeshes.data[index], true);
            }
        }
        else {
            for (index = 0; index < transparentSubMeshes.length; index++) {
                transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;
            }
        }
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ShadowGenerator.prototype._bindCustomEffectForRenderSubMeshForShadowMap = function (subMesh, effect, mesh) {
        effect.setMatrix("viewProjection", this.getTransformMatrix());
    };
    ShadowGenerator.prototype._renderSubMeshForShadowMap = function (subMesh, isTransparent) {
        var _a, _b;
        if (isTransparent === void 0) { isTransparent = false; }
        var renderingMesh = subMesh.getRenderingMesh();
        var effectiveMesh = subMesh.getEffectiveMesh();
        var scene = this._scene;
        var engine = scene.getEngine();
        var material = subMesh.getMaterial();
        effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;
        if (!material || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {
            return;
        }
        // Culling
        var detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;
        var sideOrientation = (_a = renderingMesh.overrideMaterialSideOrientation) !== null && _a !== void 0 ? _a : material.sideOrientation;
        if (detNeg) {
            sideOrientation =
                sideOrientation === 0 ? 1 : 0;
        }
        var reverseSideOrientation = sideOrientation === 0;
        engine.setState(material.backFaceCulling, undefined, undefined, reverseSideOrientation, material.cullBackFaces);
        // Managing instances
        var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
        if (batch.mustReturn) {
            return;
        }
        var hardwareInstancedRendering = engine.getCaps().instancedArrays &&
            ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || renderingMesh.hasThinInstances);
        if (this.customAllowRendering && !this.customAllowRendering(subMesh)) {
            return;
        }
        if (this.isReady(subMesh, hardwareInstancedRendering, isTransparent)) {
            subMesh._renderId = scene.getRenderId();
            var shadowDepthWrapper = material.shadowDepthWrapper;
            var drawWrapper = (_b = shadowDepthWrapper === null || shadowDepthWrapper === void 0 ? void 0 : shadowDepthWrapper.getEffect(subMesh, this, engine.currentRenderPassId)) !== null && _b !== void 0 ? _b : subMesh._getDrawWrapper();
            var effect_1 = DrawWrapper.GetEffect(drawWrapper);
            engine.enableEffect(drawWrapper);
            if (!hardwareInstancedRendering) {
                renderingMesh._bind(subMesh, effect_1, material.fillMode);
            }
            this.getTransformMatrix(); // make sure _cachedDirection et _cachedPosition are up to date
            effect_1.setFloat3("biasAndScaleSM", this.bias, this.normalBias, this.depthScale);
            if (this.getLight().getTypeID() === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {
                effect_1.setVector3("lightDataSM", this._cachedDirection);
            }
            else {
                effect_1.setVector3("lightDataSM", this._cachedPosition);
            }
            if (scene.activeCamera) {
                effect_1.setFloat2("depthValuesSM", this.getLight().getDepthMinZ(scene.activeCamera), this.getLight().getDepthMinZ(scene.activeCamera) + this.getLight().getDepthMaxZ(scene.activeCamera));
            }
            if (isTransparent && this.enableSoftTransparentShadow) {
                effect_1.setFloat("softTransparentShadowSM", effectiveMesh.visibility * material.alpha);
            }
            if (shadowDepthWrapper) {
                subMesh._setMainDrawWrapperOverride(drawWrapper);
                if (shadowDepthWrapper.standalone) {
                    shadowDepthWrapper.baseMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), renderingMesh, subMesh);
                }
                else {
                    material.bindForSubMesh(effectiveMesh.getWorldMatrix(), renderingMesh, subMesh);
                }
                subMesh._setMainDrawWrapperOverride(null);
            }
            else {
                // Alpha test
                if (material && this.useOpacityTextureForTransparentShadow) {
                    var opacityTexture = material.opacityTexture;
                    if (opacityTexture) {
                        effect_1.setTexture("diffuseSampler", opacityTexture);
                        effect_1.setMatrix("diffuseMatrix", opacityTexture.getTextureMatrix() || this._defaultTextureMatrix);
                    }
                }
                else if (material && material.needAlphaTesting()) {
                    var alphaTexture = material.getAlphaTestTexture();
                    if (alphaTexture) {
                        effect_1.setTexture("diffuseSampler", alphaTexture);
                        effect_1.setMatrix("diffuseMatrix", alphaTexture.getTextureMatrix() || this._defaultTextureMatrix);
                    }
                }
                // Bones
                if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {
                    var skeleton = renderingMesh.skeleton;
                    if (skeleton.isUsingTextureForMatrices) {
                        var boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);
                        if (!boneTexture) {
                            return;
                        }
                        effect_1.setTexture("boneSampler", boneTexture);
                        effect_1.setFloat("boneTextureWidth", 4.0 * (skeleton.bones.length + 1));
                    }
                    else {
                        effect_1.setMatrices("mBones", skeleton.getTransformMatrices(renderingMesh));
                    }
                }
                // Morph targets
                MaterialHelper.BindMorphTargetParameters(renderingMesh, effect_1);
                if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {
                    renderingMesh.morphTargetManager._bind(effect_1);
                }
                // Clip planes
                MaterialHelper.BindClipPlane(effect_1, scene);
            }
            if (!this._useUBO && !shadowDepthWrapper) {
                this._bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect_1, effectiveMesh);
            }
            MaterialHelper.BindSceneUniformBuffer(effect_1, this._scene.getSceneUniformBuffer());
            this._scene.getSceneUniformBuffer().bindUniformBuffer();
            var world_1 = effectiveMesh.getWorldMatrix();
            // In the non hardware instanced mode, the Mesh ubo update is done by the callback passed to renderingMesh._processRendering (see below)
            if (hardwareInstancedRendering) {
                effectiveMesh.getMeshUniformBuffer().bindToEffect(effect_1, "Mesh");
                effectiveMesh.transferToEffect(world_1);
            }
            if (this.forceBackFacesOnly) {
                engine.setState(true, 0, false, true, material.cullBackFaces);
            }
            // Observables
            this.onBeforeShadowMapRenderMeshObservable.notifyObservers(renderingMesh);
            this.onBeforeShadowMapRenderObservable.notifyObservers(effect_1);
            // Draw
            renderingMesh._processRendering(effectiveMesh, subMesh, effect_1, material.fillMode, batch, hardwareInstancedRendering, function (isInstance, worldOverride) {
                if (effectiveMesh !== renderingMesh && !isInstance) {
                    renderingMesh.getMeshUniformBuffer().bindToEffect(effect_1, "Mesh");
                    renderingMesh.transferToEffect(worldOverride);
                }
                else {
                    effectiveMesh.getMeshUniformBuffer().bindToEffect(effect_1, "Mesh");
                    effectiveMesh.transferToEffect(isInstance ? worldOverride : world_1);
                }
            });
            if (this.forceBackFacesOnly) {
                engine.setState(true, 0, false, false, material.cullBackFaces);
            }
            // Observables
            this.onAfterShadowMapRenderObservable.notifyObservers(effect_1);
            this.onAfterShadowMapRenderMeshObservable.notifyObservers(renderingMesh);
        }
        else {
            // Need to reset refresh rate of the shadowMap
            if (this._shadowMap) {
                this._shadowMap.resetRefreshCounter();
            }
        }
    };
    ShadowGenerator.prototype._applyFilterValues = function () {
        if (!this._shadowMap) {
            return;
        }
        if (this.filter === ShadowGenerator.FILTER_NONE || this.filter === ShadowGenerator.FILTER_PCSS) {
            this._shadowMap.updateSamplingMode(Texture.NEAREST_SAMPLINGMODE);
        }
        else {
            this._shadowMap.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
        }
    };
    /**
     * Forces all the attached effect to compile to enable rendering only once ready vs. lazily compiling effects.
     * @param onCompiled Callback triggered at the and of the effects compilation
     * @param options Sets of optional options forcing the compilation with different modes
     */
    ShadowGenerator.prototype.forceCompilation = function (onCompiled, options) {
        var _this = this;
        var localOptions = __assign({ useInstances: false }, options);
        var shadowMap = this.getShadowMap();
        if (!shadowMap) {
            if (onCompiled) {
                onCompiled(this);
            }
            return;
        }
        var renderList = shadowMap.renderList;
        if (!renderList) {
            if (onCompiled) {
                onCompiled(this);
            }
            return;
        }
        var subMeshes = new Array();
        for (var _i = 0, renderList_1 = renderList; _i < renderList_1.length; _i++) {
            var mesh = renderList_1[_i];
            subMeshes.push.apply(subMeshes, mesh.subMeshes);
        }
        if (subMeshes.length === 0) {
            if (onCompiled) {
                onCompiled(this);
            }
            return;
        }
        var currentIndex = 0;
        var checkReady = function () {
            var _a, _b;
            if (!_this._scene || !_this._scene.getEngine()) {
                return;
            }
            while (_this.isReady(subMeshes[currentIndex], localOptions.useInstances, (_b = (_a = subMeshes[currentIndex].getMaterial()) === null || _a === void 0 ? void 0 : _a.needAlphaBlendingForMesh(subMeshes[currentIndex].getMesh())) !== null && _b !== void 0 ? _b : false)) {
                currentIndex++;
                if (currentIndex >= subMeshes.length) {
                    if (onCompiled) {
                        onCompiled(_this);
                    }
                    return;
                }
            }
            setTimeout(checkReady, 16);
        };
        checkReady();
    };
    /**
     * Forces all the attached effect to compile to enable rendering only once ready vs. lazily compiling effects.
     * @param options Sets of optional options forcing the compilation with different modes
     * @returns A promise that resolves when the compilation completes
     */
    ShadowGenerator.prototype.forceCompilationAsync = function (options) {
        var _this = this;
        return new Promise(function (resolve) {
            _this.forceCompilation(function () {
                resolve();
            }, options);
        });
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ShadowGenerator.prototype._isReadyCustomDefines = function (defines, subMesh, useInstances) { };
    ShadowGenerator.prototype._prepareShadowDefines = function (subMesh, useInstances, defines, isTransparent) {
        defines.push("#define SM_FLOAT " + (this._textureType !== 0 ? "1" : "0"));
        defines.push("#define SM_ESM " + (this.useExponentialShadowMap || this.useBlurExponentialShadowMap ? "1" : "0"));
        defines.push("#define SM_DEPTHTEXTURE " + (this.usePercentageCloserFiltering || this.useContactHardeningShadow ? "1" : "0"));
        var mesh = subMesh.getMesh();
        // Normal bias.
        defines.push("#define SM_NORMALBIAS " + (this.normalBias && mesh.isVerticesDataPresent(VertexBuffer.NormalKind) ? "1" : "0"));
        defines.push("#define SM_DIRECTIONINLIGHTDATA " + (this.getLight().getTypeID() === Light.LIGHTTYPEID_DIRECTIONALLIGHT ? "1" : "0"));
        // Point light
        defines.push("#define SM_USEDISTANCE " + (this._light.needCube() ? "1" : "0"));
        // Soft transparent shadows
        defines.push("#define SM_SOFTTRANSPARENTSHADOW " + (this.enableSoftTransparentShadow && isTransparent ? "1" : "0"));
        this._isReadyCustomDefines(defines, subMesh, useInstances);
        return defines;
    };
    /**
     * Determine whether the shadow generator is ready or not (mainly all effects and related post processes needs to be ready).
     * @param subMesh The submesh we want to render in the shadow map
     * @param useInstances Defines whether will draw in the map using instances
     * @param isTransparent Indicates that isReady is called for a transparent subMesh
     * @returns true if ready otherwise, false
     */
    ShadowGenerator.prototype.isReady = function (subMesh, useInstances, isTransparent) {
        var _a;
        var material = subMesh.getMaterial(), shadowDepthWrapper = material === null || material === void 0 ? void 0 : material.shadowDepthWrapper;
        var defines = [];
        this._prepareShadowDefines(subMesh, useInstances, defines, isTransparent);
        if (shadowDepthWrapper) {
            if (!shadowDepthWrapper.isReadyForSubMesh(subMesh, defines, this, useInstances, this._scene.getEngine().currentRenderPassId)) {
                return false;
            }
        }
        else {
            var subMeshEffect = subMesh._getDrawWrapper(undefined, true);
            var effect = subMeshEffect.effect;
            var cachedDefines = subMeshEffect.defines;
            var attribs = [VertexBuffer.PositionKind];
            var mesh = subMesh.getMesh();
            // Normal bias.
            if (this.normalBias && mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
                attribs.push(VertexBuffer.NormalKind);
                defines.push("#define NORMAL");
                if (mesh.nonUniformScaling) {
                    defines.push("#define NONUNIFORMSCALING");
                }
            }
            // Alpha test
            if (material && material.needAlphaTesting()) {
                var alphaTexture = null;
                if (this.useOpacityTextureForTransparentShadow) {
                    alphaTexture = material.opacityTexture;
                }
                else {
                    alphaTexture = material.getAlphaTestTexture();
                }
                if (alphaTexture) {
                    if (!alphaTexture.isReady()) {
                        return false;
                    }
                    var alphaCutOff = (_a = material.alphaCutOff) !== null && _a !== void 0 ? _a : ShadowGenerator.DEFAULT_ALPHA_CUTOFF;
                    defines.push("#define ALPHATEST");
                    defines.push("#define ALPHATESTVALUE ".concat(alphaCutOff).concat(alphaCutOff % 1 === 0 ? "." : ""));
                    if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
                        attribs.push(VertexBuffer.UVKind);
                        defines.push("#define UV1");
                    }
                    if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
                        if (alphaTexture.coordinatesIndex === 1) {
                            attribs.push(VertexBuffer.UV2Kind);
                            defines.push("#define UV2");
                        }
                    }
                }
            }
            // Bones
            var fallbacks = new EffectFallbacks();
            if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
                attribs.push(VertexBuffer.MatricesIndicesKind);
                attribs.push(VertexBuffer.MatricesWeightsKind);
                if (mesh.numBoneInfluencers > 4) {
                    attribs.push(VertexBuffer.MatricesIndicesExtraKind);
                    attribs.push(VertexBuffer.MatricesWeightsExtraKind);
                }
                var skeleton = mesh.skeleton;
                defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
                if (mesh.numBoneInfluencers > 0) {
                    fallbacks.addCPUSkinningFallback(0, mesh);
                }
                if (skeleton.isUsingTextureForMatrices) {
                    defines.push("#define BONETEXTURE");
                }
                else {
                    defines.push("#define BonesPerMesh " + (skeleton.bones.length + 1));
                }
            }
            else {
                defines.push("#define NUM_BONE_INFLUENCERS 0");
            }
            // Morph targets
            var manager = mesh.morphTargetManager;
            var morphInfluencers = 0;
            if (manager) {
                if (manager.numInfluencers > 0) {
                    defines.push("#define MORPHTARGETS");
                    morphInfluencers = manager.numInfluencers;
                    defines.push("#define NUM_MORPH_INFLUENCERS " + morphInfluencers);
                    if (manager.isUsingTextureForTargets) {
                        defines.push("#define MORPHTARGETS_TEXTURE");
                    }
                    MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, morphInfluencers);
                }
            }
            // ClipPlanes
            var scene = this._scene;
            if (scene.clipPlane) {
                defines.push("#define CLIPPLANE");
            }
            if (scene.clipPlane2) {
                defines.push("#define CLIPPLANE2");
            }
            if (scene.clipPlane3) {
                defines.push("#define CLIPPLANE3");
            }
            if (scene.clipPlane4) {
                defines.push("#define CLIPPLANE4");
            }
            if (scene.clipPlane5) {
                defines.push("#define CLIPPLANE5");
            }
            if (scene.clipPlane6) {
                defines.push("#define CLIPPLANE6");
            }
            // Instances
            if (useInstances) {
                defines.push("#define INSTANCES");
                MaterialHelper.PushAttributesForInstances(attribs);
                if (subMesh.getRenderingMesh().hasThinInstances) {
                    defines.push("#define THIN_INSTANCES");
                }
            }
            if (this.customShaderOptions) {
                if (this.customShaderOptions.defines) {
                    for (var _i = 0, _b = this.customShaderOptions.defines; _i < _b.length; _i++) {
                        var define = _b[_i];
                        if (defines.indexOf(define) === -1) {
                            defines.push(define);
                        }
                    }
                }
            }
            // Get correct effect
            var join = defines.join("\n");
            if (cachedDefines !== join) {
                cachedDefines = join;
                var shaderName = "shadowMap";
                var uniforms = [
                    "world",
                    "mBones",
                    "viewProjection",
                    "diffuseMatrix",
                    "lightDataSM",
                    "depthValuesSM",
                    "biasAndScaleSM",
                    "morphTargetInfluences",
                    "boneTextureWidth",
                    "vClipPlane",
                    "vClipPlane2",
                    "vClipPlane3",
                    "vClipPlane4",
                    "vClipPlane5",
                    "vClipPlane6",
                    "softTransparentShadowSM",
                    "morphTargetTextureInfo",
                    "morphTargetTextureIndices",
                ];
                var samplers = ["diffuseSampler", "boneSampler", "morphTargets"];
                var uniformBuffers = ["Scene", "Mesh"];
                // Custom shader?
                if (this.customShaderOptions) {
                    shaderName = this.customShaderOptions.shaderName;
                    if (this.customShaderOptions.attributes) {
                        for (var _c = 0, _d = this.customShaderOptions.attributes; _c < _d.length; _c++) {
                            var attrib = _d[_c];
                            if (attribs.indexOf(attrib) === -1) {
                                attribs.push(attrib);
                            }
                        }
                    }
                    if (this.customShaderOptions.uniforms) {
                        for (var _e = 0, _f = this.customShaderOptions.uniforms; _e < _f.length; _e++) {
                            var uniform = _f[_e];
                            if (uniforms.indexOf(uniform) === -1) {
                                uniforms.push(uniform);
                            }
                        }
                    }
                    if (this.customShaderOptions.samplers) {
                        for (var _g = 0, _h = this.customShaderOptions.samplers; _g < _h.length; _g++) {
                            var sampler = _h[_g];
                            if (samplers.indexOf(sampler) === -1) {
                                samplers.push(sampler);
                            }
                        }
                    }
                }
                var engine = this._scene.getEngine();
                effect = engine.createEffect(shaderName, {
                    attributes: attribs,
                    uniformsNames: uniforms,
                    uniformBuffersNames: uniformBuffers,
                    samplers: samplers,
                    defines: join,
                    fallbacks: fallbacks,
                    onCompiled: null,
                    onError: null,
                    indexParameters: { maxSimultaneousMorphTargets: morphInfluencers },
                }, engine);
                subMeshEffect.setEffect(effect, cachedDefines);
            }
            if (!effect.isReady()) {
                return false;
            }
        }
        if (this.useBlurExponentialShadowMap || this.useBlurCloseExponentialShadowMap) {
            if (!this._blurPostProcesses || !this._blurPostProcesses.length) {
                this._initializeBlurRTTAndPostProcesses();
            }
        }
        if (this._kernelBlurXPostprocess && !this._kernelBlurXPostprocess.isReady()) {
            return false;
        }
        if (this._kernelBlurYPostprocess && !this._kernelBlurYPostprocess.isReady()) {
            return false;
        }
        if (this._boxBlurPostprocess && !this._boxBlurPostprocess.isReady()) {
            return false;
        }
        return true;
    };
    /**
     * Prepare all the defines in a material relying on a shadow map at the specified light index.
     * @param defines Defines of the material we want to update
     * @param lightIndex Index of the light in the enabled light list of the material
     */
    ShadowGenerator.prototype.prepareDefines = function (defines, lightIndex) {
        var scene = this._scene;
        var light = this._light;
        if (!scene.shadowsEnabled || !light.shadowEnabled) {
            return;
        }
        defines["SHADOW" + lightIndex] = true;
        if (this.useContactHardeningShadow) {
            defines["SHADOWPCSS" + lightIndex] = true;
            if (this._filteringQuality === ShadowGenerator.QUALITY_LOW) {
                defines["SHADOWLOWQUALITY" + lightIndex] = true;
            }
            else if (this._filteringQuality === ShadowGenerator.QUALITY_MEDIUM) {
                defines["SHADOWMEDIUMQUALITY" + lightIndex] = true;
            }
            // else default to high.
        }
        else if (this.usePercentageCloserFiltering) {
            defines["SHADOWPCF" + lightIndex] = true;
            if (this._filteringQuality === ShadowGenerator.QUALITY_LOW) {
                defines["SHADOWLOWQUALITY" + lightIndex] = true;
            }
            else if (this._filteringQuality === ShadowGenerator.QUALITY_MEDIUM) {
                defines["SHADOWMEDIUMQUALITY" + lightIndex] = true;
            }
            // else default to high.
        }
        else if (this.usePoissonSampling) {
            defines["SHADOWPOISSON" + lightIndex] = true;
        }
        else if (this.useExponentialShadowMap || this.useBlurExponentialShadowMap) {
            defines["SHADOWESM" + lightIndex] = true;
        }
        else if (this.useCloseExponentialShadowMap || this.useBlurCloseExponentialShadowMap) {
            defines["SHADOWCLOSEESM" + lightIndex] = true;
        }
        if (light.needCube()) {
            defines["SHADOWCUBE" + lightIndex] = true;
        }
    };
    /**
     * Binds the shadow related information inside of an effect (information like near, far, darkness...
     * defined in the generator but impacting the effect).
     * @param lightIndex Index of the light in the enabled light list of the material owning the effect
     * @param effect The effect we are binding the information for
     */
    ShadowGenerator.prototype.bindShadowLight = function (lightIndex, effect) {
        var light = this._light;
        var scene = this._scene;
        if (!scene.shadowsEnabled || !light.shadowEnabled) {
            return;
        }
        var camera = scene.activeCamera;
        if (!camera) {
            return;
        }
        var shadowMap = this.getShadowMap();
        if (!shadowMap) {
            return;
        }
        if (!light.needCube()) {
            effect.setMatrix("lightMatrix" + lightIndex, this.getTransformMatrix());
        }
        // Only PCF uses depth stencil texture.
        if (this._filter === ShadowGenerator.FILTER_PCF) {
            effect.setDepthStencilTexture("shadowSampler" + lightIndex, this.getShadowMapForRendering());
            light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), shadowMap.getSize().width, 1 / shadowMap.getSize().width, this.frustumEdgeFalloff, lightIndex);
        }
        else if (this._filter === ShadowGenerator.FILTER_PCSS) {
            effect.setDepthStencilTexture("shadowSampler" + lightIndex, this.getShadowMapForRendering());
            effect.setTexture("depthSampler" + lightIndex, this.getShadowMapForRendering());
            light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), 1 / shadowMap.getSize().width, this._contactHardeningLightSizeUVRatio * shadowMap.getSize().width, this.frustumEdgeFalloff, lightIndex);
        }
        else {
            effect.setTexture("shadowSampler" + lightIndex, this.getShadowMapForRendering());
            light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), this.blurScale / shadowMap.getSize().width, this.depthScale, this.frustumEdgeFalloff, lightIndex);
        }
        light._uniformBuffer.updateFloat2("depthValues", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera), lightIndex);
    };
    /**
     * Gets the transformation matrix used to project the meshes into the map from the light point of view.
     * (eq to shadow projection matrix * light transform matrix)
     * @returns The transform matrix used to create the shadow map
     */
    ShadowGenerator.prototype.getTransformMatrix = function () {
        var scene = this._scene;
        if (this._currentRenderId === scene.getRenderId() && this._currentFaceIndexCache === this._currentFaceIndex) {
            return this._transformMatrix;
        }
        this._currentRenderId = scene.getRenderId();
        this._currentFaceIndexCache = this._currentFaceIndex;
        var lightPosition = this._light.position;
        if (this._light.computeTransformedInformation()) {
            lightPosition = this._light.transformedPosition;
        }
        Vector3.NormalizeToRef(this._light.getShadowDirection(this._currentFaceIndex), this._lightDirection);
        if (Math.abs(Vector3.Dot(this._lightDirection, Vector3.Up())) === 1.0) {
            this._lightDirection.z = 0.0000000000001; // Required to avoid perfectly perpendicular light
        }
        if (this._light.needProjectionMatrixCompute() ||
            !this._cachedPosition ||
            !this._cachedDirection ||
            !lightPosition.equals(this._cachedPosition) ||
            !this._lightDirection.equals(this._cachedDirection)) {
            this._cachedPosition.copyFrom(lightPosition);
            this._cachedDirection.copyFrom(this._lightDirection);
            Matrix.LookAtLHToRef(lightPosition, lightPosition.add(this._lightDirection), Vector3.Up(), this._viewMatrix);
            var shadowMap = this.getShadowMap();
            if (shadowMap) {
                var renderList = shadowMap.renderList;
                if (renderList) {
                    this._light.setShadowProjectionMatrix(this._projectionMatrix, this._viewMatrix, renderList);
                }
            }
            this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
        }
        return this._transformMatrix;
    };
    /**
     * Recreates the shadow map dependencies like RTT and post processes. This can be used during the switch between
     * Cube and 2D textures for instance.
     */
    ShadowGenerator.prototype.recreateShadowMap = function () {
        var shadowMap = this._shadowMap;
        if (!shadowMap) {
            return;
        }
        // Track render list.
        var renderList = shadowMap.renderList;
        // Clean up existing data.
        this._disposeRTTandPostProcesses();
        // Reinitializes.
        this._initializeGenerator();
        // Reaffect the filter to ensure a correct fallback if necessary.
        this.filter = this._filter;
        // Reaffect the filter.
        this._applyFilterValues();
        // Reaffect Render List.
        if (renderList) {
            // Note: don't do this._shadowMap!.renderList = renderList;
            // The renderList hooked array is accessing the old RenderTargetTexture (see RenderTargetTexture._hookArray), which is disposed at this point (by the call to _disposeRTTandPostProcesses)
            if (!this._shadowMap.renderList) {
                this._shadowMap.renderList = [];
            }
            for (var _i = 0, renderList_2 = renderList; _i < renderList_2.length; _i++) {
                var mesh = renderList_2[_i];
                this._shadowMap.renderList.push(mesh);
            }
        }
        else {
            this._shadowMap.renderList = null;
        }
    };
    ShadowGenerator.prototype._disposeBlurPostProcesses = function () {
        if (this._shadowMap2) {
            this._shadowMap2.dispose();
            this._shadowMap2 = null;
        }
        if (this._boxBlurPostprocess) {
            this._boxBlurPostprocess.dispose();
            this._boxBlurPostprocess = null;
        }
        if (this._kernelBlurXPostprocess) {
            this._kernelBlurXPostprocess.dispose();
            this._kernelBlurXPostprocess = null;
        }
        if (this._kernelBlurYPostprocess) {
            this._kernelBlurYPostprocess.dispose();
            this._kernelBlurYPostprocess = null;
        }
        this._blurPostProcesses = [];
    };
    ShadowGenerator.prototype._disposeRTTandPostProcesses = function () {
        if (this._shadowMap) {
            this._shadowMap.dispose();
            this._shadowMap = null;
        }
        this._disposeBlurPostProcesses();
    };
    ShadowGenerator.prototype._disposeSceneUBOs = function () {
        if (this._sceneUBOs) {
            for (var _i = 0, _a = this._sceneUBOs; _i < _a.length; _i++) {
                var ubo = _a[_i];
                ubo.dispose();
            }
            this._sceneUBOs = [];
        }
    };
    /**
     * Disposes the ShadowGenerator.
     * Returns nothing.
     */
    ShadowGenerator.prototype.dispose = function () {
        this._disposeRTTandPostProcesses();
        this._disposeSceneUBOs();
        if (this._light) {
            this._light._shadowGenerator = null;
            this._light._markMeshesAsLightDirty();
        }
        this.onBeforeShadowMapRenderMeshObservable.clear();
        this.onBeforeShadowMapRenderObservable.clear();
        this.onAfterShadowMapRenderMeshObservable.clear();
        this.onAfterShadowMapRenderObservable.clear();
    };
    /**
     * Serializes the shadow generator setup to a json object.
     * @returns The serialized JSON object
     */
    ShadowGenerator.prototype.serialize = function () {
        var serializationObject = {};
        var shadowMap = this.getShadowMap();
        if (!shadowMap) {
            return serializationObject;
        }
        serializationObject.className = this.getClassName();
        serializationObject.lightId = this._light.id;
        serializationObject.id = this.id;
        serializationObject.mapSize = shadowMap.getRenderSize();
        serializationObject.forceBackFacesOnly = this.forceBackFacesOnly;
        serializationObject.darkness = this.getDarkness();
        serializationObject.transparencyShadow = this._transparencyShadow;
        serializationObject.frustumEdgeFalloff = this.frustumEdgeFalloff;
        serializationObject.bias = this.bias;
        serializationObject.normalBias = this.normalBias;
        serializationObject.usePercentageCloserFiltering = this.usePercentageCloserFiltering;
        serializationObject.useContactHardeningShadow = this.useContactHardeningShadow;
        serializationObject.contactHardeningLightSizeUVRatio = this.contactHardeningLightSizeUVRatio;
        serializationObject.filteringQuality = this.filteringQuality;
        serializationObject.useExponentialShadowMap = this.useExponentialShadowMap;
        serializationObject.useBlurExponentialShadowMap = this.useBlurExponentialShadowMap;
        serializationObject.useCloseExponentialShadowMap = this.useBlurExponentialShadowMap;
        serializationObject.useBlurCloseExponentialShadowMap = this.useBlurExponentialShadowMap;
        serializationObject.usePoissonSampling = this.usePoissonSampling;
        serializationObject.depthScale = this.depthScale;
        serializationObject.blurBoxOffset = this.blurBoxOffset;
        serializationObject.blurKernel = this.blurKernel;
        serializationObject.blurScale = this.blurScale;
        serializationObject.useKernelBlur = this.useKernelBlur;
        serializationObject.renderList = [];
        if (shadowMap.renderList) {
            for (var meshIndex = 0; meshIndex < shadowMap.renderList.length; meshIndex++) {
                var mesh = shadowMap.renderList[meshIndex];
                serializationObject.renderList.push(mesh.id);
            }
        }
        return serializationObject;
    };
    /**
     * Parses a serialized ShadowGenerator and returns a new ShadowGenerator.
     * @param parsedShadowGenerator The JSON object to parse
     * @param scene The scene to create the shadow map for
     * @param constr A function that builds a shadow generator or undefined to create an instance of the default shadow generator
     * @returns The parsed shadow generator
     */
    ShadowGenerator.Parse = function (parsedShadowGenerator, scene, constr) {
        var light = scene.getLightById(parsedShadowGenerator.lightId);
        var shadowGenerator = constr ? constr(parsedShadowGenerator.mapSize, light) : new ShadowGenerator(parsedShadowGenerator.mapSize, light);
        var shadowMap = shadowGenerator.getShadowMap();
        for (var meshIndex = 0; meshIndex < parsedShadowGenerator.renderList.length; meshIndex++) {
            var meshes = scene.getMeshesById(parsedShadowGenerator.renderList[meshIndex]);
            meshes.forEach(function (mesh) {
                if (!shadowMap) {
                    return;
                }
                if (!shadowMap.renderList) {
                    shadowMap.renderList = [];
                }
                shadowMap.renderList.push(mesh);
            });
        }
        if (parsedShadowGenerator.id !== undefined) {
            shadowGenerator.id = parsedShadowGenerator.id;
        }
        shadowGenerator.forceBackFacesOnly = !!parsedShadowGenerator.forceBackFacesOnly;
        if (parsedShadowGenerator.darkness !== undefined) {
            shadowGenerator.setDarkness(parsedShadowGenerator.darkness);
        }
        if (parsedShadowGenerator.transparencyShadow) {
            shadowGenerator.setTransparencyShadow(true);
        }
        if (parsedShadowGenerator.frustumEdgeFalloff !== undefined) {
            shadowGenerator.frustumEdgeFalloff = parsedShadowGenerator.frustumEdgeFalloff;
        }
        if (parsedShadowGenerator.bias !== undefined) {
            shadowGenerator.bias = parsedShadowGenerator.bias;
        }
        if (parsedShadowGenerator.normalBias !== undefined) {
            shadowGenerator.normalBias = parsedShadowGenerator.normalBias;
        }
        if (parsedShadowGenerator.usePercentageCloserFiltering) {
            shadowGenerator.usePercentageCloserFiltering = true;
        }
        else if (parsedShadowGenerator.useContactHardeningShadow) {
            shadowGenerator.useContactHardeningShadow = true;
        }
        else if (parsedShadowGenerator.usePoissonSampling) {
            shadowGenerator.usePoissonSampling = true;
        }
        else if (parsedShadowGenerator.useExponentialShadowMap) {
            shadowGenerator.useExponentialShadowMap = true;
        }
        else if (parsedShadowGenerator.useBlurExponentialShadowMap) {
            shadowGenerator.useBlurExponentialShadowMap = true;
        }
        else if (parsedShadowGenerator.useCloseExponentialShadowMap) {
            shadowGenerator.useCloseExponentialShadowMap = true;
        }
        else if (parsedShadowGenerator.useBlurCloseExponentialShadowMap) {
            shadowGenerator.useBlurCloseExponentialShadowMap = true;
        }
        // Backward compat
        else if (parsedShadowGenerator.useVarianceShadowMap) {
            shadowGenerator.useExponentialShadowMap = true;
        }
        else if (parsedShadowGenerator.useBlurVarianceShadowMap) {
            shadowGenerator.useBlurExponentialShadowMap = true;
        }
        if (parsedShadowGenerator.contactHardeningLightSizeUVRatio !== undefined) {
            shadowGenerator.contactHardeningLightSizeUVRatio = parsedShadowGenerator.contactHardeningLightSizeUVRatio;
        }
        if (parsedShadowGenerator.filteringQuality !== undefined) {
            shadowGenerator.filteringQuality = parsedShadowGenerator.filteringQuality;
        }
        if (parsedShadowGenerator.depthScale) {
            shadowGenerator.depthScale = parsedShadowGenerator.depthScale;
        }
        if (parsedShadowGenerator.blurScale) {
            shadowGenerator.blurScale = parsedShadowGenerator.blurScale;
        }
        if (parsedShadowGenerator.blurBoxOffset) {
            shadowGenerator.blurBoxOffset = parsedShadowGenerator.blurBoxOffset;
        }
        if (parsedShadowGenerator.useKernelBlur) {
            shadowGenerator.useKernelBlur = parsedShadowGenerator.useKernelBlur;
        }
        if (parsedShadowGenerator.blurKernel) {
            shadowGenerator.blurKernel = parsedShadowGenerator.blurKernel;
        }
        return shadowGenerator;
    };
    /**
     * Name of the shadow generator class
     */
    ShadowGenerator.CLASSNAME = "ShadowGenerator";
    /**
     * Shadow generator mode None: no filtering applied.
     */
    ShadowGenerator.FILTER_NONE = 0;
    /**
     * Shadow generator mode ESM: Exponential Shadow Mapping.
     * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
     */
    ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP = 1;
    /**
     * Shadow generator mode Poisson Sampling: Percentage Closer Filtering.
     * (Multiple Tap around evenly distributed around the pixel are used to evaluate the shadow strength)
     */
    ShadowGenerator.FILTER_POISSONSAMPLING = 2;
    /**
     * Shadow generator mode ESM: Blurred Exponential Shadow Mapping.
     * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
     */
    ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP = 3;
    /**
     * Shadow generator mode ESM: Exponential Shadow Mapping using the inverse of the exponential preventing
     * edge artifacts on steep falloff.
     * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
     */
    ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP = 4;
    /**
     * Shadow generator mode ESM: Blurred Exponential Shadow Mapping using the inverse of the exponential preventing
     * edge artifacts on steep falloff.
     * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
     */
    ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP = 5;
    /**
     * Shadow generator mode PCF: Percentage Closer Filtering
     * benefits from Webgl 2 shadow samplers. Fallback to Poisson Sampling in Webgl 1
     * (https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch11.html)
     */
    ShadowGenerator.FILTER_PCF = 6;
    /**
     * Shadow generator mode PCSS: Percentage Closering Soft Shadow.
     * benefits from Webgl 2 shadow samplers. Fallback to Poisson Sampling in Webgl 1
     * Contact Hardening
     */
    ShadowGenerator.FILTER_PCSS = 7;
    /**
     * Reserved for PCF and PCSS
     * Highest Quality.
     *
     * Execute PCF on a 5*5 kernel improving a lot the shadow aliasing artifacts.
     *
     * Execute PCSS with 32 taps blocker search and 64 taps PCF.
     */
    ShadowGenerator.QUALITY_HIGH = 0;
    /**
     * Reserved for PCF and PCSS
     * Good tradeoff for quality/perf cross devices
     *
     * Execute PCF on a 3*3 kernel.
     *
     * Execute PCSS with 16 taps blocker search and 32 taps PCF.
     */
    ShadowGenerator.QUALITY_MEDIUM = 1;
    /**
     * Reserved for PCF and PCSS
     * The lowest quality but the fastest.
     *
     * Execute PCF on a 1*1 kernel.
     *
     * Execute PCSS with 16 taps blocker search and 16 taps PCF.
     */
    ShadowGenerator.QUALITY_LOW = 2;
    /**
     * Defines the default alpha cutoff value used for transparent alpha tested materials.
     */
    ShadowGenerator.DEFAULT_ALPHA_CUTOFF = 0.5;
    /**
     * @param _
     * @hidden
     */
    ShadowGenerator._SceneComponentInitialization = function (_) {
        throw _WarnImport("ShadowGeneratorSceneComponent");
    };
    return ShadowGenerator;
}());
export { ShadowGenerator };
//# sourceMappingURL=shadowGenerator.js.map