{"version":3,"file":"babylonFileLoader.js","sourceRoot":"","sources":["../../../../../../lts/core/generated/Loading/Plugins/babylonFileLoader.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Camera } from \"../../Cameras/camera\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Geometry } from \"../../Meshes/geometry\";\r\nimport type { Node } from \"../../node\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Material } from \"../../Materials/material\";\r\nimport { MultiMaterial } from \"../../Materials/multiMaterial\";\r\nimport { CubeTexture } from \"../../Materials/Textures/cubeTexture\";\r\nimport { HDRCubeTexture } from \"../../Materials/Textures/hdrCubeTexture\";\r\nimport { AnimationGroup } from \"../../Animations/animationGroup\";\r\nimport { Light } from \"../../Lights/light\";\r\nimport { SceneComponentConstants } from \"../../sceneComponent\";\r\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\r\nimport { AbstractScene } from \"../../abstractScene\";\r\nimport { AssetContainer } from \"../../assetContainer\";\r\nimport { ActionManager } from \"../../Actions/actionManager\";\r\nimport type { IParticleSystem } from \"../../Particles/IParticleSystem\";\r\nimport { Skeleton } from \"../../Bones/skeleton\";\r\nimport { MorphTargetManager } from \"../../Morph/morphTargetManager\";\r\nimport { CannonJSPlugin } from \"../../Physics/Plugins/cannonJSPlugin\";\r\nimport { OimoJSPlugin } from \"../../Physics/Plugins/oimoJSPlugin\";\r\nimport { AmmoJSPlugin } from \"../../Physics/Plugins/ammoJSPlugin\";\r\nimport { ReflectionProbe } from \"../../Probes/reflectionProbe\";\r\nimport { GetClass } from \"../../Misc/typeStore\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\r\nimport { EndsWith } from \"../../Misc/stringTools\";\r\n\r\n/** @hidden */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention, no-var\r\nexport var _BabylonLoaderRegistered = true;\r\n\r\n/**\r\n * Helps setting up some configuration for the babylon file loader.\r\n */\r\nexport class BabylonFileLoaderConfiguration {\r\n    /**\r\n     * The loader does not allow injecting custom physics engine into the plugins.\r\n     * Unfortunately in ES6, we need to manually inject them into the plugin.\r\n     * So you could set this variable to your engine import to make it work.\r\n     */\r\n    public static LoaderInjectedPhysicsEngine: any = undefined;\r\n}\r\n\r\nlet tempIndexContainer: { [key: string]: Node } = {};\r\nconst tempMaterialIndexContainer: { [key: string]: Material } = {};\r\n\r\nconst parseMaterialByPredicate = (predicate: (parsedMaterial: any) => boolean, parsedData: any, scene: Scene, rootUrl: string) => {\r\n    if (!parsedData.materials) {\r\n        return null;\r\n    }\r\n\r\n    for (let index = 0, cache = parsedData.materials.length; index < cache; index++) {\r\n        const parsedMaterial = parsedData.materials[index];\r\n        if (predicate(parsedMaterial)) {\r\n            return { parsedMaterial, material: Material.Parse(parsedMaterial, scene, rootUrl) };\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nconst isDescendantOf = (mesh: any, names: Array<any>, hierarchyIds: Array<number>) => {\r\n    for (const i in names) {\r\n        if (mesh.name === names[i]) {\r\n            hierarchyIds.push(mesh.id);\r\n            return true;\r\n        }\r\n    }\r\n    if (mesh.parentId !== undefined && hierarchyIds.indexOf(mesh.parentId) !== -1) {\r\n        hierarchyIds.push(mesh.id);\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst logOperation = (operation: string, producer: { file: string; name: string; version: string; exporter_version: string }) => {\r\n    return (\r\n        operation +\r\n        \" of \" +\r\n        (producer ? producer.file + \" from \" + producer.name + \" version: \" + producer.version + \", exporter version: \" + producer.exporter_version : \"unknown\")\r\n    );\r\n};\r\n\r\nconst loadDetailLevels = (scene: Scene, mesh: AbstractMesh) => {\r\n    const mastermesh: Mesh = mesh as Mesh;\r\n\r\n    // Every value specified in the ids array of the lod data points to another mesh which should be used as the lower LOD level.\r\n    // The distances (or coverages) array values specified are used along with the lod mesh ids as a hint to determine the switching threshold for the various LODs.\r\n    if (mesh._waitingData.lods) {\r\n        if (mesh._waitingData.lods.ids && mesh._waitingData.lods.ids.length > 0) {\r\n            const lodmeshes: string[] = mesh._waitingData.lods.ids;\r\n            const wasenabled: boolean = mastermesh.isEnabled(false);\r\n            if (mesh._waitingData.lods.distances) {\r\n                const distances: number[] = mesh._waitingData.lods.distances;\r\n                if (distances.length >= lodmeshes.length) {\r\n                    const culling: number = distances.length > lodmeshes.length ? distances[distances.length - 1] : 0;\r\n                    mastermesh.setEnabled(false);\r\n                    for (let index = 0; index < lodmeshes.length; index++) {\r\n                        const lodid: string = lodmeshes[index];\r\n                        const lodmesh: Mesh = scene.getMeshById(lodid) as Mesh;\r\n                        if (lodmesh != null) {\r\n                            mastermesh.addLODLevel(distances[index], lodmesh);\r\n                        }\r\n                    }\r\n                    if (culling > 0) {\r\n                        mastermesh.addLODLevel(culling, null);\r\n                    }\r\n                    if (wasenabled === true) {\r\n                        mastermesh.setEnabled(true);\r\n                    }\r\n                } else {\r\n                    Tools.Warn(\"Invalid level of detail distances for \" + mesh.name);\r\n                }\r\n            }\r\n        }\r\n        mesh._waitingData.lods = null;\r\n    }\r\n};\r\n\r\nconst findParent = (parentId: any, scene: Scene) => {\r\n    if (typeof parentId !== \"number\") {\r\n        return scene.getLastEntryById(parentId);\r\n    }\r\n\r\n    const parent = tempIndexContainer[parentId];\r\n\r\n    return parent;\r\n};\r\n\r\nconst findMaterial = (materialId: any, scene: Scene) => {\r\n    if (typeof materialId !== \"number\") {\r\n        return scene.getLastMaterialById(materialId, true);\r\n    }\r\n\r\n    return tempMaterialIndexContainer[materialId];\r\n};\r\n\r\nconst loadAssetContainer = (scene: Scene, data: string, rootUrl: string, onError?: (message: string, exception?: any) => void, addToScene = false): AssetContainer => {\r\n    const container = new AssetContainer(scene);\r\n\r\n    // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\r\n    // when SceneLoader.debugLogging = true (default), or exception encountered.\r\n    // Everything stored in var log instead of writing separate lines to support only writing in exception,\r\n    // and avoid problems with multiple concurrent .babylon loads.\r\n    let log = \"importScene has failed JSON parse\";\r\n    try {\r\n        // eslint-disable-next-line no-var\r\n        var parsedData = JSON.parse(data);\r\n        log = \"\";\r\n        const fullDetails = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;\r\n\r\n        let index: number;\r\n        let cache: number;\r\n\r\n        // Environment texture\r\n        if (parsedData.environmentTexture !== undefined && parsedData.environmentTexture !== null) {\r\n            // PBR needed for both HDR texture (gamma space) & a sky box\r\n            const isPBR = parsedData.isPBR !== undefined ? parsedData.isPBR : true;\r\n            if (parsedData.environmentTextureType && parsedData.environmentTextureType === \"BABYLON.HDRCubeTexture\") {\r\n                const hdrSize: number = parsedData.environmentTextureSize ? parsedData.environmentTextureSize : 128;\r\n                const hdrTexture = new HDRCubeTexture(\r\n                    (parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture,\r\n                    scene,\r\n                    hdrSize,\r\n                    true,\r\n                    !isPBR,\r\n                    undefined,\r\n                    parsedData.environmentTexturePrefilterOnLoad\r\n                );\r\n                if (parsedData.environmentTextureRotationY) {\r\n                    hdrTexture.rotationY = parsedData.environmentTextureRotationY;\r\n                }\r\n                scene.environmentTexture = hdrTexture;\r\n            } else {\r\n                if (EndsWith(parsedData.environmentTexture, \".env\")) {\r\n                    const compressedTexture = new CubeTexture(\r\n                        (parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture,\r\n                        scene,\r\n                        parsedData.environmentTextureForcedExtension\r\n                    );\r\n                    if (parsedData.environmentTextureRotationY) {\r\n                        compressedTexture.rotationY = parsedData.environmentTextureRotationY;\r\n                    }\r\n                    scene.environmentTexture = compressedTexture;\r\n                } else {\r\n                    const cubeTexture = CubeTexture.CreateFromPrefilteredData(\r\n                        (parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture,\r\n                        scene,\r\n                        parsedData.environmentTextureForcedExtension\r\n                    );\r\n                    if (parsedData.environmentTextureRotationY) {\r\n                        cubeTexture.rotationY = parsedData.environmentTextureRotationY;\r\n                    }\r\n                    scene.environmentTexture = cubeTexture;\r\n                }\r\n            }\r\n            if (parsedData.createDefaultSkybox === true) {\r\n                const skyboxScale = scene.activeCamera !== undefined && scene.activeCamera !== null ? (scene.activeCamera.maxZ - scene.activeCamera.minZ) / 2 : 1000;\r\n                const skyboxBlurLevel = parsedData.skyboxBlurLevel || 0;\r\n                scene.createDefaultSkybox(scene.environmentTexture, isPBR, skyboxScale, skyboxBlurLevel);\r\n            }\r\n            container.environmentTexture = scene.environmentTexture;\r\n        }\r\n\r\n        // Environment Intensity\r\n        if (parsedData.environmentIntensity !== undefined && parsedData.environmentIntensity !== null) {\r\n            scene.environmentIntensity = parsedData.environmentIntensity;\r\n        }\r\n\r\n        // Lights\r\n        if (parsedData.lights !== undefined && parsedData.lights !== null) {\r\n            for (index = 0, cache = parsedData.lights.length; index < cache; index++) {\r\n                const parsedLight = parsedData.lights[index];\r\n                const light = Light.Parse(parsedLight, scene);\r\n                if (light) {\r\n                    tempIndexContainer[parsedLight.uniqueId] = light;\r\n                    container.lights.push(light);\r\n                    light._parentContainer = container;\r\n                    log += index === 0 ? \"\\n\\tLights:\" : \"\";\r\n                    log += \"\\n\\t\\t\" + light.toString(fullDetails);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Reflection probes\r\n        if (parsedData.reflectionProbes !== undefined && parsedData.reflectionProbes !== null) {\r\n            for (index = 0, cache = parsedData.reflectionProbes.length; index < cache; index++) {\r\n                const parsedReflectionProbe = parsedData.reflectionProbes[index];\r\n                const reflectionProbe = ReflectionProbe.Parse(parsedReflectionProbe, scene, rootUrl);\r\n                if (reflectionProbe) {\r\n                    container.reflectionProbes.push(reflectionProbe);\r\n                    reflectionProbe._parentContainer = container;\r\n                    log += index === 0 ? \"\\n\\tReflection Probes:\" : \"\";\r\n                    log += \"\\n\\t\\t\" + reflectionProbe.toString(fullDetails);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Animations\r\n        if (parsedData.animations !== undefined && parsedData.animations !== null) {\r\n            for (index = 0, cache = parsedData.animations.length; index < cache; index++) {\r\n                const parsedAnimation = parsedData.animations[index];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    const animation = internalClass.Parse(parsedAnimation);\r\n                    scene.animations.push(animation);\r\n                    container.animations.push(animation);\r\n                    log += index === 0 ? \"\\n\\tAnimations:\" : \"\";\r\n                    log += \"\\n\\t\\t\" + animation.toString(fullDetails);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Materials\r\n        if (parsedData.materials !== undefined && parsedData.materials !== null) {\r\n            for (index = 0, cache = parsedData.materials.length; index < cache; index++) {\r\n                const parsedMaterial = parsedData.materials[index];\r\n                const mat = Material.Parse(parsedMaterial, scene, rootUrl);\r\n                if (mat) {\r\n                    tempMaterialIndexContainer[parsedMaterial.uniqueId || parsedMaterial.id] = mat;\r\n                    container.materials.push(mat);\r\n                    mat._parentContainer = container;\r\n                    log += index === 0 ? \"\\n\\tMaterials:\" : \"\";\r\n                    log += \"\\n\\t\\t\" + mat.toString(fullDetails);\r\n\r\n                    // Textures\r\n                    const textures = mat.getActiveTextures();\r\n                    textures.forEach((t) => {\r\n                        if (container.textures.indexOf(t) == -1) {\r\n                            container.textures.push(t);\r\n                            t._parentContainer = container;\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        if (parsedData.multiMaterials !== undefined && parsedData.multiMaterials !== null) {\r\n            for (index = 0, cache = parsedData.multiMaterials.length; index < cache; index++) {\r\n                const parsedMultiMaterial = parsedData.multiMaterials[index];\r\n                const mmat = MultiMaterial.ParseMultiMaterial(parsedMultiMaterial, scene);\r\n                tempMaterialIndexContainer[parsedMultiMaterial.uniqueId || parsedMultiMaterial.id] = mmat;\r\n                container.multiMaterials.push(mmat);\r\n                mmat._parentContainer = container;\r\n\r\n                log += index === 0 ? \"\\n\\tMultiMaterials:\" : \"\";\r\n                log += \"\\n\\t\\t\" + mmat.toString(fullDetails);\r\n\r\n                // Textures\r\n                const textures = mmat.getActiveTextures();\r\n                textures.forEach((t) => {\r\n                    if (container.textures.indexOf(t) == -1) {\r\n                        container.textures.push(t);\r\n                        t._parentContainer = container;\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        // Morph targets\r\n        if (parsedData.morphTargetManagers !== undefined && parsedData.morphTargetManagers !== null) {\r\n            for (const managerData of parsedData.morphTargetManagers) {\r\n                const manager = MorphTargetManager.Parse(managerData, scene);\r\n                container.morphTargetManagers.push(manager);\r\n                manager._parentContainer = container;\r\n            }\r\n        }\r\n\r\n        // Skeletons\r\n        if (parsedData.skeletons !== undefined && parsedData.skeletons !== null) {\r\n            for (index = 0, cache = parsedData.skeletons.length; index < cache; index++) {\r\n                const parsedSkeleton = parsedData.skeletons[index];\r\n                const skeleton = Skeleton.Parse(parsedSkeleton, scene);\r\n                container.skeletons.push(skeleton);\r\n                skeleton._parentContainer = container;\r\n                log += index === 0 ? \"\\n\\tSkeletons:\" : \"\";\r\n                log += \"\\n\\t\\t\" + skeleton.toString(fullDetails);\r\n            }\r\n        }\r\n\r\n        // Geometries\r\n        const geometries = parsedData.geometries;\r\n        if (geometries !== undefined && geometries !== null) {\r\n            const addedGeometry = new Array<Nullable<Geometry>>();\r\n\r\n            // VertexData\r\n            const vertexData = geometries.vertexData;\r\n            if (vertexData !== undefined && vertexData !== null) {\r\n                for (index = 0, cache = vertexData.length; index < cache; index++) {\r\n                    const parsedVertexData = vertexData[index];\r\n                    addedGeometry.push(Geometry.Parse(parsedVertexData, scene, rootUrl));\r\n                }\r\n            }\r\n\r\n            addedGeometry.forEach((g) => {\r\n                if (g) {\r\n                    container.geometries.push(g);\r\n                    g._parentContainer = container;\r\n                }\r\n            });\r\n        }\r\n\r\n        // Transform nodes\r\n        if (parsedData.transformNodes !== undefined && parsedData.transformNodes !== null) {\r\n            for (index = 0, cache = parsedData.transformNodes.length; index < cache; index++) {\r\n                const parsedTransformNode = parsedData.transformNodes[index];\r\n                const node = TransformNode.Parse(parsedTransformNode, scene, rootUrl);\r\n                tempIndexContainer[parsedTransformNode.uniqueId] = node;\r\n                container.transformNodes.push(node);\r\n                node._parentContainer = container;\r\n            }\r\n        }\r\n\r\n        // Meshes\r\n        if (parsedData.meshes !== undefined && parsedData.meshes !== null) {\r\n            for (index = 0, cache = parsedData.meshes.length; index < cache; index++) {\r\n                const parsedMesh = parsedData.meshes[index];\r\n                const mesh = <AbstractMesh>Mesh.Parse(parsedMesh, scene, rootUrl);\r\n                tempIndexContainer[parsedMesh.uniqueId] = mesh;\r\n                container.meshes.push(mesh);\r\n                mesh._parentContainer = container;\r\n                if (mesh.hasInstances) {\r\n                    for (const instance of (mesh as Mesh).instances) {\r\n                        container.meshes.push(instance);\r\n                        instance._parentContainer = container;\r\n                    }\r\n                }\r\n                log += index === 0 ? \"\\n\\tMeshes:\" : \"\";\r\n                log += \"\\n\\t\\t\" + mesh.toString(fullDetails);\r\n            }\r\n        }\r\n\r\n        // Cameras\r\n        if (parsedData.cameras !== undefined && parsedData.cameras !== null) {\r\n            for (index = 0, cache = parsedData.cameras.length; index < cache; index++) {\r\n                const parsedCamera = parsedData.cameras[index];\r\n                const camera = Camera.Parse(parsedCamera, scene);\r\n                tempIndexContainer[parsedCamera.uniqueId] = camera;\r\n                container.cameras.push(camera);\r\n                camera._parentContainer = container;\r\n                log += index === 0 ? \"\\n\\tCameras:\" : \"\";\r\n                log += \"\\n\\t\\t\" + camera.toString(fullDetails);\r\n            }\r\n        }\r\n\r\n        // Postprocesses\r\n        if (parsedData.postProcesses !== undefined && parsedData.postProcesses !== null) {\r\n            for (index = 0, cache = parsedData.postProcesses.length; index < cache; index++) {\r\n                const parsedPostProcess = parsedData.postProcesses[index];\r\n                const postProcess = PostProcess.Parse(parsedPostProcess, scene, rootUrl);\r\n                if (postProcess) {\r\n                    container.postProcesses.push(postProcess);\r\n                    postProcess._parentContainer = container;\r\n                    log += index === 0 ? \"\\nPostprocesses:\" : \"\";\r\n                    log += \"\\n\\t\\t\" + postProcess.toString();\r\n                }\r\n            }\r\n        }\r\n\r\n        // Animation Groups\r\n        if (parsedData.animationGroups !== undefined && parsedData.animationGroups !== null) {\r\n            for (index = 0, cache = parsedData.animationGroups.length; index < cache; index++) {\r\n                const parsedAnimationGroup = parsedData.animationGroups[index];\r\n                const animationGroup = AnimationGroup.Parse(parsedAnimationGroup, scene);\r\n                container.animationGroups.push(animationGroup);\r\n                animationGroup._parentContainer = container;\r\n                log += index === 0 ? \"\\n\\tAnimationGroups:\" : \"\";\r\n                log += \"\\n\\t\\t\" + animationGroup.toString(fullDetails);\r\n            }\r\n        }\r\n\r\n        // Browsing all the graph to connect the dots\r\n        for (index = 0, cache = scene.cameras.length; index < cache; index++) {\r\n            const camera = scene.cameras[index];\r\n            if (camera._waitingParentId !== null) {\r\n                camera.parent = findParent(camera._waitingParentId, scene);\r\n                camera._waitingParentId = null;\r\n            }\r\n        }\r\n\r\n        for (index = 0, cache = scene.lights.length; index < cache; index++) {\r\n            const light = scene.lights[index];\r\n            if (light && light._waitingParentId !== null) {\r\n                light.parent = findParent(light._waitingParentId, scene);\r\n                light._waitingParentId = null;\r\n            }\r\n        }\r\n\r\n        // Connect parents & children and parse actions and lods\r\n        for (index = 0, cache = scene.transformNodes.length; index < cache; index++) {\r\n            const transformNode = scene.transformNodes[index];\r\n            if (transformNode._waitingParentId !== null) {\r\n                transformNode.parent = findParent(transformNode._waitingParentId, scene);\r\n                transformNode._waitingParentId = null;\r\n            }\r\n        }\r\n        for (index = 0, cache = scene.meshes.length; index < cache; index++) {\r\n            const mesh = scene.meshes[index];\r\n            if (mesh._waitingParentId !== null) {\r\n                mesh.parent = findParent(mesh._waitingParentId, scene);\r\n                mesh._waitingParentId = null;\r\n            }\r\n            if (mesh._waitingData.lods) {\r\n                loadDetailLevels(scene, mesh);\r\n            }\r\n        }\r\n\r\n        // link multimats with materials\r\n        scene.multiMaterials.forEach((multimat) => {\r\n            multimat._waitingSubMaterialsUniqueIds.forEach((subMaterial) => {\r\n                multimat.subMaterials.push(findMaterial(subMaterial, scene));\r\n            });\r\n            multimat._waitingSubMaterialsUniqueIds = [];\r\n        });\r\n\r\n        // link meshes with materials\r\n        scene.meshes.forEach((mesh) => {\r\n            if (mesh._waitingMaterialId !== null) {\r\n                mesh.material = findMaterial(mesh._waitingMaterialId, scene);\r\n                mesh._waitingMaterialId = null;\r\n            }\r\n        });\r\n\r\n        // link skeleton transform nodes\r\n        for (index = 0, cache = scene.skeletons.length; index < cache; index++) {\r\n            const skeleton = scene.skeletons[index];\r\n            if (skeleton._hasWaitingData) {\r\n                if (skeleton.bones != null) {\r\n                    skeleton.bones.forEach((bone) => {\r\n                        if (bone._waitingTransformNodeId) {\r\n                            const linkTransformNode = scene.getLastEntryById(bone._waitingTransformNodeId) as TransformNode;\r\n                            if (linkTransformNode) {\r\n                                bone.linkTransformNode(linkTransformNode);\r\n                            }\r\n                            bone._waitingTransformNodeId = null;\r\n                        }\r\n                    });\r\n                }\r\n\r\n                skeleton._hasWaitingData = null;\r\n            }\r\n        }\r\n\r\n        // freeze world matrix application\r\n        for (index = 0, cache = scene.meshes.length; index < cache; index++) {\r\n            const currentMesh = scene.meshes[index];\r\n            if (currentMesh._waitingData.freezeWorldMatrix) {\r\n                currentMesh.freezeWorldMatrix();\r\n                currentMesh._waitingData.freezeWorldMatrix = null;\r\n            } else {\r\n                currentMesh.computeWorldMatrix(true);\r\n            }\r\n        }\r\n\r\n        // Lights exclusions / inclusions\r\n        for (index = 0, cache = scene.lights.length; index < cache; index++) {\r\n            const light = scene.lights[index];\r\n            // Excluded check\r\n            if (light._excludedMeshesIds.length > 0) {\r\n                for (let excludedIndex = 0; excludedIndex < light._excludedMeshesIds.length; excludedIndex++) {\r\n                    const excludedMesh = scene.getMeshById(light._excludedMeshesIds[excludedIndex]);\r\n\r\n                    if (excludedMesh) {\r\n                        light.excludedMeshes.push(excludedMesh);\r\n                    }\r\n                }\r\n\r\n                light._excludedMeshesIds = [];\r\n            }\r\n\r\n            // Included check\r\n            if (light._includedOnlyMeshesIds.length > 0) {\r\n                for (let includedOnlyIndex = 0; includedOnlyIndex < light._includedOnlyMeshesIds.length; includedOnlyIndex++) {\r\n                    const includedOnlyMesh = scene.getMeshById(light._includedOnlyMeshesIds[includedOnlyIndex]);\r\n\r\n                    if (includedOnlyMesh) {\r\n                        light.includedOnlyMeshes.push(includedOnlyMesh);\r\n                    }\r\n                }\r\n\r\n                light._includedOnlyMeshesIds = [];\r\n            }\r\n        }\r\n\r\n        AbstractScene.Parse(parsedData, scene, container, rootUrl);\r\n\r\n        // Actions (scene) Done last as it can access other objects.\r\n        for (index = 0, cache = scene.meshes.length; index < cache; index++) {\r\n            const mesh = scene.meshes[index];\r\n            if (mesh._waitingData.actions) {\r\n                ActionManager.Parse(mesh._waitingData.actions, mesh, scene);\r\n                mesh._waitingData.actions = null;\r\n            }\r\n        }\r\n        if (parsedData.actions !== undefined && parsedData.actions !== null) {\r\n            ActionManager.Parse(parsedData.actions, null, scene);\r\n        }\r\n    } catch (err) {\r\n        const msg = logOperation(\"loadAssets\", parsedData ? parsedData.producer : \"Unknown\") + log;\r\n        if (onError) {\r\n            onError(msg, err);\r\n        } else {\r\n            Logger.Log(msg);\r\n            throw err;\r\n        }\r\n    } finally {\r\n        tempIndexContainer = {};\r\n\r\n        if (!addToScene) {\r\n            container.removeAllFromScene();\r\n        }\r\n        if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\r\n            Logger.Log(logOperation(\"loadAssets\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\r\n        }\r\n    }\r\n\r\n    return container;\r\n};\r\n\r\nSceneLoader.RegisterPlugin({\r\n    name: \"babylon.js\",\r\n    extensions: \".babylon\",\r\n    canDirectLoad: (data: string) => {\r\n        if (data.indexOf(\"babylon\") !== -1) {\r\n            // We consider that the producer string is filled\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    },\r\n    importMesh: (\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        data: any,\r\n        rootUrl: string,\r\n        meshes: AbstractMesh[],\r\n        particleSystems: IParticleSystem[],\r\n        skeletons: Skeleton[],\r\n        onError?: (message: string, exception?: any) => void\r\n    ): boolean => {\r\n        // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\r\n        // when SceneLoader.debugLogging = true (default), or exception encountered.\r\n        // Everything stored in var log instead of writing separate lines to support only writing in exception,\r\n        // and avoid problems with multiple concurrent .babylon loads.\r\n        let log = \"importMesh has failed JSON parse\";\r\n        try {\r\n            // eslint-disable-next-line no-var\r\n            var parsedData = JSON.parse(data);\r\n            log = \"\";\r\n            const fullDetails = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;\r\n            if (!meshesNames) {\r\n                meshesNames = null;\r\n            } else if (!Array.isArray(meshesNames)) {\r\n                meshesNames = [meshesNames];\r\n            }\r\n\r\n            const hierarchyIds = new Array<number>();\r\n\r\n            // Transform nodes (the overall idea is to load all of them as this is super fast and then get rid of the ones we don't need)\r\n            const loadedTransformNodes = [];\r\n            if (parsedData.transformNodes !== undefined && parsedData.transformNodes !== null) {\r\n                for (let index = 0, cache = parsedData.transformNodes.length; index < cache; index++) {\r\n                    const parsedTransformNode = parsedData.transformNodes[index];\r\n                    loadedTransformNodes.push(TransformNode.Parse(parsedTransformNode, scene, rootUrl));\r\n                }\r\n            }\r\n\r\n            if (parsedData.meshes !== undefined && parsedData.meshes !== null) {\r\n                const loadedSkeletonsIds = [];\r\n                const loadedMaterialsIds: string[] = [];\r\n                const loadedMaterialsUniqueIds: string[] = [];\r\n                const loadedMorphTargetsIds = [];\r\n                for (let index = 0, cache = parsedData.meshes.length; index < cache; index++) {\r\n                    const parsedMesh = parsedData.meshes[index];\r\n\r\n                    if (meshesNames === null || isDescendantOf(parsedMesh, meshesNames, hierarchyIds)) {\r\n                        if (meshesNames !== null) {\r\n                            // Remove found mesh name from list.\r\n                            delete meshesNames[meshesNames.indexOf(parsedMesh.name)];\r\n                        }\r\n\r\n                        //Geometry?\r\n                        if (parsedMesh.geometryId !== undefined && parsedMesh.geometryId !== null) {\r\n                            //does the file contain geometries?\r\n                            if (parsedData.geometries !== undefined && parsedData.geometries !== null) {\r\n                                //find the correct geometry and add it to the scene\r\n                                let found: boolean = false;\r\n                                [\"boxes\", \"spheres\", \"cylinders\", \"toruses\", \"grounds\", \"planes\", \"torusKnots\", \"vertexData\"].forEach((geometryType: string) => {\r\n                                    if (found === true || !parsedData.geometries[geometryType] || !Array.isArray(parsedData.geometries[geometryType])) {\r\n                                        return;\r\n                                    } else {\r\n                                        parsedData.geometries[geometryType].forEach((parsedGeometryData: any) => {\r\n                                            if (parsedGeometryData.id === parsedMesh.geometryId) {\r\n                                                switch (geometryType) {\r\n                                                    case \"vertexData\":\r\n                                                        Geometry.Parse(parsedGeometryData, scene, rootUrl);\r\n                                                        break;\r\n                                                }\r\n                                                found = true;\r\n                                            }\r\n                                        });\r\n                                    }\r\n                                });\r\n                                if (found === false) {\r\n                                    Logger.Warn(\"Geometry not found for mesh \" + parsedMesh.id);\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // Material ?\r\n                        if (parsedMesh.materialUniqueId || parsedMesh.materialId) {\r\n                            // if we have a unique ID, look up and store in loadedMaterialsUniqueIds, else use loadedMaterialsIds\r\n                            const materialArray = parsedMesh.materialUniqueId ? loadedMaterialsUniqueIds : loadedMaterialsIds;\r\n                            let materialFound = materialArray.indexOf(parsedMesh.materialUniqueId || parsedMesh.materialId) !== -1;\r\n                            if (materialFound === false && parsedData.multiMaterials !== undefined && parsedData.multiMaterials !== null) {\r\n                                // Loads a submaterial of a multimaterial\r\n                                const loadSubMaterial = (subMatId: string, predicate: (parsedMaterial: any) => boolean) => {\r\n                                    materialArray.push(subMatId);\r\n                                    const mat = parseMaterialByPredicate(predicate, parsedData, scene, rootUrl);\r\n                                    if (mat && mat.material) {\r\n                                        tempMaterialIndexContainer[mat.parsedMaterial.uniqueId || mat.parsedMaterial.id] = mat.material;\r\n                                        log += \"\\n\\tMaterial \" + mat.material.toString(fullDetails);\r\n                                    }\r\n                                };\r\n                                for (let multimatIndex = 0, multimatCache = parsedData.multiMaterials.length; multimatIndex < multimatCache; multimatIndex++) {\r\n                                    const parsedMultiMaterial = parsedData.multiMaterials[multimatIndex];\r\n                                    if (\r\n                                        (parsedMesh.materialUniqueId && parsedMultiMaterial.uniqueId === parsedMesh.materialUniqueId) ||\r\n                                        parsedMultiMaterial.id === parsedMesh.materialId\r\n                                    ) {\r\n                                        if (parsedMultiMaterial.materialsUniqueIds) {\r\n                                            // if the materials inside the multimat are stored by unique id\r\n                                            parsedMultiMaterial.materialsUniqueIds.forEach((subMatId: string) =>\r\n                                                loadSubMaterial(subMatId, (parsedMaterial) => parsedMaterial.uniqueId === subMatId)\r\n                                            );\r\n                                        } else {\r\n                                            // if the mats are stored by id instead\r\n                                            parsedMultiMaterial.materials.forEach((subMatId: string) =>\r\n                                                loadSubMaterial(subMatId, (parsedMaterial) => parsedMaterial.id === subMatId)\r\n                                            );\r\n                                        }\r\n                                        materialArray.push(parsedMultiMaterial.uniqueId || parsedMultiMaterial.id);\r\n                                        const mmat = MultiMaterial.ParseMultiMaterial(parsedMultiMaterial, scene);\r\n                                        tempMaterialIndexContainer[parsedMultiMaterial.uniqueId || parsedMultiMaterial.id] = mmat;\r\n                                        if (mmat) {\r\n                                            materialFound = true;\r\n                                            log += \"\\n\\tMulti-Material \" + mmat.toString(fullDetails);\r\n                                        }\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            if (materialFound === false) {\r\n                                materialArray.push(parsedMesh.materialUniqueId || parsedMesh.materialId);\r\n                                const mat = parseMaterialByPredicate(\r\n                                    (parsedMaterial) =>\r\n                                        (parsedMesh.materialUniqueId && parsedMaterial.uniqueId === parsedMesh.materialUniqueId) || parsedMaterial.id === parsedMesh.materialId,\r\n                                    parsedData,\r\n                                    scene,\r\n                                    rootUrl\r\n                                );\r\n                                if (!mat || !mat.material) {\r\n                                    Logger.Warn(\"Material not found for mesh \" + parsedMesh.id);\r\n                                } else {\r\n                                    tempMaterialIndexContainer[mat.parsedMaterial.uniqueId || mat.parsedMaterial.id] = mat.material;\r\n                                    log += \"\\n\\tMaterial \" + mat.material.toString(fullDetails);\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // Skeleton ?\r\n                        if (parsedMesh.skeletonId > -1 && parsedData.skeletons !== undefined && parsedData.skeletons !== null) {\r\n                            const skeletonAlreadyLoaded = loadedSkeletonsIds.indexOf(parsedMesh.skeletonId) > -1;\r\n                            if (!skeletonAlreadyLoaded) {\r\n                                for (let skeletonIndex = 0, skeletonCache = parsedData.skeletons.length; skeletonIndex < skeletonCache; skeletonIndex++) {\r\n                                    const parsedSkeleton = parsedData.skeletons[skeletonIndex];\r\n                                    if (parsedSkeleton.id === parsedMesh.skeletonId) {\r\n                                        const skeleton = Skeleton.Parse(parsedSkeleton, scene);\r\n                                        skeletons.push(skeleton);\r\n                                        loadedSkeletonsIds.push(parsedSkeleton.id);\r\n                                        log += \"\\n\\tSkeleton \" + skeleton.toString(fullDetails);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // Morph targets ?\r\n                        if (parsedMesh.morphTargetManagerId > -1 && parsedData.morphTargetManagers !== undefined && parsedData.morphTargetManagers !== null) {\r\n                            const morphTargetAlreadyLoaded = loadedMorphTargetsIds.indexOf(parsedMesh.morphTargetManagerId) > -1;\r\n                            if (!morphTargetAlreadyLoaded) {\r\n                                for (let morphTargetIndex = 0, morphTargetCache = parsedData.morphTargetManagers.length; morphTargetIndex < morphTargetCache; morphTargetIndex++) {\r\n                                    const parsedMorphTarget = parsedData.morphTargetManagers[morphTargetIndex];\r\n                                    if (parsedMorphTarget.id === parsedMesh.morphTargetManagerId) {\r\n                                        const morphTarget = MorphTargetManager.Parse(parsedMorphTarget, scene);\r\n                                        loadedMorphTargetsIds.push(morphTarget.uniqueId);\r\n                                        log += \"\\nMorph target \" + morphTarget.toString();\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        const mesh = Mesh.Parse(parsedMesh, scene, rootUrl);\r\n                        meshes.push(mesh);\r\n                        log += \"\\n\\tMesh \" + mesh.toString(fullDetails);\r\n                    }\r\n                }\r\n\r\n                // link multimats with materials\r\n                scene.multiMaterials.forEach((multimat) => {\r\n                    multimat._waitingSubMaterialsUniqueIds.forEach((subMaterial) => {\r\n                        multimat.subMaterials.push(findMaterial(subMaterial, scene));\r\n                    });\r\n                    multimat._waitingSubMaterialsUniqueIds = [];\r\n                });\r\n\r\n                // link meshes with materials\r\n                scene.meshes.forEach((mesh) => {\r\n                    if (mesh._waitingMaterialId !== null) {\r\n                        mesh.material = findMaterial(mesh._waitingMaterialId, scene);\r\n                        mesh._waitingMaterialId = null;\r\n                    }\r\n                });\r\n\r\n                // Connecting parents and lods\r\n                for (let index = 0, cache = scene.transformNodes.length; index < cache; index++) {\r\n                    const transformNode = scene.transformNodes[index];\r\n                    if (transformNode._waitingParentId !== null) {\r\n                        transformNode.parent = scene.getLastEntryById(transformNode._waitingParentId);\r\n                        transformNode._waitingParentId = null;\r\n                    }\r\n                }\r\n                let currentMesh: AbstractMesh;\r\n                for (let index = 0, cache = scene.meshes.length; index < cache; index++) {\r\n                    currentMesh = scene.meshes[index];\r\n                    if (currentMesh._waitingParentId) {\r\n                        currentMesh.parent = scene.getLastEntryById(currentMesh._waitingParentId);\r\n                        if (currentMesh.parent?.getClassName() === \"TransformNode\") {\r\n                            const loadedTransformNodeIndex = loadedTransformNodes.indexOf(currentMesh.parent as TransformNode);\r\n                            if (loadedTransformNodeIndex > -1) {\r\n                                loadedTransformNodes.splice(loadedTransformNodeIndex, 1);\r\n                            }\r\n                        }\r\n                        currentMesh._waitingParentId = null;\r\n                    }\r\n                    if (currentMesh._waitingData.lods) {\r\n                        loadDetailLevels(scene, currentMesh);\r\n                    }\r\n                }\r\n\r\n                // Remove unused transform nodes\r\n                for (const transformNode of loadedTransformNodes) {\r\n                    transformNode.dispose();\r\n                }\r\n\r\n                // link skeleton transform nodes\r\n                for (let index = 0, cache = scene.skeletons.length; index < cache; index++) {\r\n                    const skeleton = scene.skeletons[index];\r\n                    if (skeleton._hasWaitingData) {\r\n                        if (skeleton.bones != null) {\r\n                            skeleton.bones.forEach((bone) => {\r\n                                if (bone._waitingTransformNodeId) {\r\n                                    const linkTransformNode = scene.getLastEntryById(bone._waitingTransformNodeId) as TransformNode;\r\n                                    if (linkTransformNode) {\r\n                                        bone.linkTransformNode(linkTransformNode);\r\n                                    }\r\n                                    bone._waitingTransformNodeId = null;\r\n                                }\r\n                            });\r\n                        }\r\n\r\n                        skeleton._hasWaitingData = null;\r\n                    }\r\n                }\r\n\r\n                // freeze and compute world matrix application\r\n                for (let index = 0, cache = scene.meshes.length; index < cache; index++) {\r\n                    currentMesh = scene.meshes[index];\r\n                    if (currentMesh._waitingData.freezeWorldMatrix) {\r\n                        currentMesh.freezeWorldMatrix();\r\n                        currentMesh._waitingData.freezeWorldMatrix = null;\r\n                    } else {\r\n                        currentMesh.computeWorldMatrix(true);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Particles\r\n            if (parsedData.particleSystems !== undefined && parsedData.particleSystems !== null) {\r\n                const parser = AbstractScene.GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);\r\n                if (parser) {\r\n                    for (let index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {\r\n                        const parsedParticleSystem = parsedData.particleSystems[index];\r\n                        if (hierarchyIds.indexOf(parsedParticleSystem.emitterId) !== -1) {\r\n                            particleSystems.push(parser(parsedParticleSystem, scene, rootUrl));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        } catch (err) {\r\n            const msg = logOperation(\"importMesh\", parsedData ? parsedData.producer : \"Unknown\") + log;\r\n            if (onError) {\r\n                onError(msg, err);\r\n            } else {\r\n                Logger.Log(msg);\r\n                throw err;\r\n            }\r\n        } finally {\r\n            if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\r\n                Logger.Log(logOperation(\"importMesh\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\r\n            }\r\n        }\r\n\r\n        return false;\r\n    },\r\n    load: (scene: Scene, data: string, rootUrl: string, onError?: (message: string, exception?: any) => void): boolean => {\r\n        // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\r\n        // when SceneLoader.debugLogging = true (default), or exception encountered.\r\n        // Everything stored in var log instead of writing separate lines to support only writing in exception,\r\n        // and avoid problems with multiple concurrent .babylon loads.\r\n        let log = \"importScene has failed JSON parse\";\r\n        try {\r\n            // eslint-disable-next-line no-var\r\n            var parsedData = JSON.parse(data);\r\n            log = \"\";\r\n\r\n            // Scene\r\n            if (parsedData.useDelayedTextureLoading !== undefined && parsedData.useDelayedTextureLoading !== null) {\r\n                scene.useDelayedTextureLoading = parsedData.useDelayedTextureLoading && !SceneLoader.ForceFullSceneLoadingForIncremental;\r\n            }\r\n            if (parsedData.autoClear !== undefined && parsedData.autoClear !== null) {\r\n                scene.autoClear = parsedData.autoClear;\r\n            }\r\n            if (parsedData.clearColor !== undefined && parsedData.clearColor !== null) {\r\n                scene.clearColor = Color4.FromArray(parsedData.clearColor);\r\n            }\r\n            if (parsedData.ambientColor !== undefined && parsedData.ambientColor !== null) {\r\n                scene.ambientColor = Color3.FromArray(parsedData.ambientColor);\r\n            }\r\n            if (parsedData.gravity !== undefined && parsedData.gravity !== null) {\r\n                scene.gravity = Vector3.FromArray(parsedData.gravity);\r\n            }\r\n\r\n            if (parsedData.useRightHandedSystem !== undefined) {\r\n                scene.useRightHandedSystem = !!parsedData.useRightHandedSystem;\r\n            }\r\n\r\n            // Fog\r\n            if (parsedData.fogMode && parsedData.fogMode !== 0) {\r\n                scene.fogMode = parsedData.fogMode;\r\n                scene.fogColor = Color3.FromArray(parsedData.fogColor);\r\n                scene.fogStart = parsedData.fogStart;\r\n                scene.fogEnd = parsedData.fogEnd;\r\n                scene.fogDensity = parsedData.fogDensity;\r\n                log += \"\\tFog mode for scene:  \";\r\n                switch (scene.fogMode) {\r\n                    // getters not compiling, so using hardcoded\r\n                    case 1:\r\n                        log += \"exp\\n\";\r\n                        break;\r\n                    case 2:\r\n                        log += \"exp2\\n\";\r\n                        break;\r\n                    case 3:\r\n                        log += \"linear\\n\";\r\n                        break;\r\n                }\r\n            }\r\n\r\n            //Physics\r\n            if (parsedData.physicsEnabled) {\r\n                let physicsPlugin;\r\n                if (parsedData.physicsEngine === \"cannon\") {\r\n                    physicsPlugin = new CannonJSPlugin(undefined, undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine);\r\n                } else if (parsedData.physicsEngine === \"oimo\") {\r\n                    physicsPlugin = new OimoJSPlugin(undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine);\r\n                } else if (parsedData.physicsEngine === \"ammo\") {\r\n                    physicsPlugin = new AmmoJSPlugin(undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine, undefined);\r\n                }\r\n                log = \"\\tPhysics engine \" + (parsedData.physicsEngine ? parsedData.physicsEngine : \"oimo\") + \" enabled\\n\";\r\n                //else - default engine, which is currently oimo\r\n                const physicsGravity = parsedData.physicsGravity ? Vector3.FromArray(parsedData.physicsGravity) : null;\r\n                scene.enablePhysics(physicsGravity, physicsPlugin);\r\n            }\r\n\r\n            // Metadata\r\n            if (parsedData.metadata !== undefined && parsedData.metadata !== null) {\r\n                scene.metadata = parsedData.metadata;\r\n            }\r\n\r\n            //collisions, if defined. otherwise, default is true\r\n            if (parsedData.collisionsEnabled !== undefined && parsedData.collisionsEnabled !== null) {\r\n                scene.collisionsEnabled = parsedData.collisionsEnabled;\r\n            }\r\n\r\n            const container = loadAssetContainer(scene, data, rootUrl, onError, true);\r\n            if (!container) {\r\n                return false;\r\n            }\r\n\r\n            if (parsedData.autoAnimate) {\r\n                scene.beginAnimation(scene, parsedData.autoAnimateFrom, parsedData.autoAnimateTo, parsedData.autoAnimateLoop, parsedData.autoAnimateSpeed || 1.0);\r\n            }\r\n\r\n            if (parsedData.activeCameraID !== undefined && parsedData.activeCameraID !== null) {\r\n                scene.setActiveCameraById(parsedData.activeCameraID);\r\n            }\r\n\r\n            // Finish\r\n            return true;\r\n        } catch (err) {\r\n            const msg = logOperation(\"importScene\", parsedData ? parsedData.producer : \"Unknown\") + log;\r\n            if (onError) {\r\n                onError(msg, err);\r\n            } else {\r\n                Logger.Log(msg);\r\n                throw err;\r\n            }\r\n        } finally {\r\n            if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\r\n                Logger.Log(logOperation(\"importScene\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n    loadAssetContainer: (scene: Scene, data: string, rootUrl: string, onError?: (message: string, exception?: any) => void): AssetContainer => {\r\n        const container = loadAssetContainer(scene, data, rootUrl, onError);\r\n        return container;\r\n    },\r\n});\r\n"]}