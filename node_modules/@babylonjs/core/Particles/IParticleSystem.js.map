{"version":3,"file":"IParticleSystem.js","sourceRoot":"","sources":["../../../../../lts/core/generated/Particles/IParticleSystem.ts"],"names":[],"mappings":"","sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { Vector2, Vector3, Matrix } from \"../Maths/math.vector\";\r\nimport type { Color3, Color4 } from \"../Maths/math.color\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type {\r\n    BoxParticleEmitter,\r\n    IParticleEmitterType,\r\n    PointParticleEmitter,\r\n    HemisphericParticleEmitter,\r\n    SphereParticleEmitter,\r\n    SphereDirectedParticleEmitter,\r\n    CylinderParticleEmitter,\r\n    ConeParticleEmitter,\r\n    // eslint-disable-next-line import/no-internal-modules\r\n} from \"../Particles/EmitterTypes/index\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { ColorGradient, FactorGradient, Color3Gradient } from \"../Misc/gradients\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { Observable } from \"../Misc/observable\";\r\n\r\ndeclare type Animation = import(\"../Animations/animation\").Animation;\r\ndeclare type AbstractMesh = import(\"../Meshes/abstractMesh\").AbstractMesh;\r\n\r\n/**\r\n * Interface representing a particle system in Babylon.js.\r\n * This groups the common functionalities that needs to be implemented in order to create a particle system.\r\n * A particle system represents a way to manage particles from their emission to their animation and rendering.\r\n */\r\nexport interface IParticleSystem {\r\n    /**\r\n     * List of animations used by the particle system.\r\n     */\r\n    animations: Animation[];\r\n    /**\r\n     * The id of the Particle system.\r\n     */\r\n    id: string;\r\n    /**\r\n     * The name of the Particle system.\r\n     */\r\n    name: string;\r\n    /**\r\n     * The emitter represents the Mesh or position we are attaching the particle system to.\r\n     */\r\n    emitter: Nullable<AbstractMesh | Vector3>;\r\n    /**\r\n     * Gets or sets a boolean indicating if the particles must be rendered as billboard or aligned with the direction\r\n     */\r\n    isBillboardBased: boolean;\r\n    /**\r\n     * The rendering group used by the Particle system to chose when to render.\r\n     */\r\n    renderingGroupId: number;\r\n    /**\r\n     * The layer mask we are rendering the particles through.\r\n     */\r\n    layerMask: number;\r\n\r\n    /**\r\n     * The overall motion speed (0.01 is default update speed, faster updates = faster animation)\r\n     */\r\n    updateSpeed: number;\r\n\r\n    /**\r\n     * The amount of time the particle system is running (depends of the overall update speed).\r\n     */\r\n    targetStopDuration: number;\r\n\r\n    /**\r\n     * The texture used to render each particle. (this can be a spritesheet)\r\n     */\r\n    particleTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Blend mode use to render the particle, it can be either ParticleSystem.BLENDMODE_ONEONE, ParticleSystem.BLENDMODE_STANDARD or ParticleSystem.BLENDMODE_ADD.\r\n     */\r\n    blendMode: number;\r\n\r\n    /**\r\n     * Minimum life time of emitting particles.\r\n     */\r\n    minLifeTime: number;\r\n    /**\r\n     * Maximum life time of emitting particles.\r\n     */\r\n    maxLifeTime: number;\r\n\r\n    /**\r\n     * Minimum Size of emitting particles.\r\n     */\r\n    minSize: number;\r\n    /**\r\n     * Maximum Size of emitting particles.\r\n     */\r\n    maxSize: number;\r\n\r\n    /**\r\n     * Minimum scale of emitting particles on X axis.\r\n     */\r\n    minScaleX: number;\r\n    /**\r\n     * Maximum scale of emitting particles on X axis.\r\n     */\r\n    maxScaleX: number;\r\n\r\n    /**\r\n     * Minimum scale of emitting particles on Y axis.\r\n     */\r\n    minScaleY: number;\r\n    /**\r\n     * Maximum scale of emitting particles on Y axis.\r\n     */\r\n    maxScaleY: number;\r\n\r\n    /**\r\n     * Random color of each particle after it has been emitted, between color1 and color2 vectors.\r\n     */\r\n    color1: Color4;\r\n    /**\r\n     * Random color of each particle after it has been emitted, between color1 and color2 vectors.\r\n     */\r\n    color2: Color4;\r\n\r\n    /**\r\n     * Color the particle will have at the end of its lifetime.\r\n     */\r\n    colorDead: Color4;\r\n\r\n    /**\r\n     * The maximum number of particles to emit per frame until we reach the activeParticleCount value\r\n     */\r\n    emitRate: number;\r\n\r\n    /**\r\n     * You can use gravity if you want to give an orientation to your particles.\r\n     */\r\n    gravity: Vector3;\r\n\r\n    /**\r\n     * Minimum power of emitting particles.\r\n     */\r\n    minEmitPower: number;\r\n    /**\r\n     * Maximum power of emitting particles.\r\n     */\r\n    maxEmitPower: number;\r\n    /**\r\n     * Minimum angular speed of emitting particles (Z-axis rotation for each particle).\r\n     */\r\n    minAngularSpeed: number;\r\n    /**\r\n     * Maximum angular speed of emitting particles (Z-axis rotation for each particle).\r\n     */\r\n    maxAngularSpeed: number;\r\n    /**\r\n     * Gets or sets the minimal initial rotation in radians.\r\n     */\r\n    minInitialRotation: number;\r\n    /**\r\n     * Gets or sets the maximal initial rotation in radians.\r\n     */\r\n    maxInitialRotation: number;\r\n    /**\r\n     * The particle emitter type defines the emitter used by the particle system.\r\n     * It can be for example box, sphere, or cone...\r\n     */\r\n    particleEmitterType: Nullable<IParticleEmitterType>;\r\n    /**\r\n     * Defines the delay in milliseconds before starting the system (0 by default)\r\n     */\r\n    startDelay: number;\r\n    /**\r\n     * Gets or sets a value indicating how many cycles (or frames) must be executed before first rendering (this value has to be set before starting the system). Default is 0\r\n     */\r\n    preWarmCycles: number;\r\n    /**\r\n     * Gets or sets a value indicating the time step multiplier to use in pre-warm mode (default is 1)\r\n     */\r\n    preWarmStepOffset: number;\r\n\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled) defines the speed of the sprite loop (default is 1 meaning the animation will play once during the entire particle lifetime)\r\n     */\r\n    spriteCellChangeSpeed: number;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled) defines the first sprite cell to display\r\n     */\r\n    startSpriteCellID: number;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled) defines the last sprite cell to display\r\n     */\r\n    endSpriteCellID: number;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled), defines whether the sprite animation is looping\r\n     */\r\n    spriteCellLoop: boolean;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell width to use\r\n     */\r\n    spriteCellWidth: number;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell height to use\r\n     */\r\n    spriteCellHeight: number;\r\n    /**\r\n     * This allows the system to random pick the start cell ID between startSpriteCellID and endSpriteCellID\r\n     */\r\n    spriteRandomStartCell: boolean;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if a spritesheet is used to animate the particles texture\r\n     */\r\n    isAnimationSheetEnabled: boolean;\r\n\r\n    /** Gets or sets a Vector2 used to move the pivot (by default (0,0)) */\r\n    translationPivot: Vector2;\r\n\r\n    /**\r\n     * Gets or sets a texture used to add random noise to particle positions\r\n     */\r\n    noiseTexture: Nullable<BaseTexture>;\r\n\r\n    /** Gets or sets the strength to apply to the noise value (default is (10, 10, 10)) */\r\n    noiseStrength: Vector3;\r\n\r\n    /**\r\n     * Gets or sets the billboard mode to use when isBillboardBased = true.\r\n     * Value can be: ParticleSystem.BILLBOARDMODE_ALL, ParticleSystem.BILLBOARDMODE_Y, ParticleSystem.BILLBOARDMODE_STRETCHED\r\n     */\r\n    billboardMode: number;\r\n\r\n    /** Gets or sets a value indicating the damping to apply if the limit velocity factor is reached */\r\n    limitVelocityDamping: number;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that hosted animations (in the system.animations array) must be started when system.start() is called\r\n     */\r\n    beginAnimationOnStart: boolean;\r\n\r\n    /**\r\n     * Gets or sets the frame to start the animation from when beginAnimationOnStart is true\r\n     */\r\n    beginAnimationFrom: number;\r\n\r\n    /**\r\n     * Gets or sets the frame to end the animation on when beginAnimationOnStart is true\r\n     */\r\n    beginAnimationTo: number;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if animations must loop when beginAnimationOnStart is true\r\n     */\r\n    beginAnimationLoop: boolean;\r\n\r\n    /**\r\n     * Specifies whether the particle system will be disposed once it reaches the end of the animation.\r\n     */\r\n    disposeOnStop: boolean;\r\n\r\n    /**\r\n     * If you want to launch only a few particles at once, that can be done, as well.\r\n     */\r\n    manualEmitCount: number;\r\n\r\n    /**\r\n     * Specifies if the particles are updated in emitter local space or world space\r\n     */\r\n    isLocal: boolean;\r\n\r\n    /** Snippet ID if the particle system was created from the snippet server */\r\n    snippetId: string;\r\n\r\n    /** Gets or sets a matrix to use to compute projection */\r\n    defaultProjectionMatrix: Matrix;\r\n\r\n    /**\r\n     * Gets the maximum number of particles active at the same time.\r\n     * @returns The max number of active particles.\r\n     */\r\n    getCapacity(): number;\r\n\r\n    /**\r\n     * Gets the number of particles active at the same time.\r\n     * @returns The number of active particles.\r\n     */\r\n    getActiveCount(): number;\r\n\r\n    /**\r\n     * Gets if the system has been started. (Note: this will still be true after stop is called)\r\n     * @returns True if it has been started, otherwise false.\r\n     */\r\n    isStarted(): boolean;\r\n\r\n    /**\r\n     * Animates the particle system for this frame.\r\n     */\r\n    animate(): void;\r\n    /**\r\n     * Renders the particle system in its current state.\r\n     * @returns the current number of particles\r\n     */\r\n    render(): number;\r\n    /**\r\n     * Dispose the particle system and frees its associated resources.\r\n     * @param disposeTexture defines if the particle texture must be disposed as well (true by default)\r\n     */\r\n    dispose(disposeTexture?: boolean): void;\r\n    /**\r\n     * An event triggered when the system is disposed\r\n     */\r\n    onDisposeObservable: Observable<IParticleSystem>;\r\n    /**\r\n     * An event triggered when the system is stopped\r\n     */\r\n    onStoppedObservable: Observable<IParticleSystem>;\r\n    /**\r\n     * Clones the particle system.\r\n     * @param name The name of the cloned object\r\n     * @param newEmitter The new emitter to use\r\n     * @returns the cloned particle system\r\n     */\r\n    clone(name: string, newEmitter: any): Nullable<IParticleSystem>;\r\n    /**\r\n     * Serializes the particle system to a JSON object\r\n     * @param serializeTexture defines if the texture must be serialized as well\r\n     * @returns the JSON object\r\n     */\r\n    serialize(serializeTexture: boolean): any;\r\n    /**\r\n     * Rebuild the particle system\r\n     */\r\n    rebuild(): void;\r\n\r\n    /** Force the system to rebuild all gradients that need to be resync */\r\n    forceRefreshGradients(): void;\r\n\r\n    /**\r\n     * Starts the particle system and begins to emit\r\n     * @param delay defines the delay in milliseconds before starting the system (0 by default)\r\n     */\r\n    start(delay?: number): void;\r\n\r\n    /**\r\n     * Stops the particle system.\r\n     */\r\n    stop(): void;\r\n\r\n    /**\r\n     * Remove all active particles\r\n     */\r\n    reset(): void;\r\n\r\n    /**\r\n     * Gets a boolean indicating that the system is stopping\r\n     * @returns true if the system is currently stopping\r\n     */\r\n    isStopping(): boolean;\r\n\r\n    /**\r\n     * Is this system ready to be used/rendered\r\n     * @return true if the system is ready\r\n     */\r\n    isReady(): boolean;\r\n    /**\r\n     * Returns the string \"ParticleSystem\"\r\n     * @returns a string containing the class name\r\n     */\r\n    getClassName(): string;\r\n    /**\r\n     * Gets the custom effect used to render the particles\r\n     * @param blendMode Blend mode for which the effect should be retrieved\r\n     * @returns The effect\r\n     */\r\n    getCustomEffect(blendMode: number): Nullable<Effect>;\r\n    /**\r\n     * Sets the custom effect used to render the particles\r\n     * @param effect The effect to set\r\n     * @param blendMode Blend mode for which the effect should be set\r\n     */\r\n    setCustomEffect(effect: Nullable<Effect>, blendMode: number): void;\r\n\r\n    /**\r\n     * Fill the defines array according to the current settings of the particle system\r\n     * @param defines Array to be updated\r\n     * @param blendMode blend mode to take into account when updating the array\r\n     */\r\n    fillDefines(defines: Array<string>, blendMode: number): void;\r\n    /**\r\n     * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system\r\n     * @param uniforms Uniforms array to fill\r\n     * @param attributes Attributes array to fill\r\n     * @param samplers Samplers array to fill\r\n     */\r\n    fillUniformsAttributesAndSamplerNames(uniforms: Array<string>, attributes: Array<string>, samplers: Array<string>): void;\r\n    /**\r\n     * Observable that will be called just before the particles are drawn\r\n     */\r\n    onBeforeDrawParticlesObservable: Observable<Nullable<Effect>>;\r\n    /**\r\n     * Gets the name of the particle vertex shader\r\n     */\r\n    vertexShaderName: string;\r\n\r\n    /**\r\n     * Adds a new color gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param color1 defines the color to affect to the specified gradient\r\n     * @param color2 defines an additional color used to define a range ([color, color2]) with main color to pick the final color from\r\n     * @returns the current particle system\r\n     */\r\n    addColorGradient(gradient: number, color1: Color4, color2?: Color4): IParticleSystem;\r\n    /**\r\n     * Remove a specific color gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    removeColorGradient(gradient: number): IParticleSystem;\r\n    /**\r\n     * Adds a new size gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the size factor to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    addSizeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;\r\n    /**\r\n     * Remove a specific size gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    removeSizeGradient(gradient: number): IParticleSystem;\r\n    /**\r\n     * Gets the current list of color gradients.\r\n     * You must use addColorGradient and removeColorGradient to update this list\r\n     * @returns the list of color gradients\r\n     */\r\n    getColorGradients(): Nullable<Array<ColorGradient>>;\r\n    /**\r\n     * Gets the current list of size gradients.\r\n     * You must use addSizeGradient and removeSizeGradient to update this list\r\n     * @returns the list of size gradients\r\n     */\r\n    getSizeGradients(): Nullable<Array<FactorGradient>>;\r\n    /**\r\n     * Gets the current list of angular speed gradients.\r\n     * You must use addAngularSpeedGradient and removeAngularSpeedGradient to update this list\r\n     * @returns the list of angular speed gradients\r\n     */\r\n    getAngularSpeedGradients(): Nullable<Array<FactorGradient>>;\r\n    /**\r\n     * Adds a new angular speed gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the angular speed to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    addAngularSpeedGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;\r\n    /**\r\n     * Remove a specific angular speed gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    removeAngularSpeedGradient(gradient: number): IParticleSystem;\r\n    /**\r\n     * Gets the current list of velocity gradients.\r\n     * You must use addVelocityGradient and removeVelocityGradient to update this list\r\n     * @returns the list of velocity gradients\r\n     */\r\n    getVelocityGradients(): Nullable<Array<FactorGradient>>;\r\n    /**\r\n     * Adds a new velocity gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the velocity to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    addVelocityGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;\r\n    /**\r\n     * Remove a specific velocity gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    removeVelocityGradient(gradient: number): IParticleSystem;\r\n    /**\r\n     * Gets the current list of limit velocity gradients.\r\n     * You must use addLimitVelocityGradient and removeLimitVelocityGradient to update this list\r\n     * @returns the list of limit velocity gradients\r\n     */\r\n    getLimitVelocityGradients(): Nullable<Array<FactorGradient>>;\r\n    /**\r\n     * Adds a new limit velocity gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the limit velocity to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    addLimitVelocityGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;\r\n    /**\r\n     * Remove a specific limit velocity gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    removeLimitVelocityGradient(gradient: number): IParticleSystem;\r\n    /**\r\n     * Adds a new drag gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the drag to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    addDragGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;\r\n    /**\r\n     * Remove a specific drag gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    removeDragGradient(gradient: number): IParticleSystem;\r\n    /**\r\n     * Gets the current list of drag gradients.\r\n     * You must use addDragGradient and removeDragGradient to update this list\r\n     * @returns the list of drag gradients\r\n     */\r\n    getDragGradients(): Nullable<Array<FactorGradient>>;\r\n    /**\r\n     * Adds a new emit rate gradient (please note that this will only work if you set the targetStopDuration property)\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the emit rate to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    addEmitRateGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;\r\n    /**\r\n     * Remove a specific emit rate gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    removeEmitRateGradient(gradient: number): IParticleSystem;\r\n    /**\r\n     * Gets the current list of emit rate gradients.\r\n     * You must use addEmitRateGradient and removeEmitRateGradient to update this list\r\n     * @returns the list of emit rate gradients\r\n     */\r\n    getEmitRateGradients(): Nullable<Array<FactorGradient>>;\r\n\r\n    /**\r\n     * Adds a new start size gradient (please note that this will only work if you set the targetStopDuration property)\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the start size to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    addStartSizeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;\r\n    /**\r\n     * Remove a specific start size gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    removeStartSizeGradient(gradient: number): IParticleSystem;\r\n    /**\r\n     * Gets the current list of start size gradients.\r\n     * You must use addStartSizeGradient and removeStartSizeGradient to update this list\r\n     * @returns the list of start size gradients\r\n     */\r\n    getStartSizeGradients(): Nullable<Array<FactorGradient>>;\r\n\r\n    /**\r\n     * Adds a new life time gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the life time factor to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    addLifeTimeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;\r\n    /**\r\n     * Remove a specific life time gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    removeLifeTimeGradient(gradient: number): IParticleSystem;\r\n    /**\r\n     * Gets the current list of life time gradients.\r\n     * You must use addLifeTimeGradient and removeLifeTimeGradient to update this list\r\n     * @returns the list of life time gradients\r\n     */\r\n    getLifeTimeGradients(): Nullable<Array<FactorGradient>>;\r\n\r\n    /**\r\n     * Gets the current list of color gradients.\r\n     * You must use addColorGradient and removeColorGradient to update this list\r\n     * @returns the list of color gradients\r\n     */\r\n    getColorGradients(): Nullable<Array<ColorGradient>>;\r\n\r\n    /**\r\n     * Adds a new ramp gradient used to remap particle colors\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param color defines the color to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    addRampGradient(gradient: number, color: Color3): IParticleSystem;\r\n    /**\r\n     * Gets the current list of ramp gradients.\r\n     * You must use addRampGradient and removeRampGradient to update this list\r\n     * @returns the list of ramp gradients\r\n     */\r\n    getRampGradients(): Nullable<Array<Color3Gradient>>;\r\n\r\n    /** Gets or sets a boolean indicating that ramp gradients must be used\r\n     * @see https://doc.babylonjs.com/babylon101/particles#ramp-gradients\r\n     */\r\n    useRampGradients: boolean;\r\n\r\n    /**\r\n     * Adds a new color remap gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param min defines the color remap minimal range\r\n     * @param max defines the color remap maximal range\r\n     * @returns the current particle system\r\n     */\r\n    addColorRemapGradient(gradient: number, min: number, max: number): IParticleSystem;\r\n    /**\r\n     * Gets the current list of color remap gradients.\r\n     * You must use addColorRemapGradient and removeColorRemapGradient to update this list\r\n     * @returns the list of color remap gradients\r\n     */\r\n    getColorRemapGradients(): Nullable<Array<FactorGradient>>;\r\n\r\n    /**\r\n     * Adds a new alpha remap gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param min defines the alpha remap minimal range\r\n     * @param max defines the alpha remap maximal range\r\n     * @returns the current particle system\r\n     */\r\n    addAlphaRemapGradient(gradient: number, min: number, max: number): IParticleSystem;\r\n    /**\r\n     * Gets the current list of alpha remap gradients.\r\n     * You must use addAlphaRemapGradient and removeAlphaRemapGradient to update this list\r\n     * @returns the list of alpha remap gradients\r\n     */\r\n    getAlphaRemapGradients(): Nullable<Array<FactorGradient>>;\r\n\r\n    /**\r\n     * Creates a Point Emitter for the particle system (emits directly from the emitter position)\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the box\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the box\r\n     * @returns the emitter\r\n     */\r\n    createPointEmitter(direction1: Vector3, direction2: Vector3): PointParticleEmitter;\r\n\r\n    /**\r\n     * Creates a Hemisphere Emitter for the particle system (emits along the hemisphere radius)\r\n     * @param radius The radius of the hemisphere to emit from\r\n     * @param radiusRange The range of the hemisphere to emit from [0-1] 0 Surface Only, 1 Entire Radius\r\n     * @returns the emitter\r\n     */\r\n    createHemisphericEmitter(radius: number, radiusRange: number): HemisphericParticleEmitter;\r\n\r\n    /**\r\n     * Creates a Sphere Emitter for the particle system (emits along the sphere radius)\r\n     * @param radius The radius of the sphere to emit from\r\n     * @param radiusRange The range of the sphere to emit from [0-1] 0 Surface Only, 1 Entire Radius\r\n     * @returns the emitter\r\n     */\r\n    createSphereEmitter(radius: number, radiusRange: number): SphereParticleEmitter;\r\n\r\n    /**\r\n     * Creates a Directed Sphere Emitter for the particle system (emits between direction1 and direction2)\r\n     * @param radius The radius of the sphere to emit from\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the sphere\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the sphere\r\n     * @returns the emitter\r\n     */\r\n    createDirectedSphereEmitter(radius: number, direction1: Vector3, direction2: Vector3): SphereDirectedParticleEmitter;\r\n\r\n    /**\r\n     * Creates a Cylinder Emitter for the particle system (emits from the cylinder to the particle position)\r\n     * @param radius The radius of the emission cylinder\r\n     * @param height The height of the emission cylinder\r\n     * @param radiusRange The range of emission [0-1] 0 Surface only, 1 Entire Radius\r\n     * @param directionRandomizer How much to randomize the particle direction [0-1]\r\n     * @returns the emitter\r\n     */\r\n    createCylinderEmitter(radius: number, height: number, radiusRange: number, directionRandomizer: number): CylinderParticleEmitter;\r\n\r\n    /**\r\n     * Creates a Directed Cylinder Emitter for the particle system (emits between direction1 and direction2)\r\n     * @param radius The radius of the cylinder to emit from\r\n     * @param height The height of the emission cylinder\r\n     * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the cylinder\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the cylinder\r\n     * @returns the emitter\r\n     */\r\n    createDirectedCylinderEmitter(radius: number, height: number, radiusRange: number, direction1: Vector3, direction2: Vector3): SphereDirectedParticleEmitter;\r\n\r\n    /**\r\n     * Creates a Cone Emitter for the particle system (emits from the cone to the particle position)\r\n     * @param radius The radius of the cone to emit from\r\n     * @param angle The base angle of the cone\r\n     * @returns the emitter\r\n     */\r\n    createConeEmitter(radius: number, angle: number): ConeParticleEmitter;\r\n\r\n    /**\r\n     * Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the box\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the box\r\n     * @param minEmitBox Particles are emitted from the box between minEmitBox and maxEmitBox\r\n     * @param maxEmitBox  Particles are emitted from the box between minEmitBox and maxEmitBox\r\n     * @returns the emitter\r\n     */\r\n    createBoxEmitter(direction1: Vector3, direction2: Vector3, minEmitBox: Vector3, maxEmitBox: Vector3): BoxParticleEmitter;\r\n\r\n    /**\r\n     * Get hosting scene\r\n     * @returns the scene\r\n     */\r\n    getScene(): Nullable<Scene>;\r\n}\r\n"]}