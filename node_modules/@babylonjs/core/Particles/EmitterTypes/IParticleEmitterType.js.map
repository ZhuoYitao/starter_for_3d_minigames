{"version":3,"file":"IParticleEmitterType.js","sourceRoot":"","sources":["../../../../../../lts/core/generated/Particles/EmitterTypes/IParticleEmitterType.ts"],"names":[],"mappings":"","sourcesContent":["import type { Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport type { Particle } from \"../../Particles/particle\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n\r\ndeclare type Scene = import(\"../../scene\").Scene;\r\n\r\n/**\r\n * Particle emitter represents a volume emitting particles.\r\n * This is the responsibility of the implementation to define the volume shape like cone/sphere/box.\r\n */\r\nexport interface IParticleEmitterType {\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     * @param inverseWorldMatrix defines the inverted world matrix to use if isLocal is false\r\n     */\r\n    startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean, inverseWorldMatrix: Matrix): void;\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void;\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    clone(): IParticleEmitterType;\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void;\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    buildUniformLayout(ubo: UniformBuffer): void;\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns the effect defines string\r\n     */\r\n    getEffectDefines(): string;\r\n\r\n    /**\r\n     * Returns a string representing the class name\r\n     * @returns a string containing the class name\r\n     */\r\n    getClassName(): string;\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    serialize(): any;\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     * @param scene defines the hosting scene\r\n     */\r\n    parse(serializationObject: any, scene: Nullable<Scene>): void;\r\n}\r\n"]}