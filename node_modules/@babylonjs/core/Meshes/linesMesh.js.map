{"version":3,"file":"linesMesh.js","sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/linesMesh.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport type { Node } from \"../node\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { InstancedMesh } from \"../Meshes/instancedMesh\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\n\r\nimport \"../Shaders/color.fragment\";\r\nimport \"../Shaders/color.vertex\";\r\n\r\nMesh._LinesMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return LinesMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Line mesh\r\n * @see https://doc.babylonjs.com/babylon101/parametric_shapes\r\n */\r\nexport class LinesMesh extends Mesh {\r\n    /**\r\n     * Color of the line (Default: White)\r\n     */\r\n    public color = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * Alpha of the line (Default: 1)\r\n     */\r\n    public alpha = 1;\r\n\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Default value is 0.1\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    private _lineMaterial: Material;\r\n\r\n    private _isShaderMaterial(shader: Material): shader is ShaderMaterial {\r\n        return shader.getClassName() === \"ShaderMaterial\";\r\n    }\r\n\r\n    private _color4: Color4;\r\n\r\n    /**\r\n     * Creates a new LinesMesh\r\n     * @param name defines the name\r\n     * @param scene defines the hosting scene\r\n     * @param parent defines the parent mesh if any\r\n     * @param source defines the optional source LinesMesh used to clone data from\r\n     * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\r\n     * When false, achieved by calling a clone(), also passing False.\r\n     * This will make creation of children, recursive.\r\n     * @param useVertexColor defines if this LinesMesh supports vertex color\r\n     * @param useVertexAlpha defines if this LinesMesh supports vertex alpha\r\n     * @param material material to use to draw the line. If not provided, will create a new one\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Nullable<Scene> = null,\r\n        parent: Nullable<Node> = null,\r\n        source: Nullable<LinesMesh> = null,\r\n        doNotCloneChildren?: boolean,\r\n        /**\r\n         * If vertex color should be applied to the mesh\r\n         */\r\n        public readonly useVertexColor?: boolean,\r\n        /**\r\n         * If vertex alpha should be applied to the mesh\r\n         */\r\n        public readonly useVertexAlpha?: boolean,\r\n        material?: Material\r\n    ) {\r\n        super(name, scene, parent, source, doNotCloneChildren);\r\n\r\n        if (source) {\r\n            this.color = source.color.clone();\r\n            this.alpha = source.alpha;\r\n            this.useVertexColor = source.useVertexColor;\r\n            this.useVertexAlpha = source.useVertexAlpha;\r\n        }\r\n\r\n        this.intersectionThreshold = 0.1;\r\n\r\n        const defines: string[] = [];\r\n        const options = {\r\n            attributes: [VertexBuffer.PositionKind],\r\n            uniforms: [\"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"world\", \"viewProjection\"],\r\n            needAlphaBlending: true,\r\n            defines: defines,\r\n            useClipPlane: null,\r\n        };\r\n\r\n        if (useVertexAlpha === false) {\r\n            options.needAlphaBlending = false;\r\n        }\r\n\r\n        if (!useVertexColor) {\r\n            options.uniforms.push(\"color\");\r\n            this._color4 = new Color4();\r\n        } else {\r\n            options.defines.push(\"#define VERTEXCOLOR\");\r\n            options.attributes.push(VertexBuffer.ColorKind);\r\n        }\r\n\r\n        if (material) {\r\n            this.material = material;\r\n        } else {\r\n            this.material = new ShaderMaterial(\"colorShader\", this.getScene(), \"color\", options, false);\r\n        }\r\n    }\r\n\r\n    public isReady() {\r\n        if (!this._lineMaterial.isReady(this, !!this._userInstancedBuffersStorage)) {\r\n            return false;\r\n        }\r\n\r\n        return super.isReady();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"LineMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"LinesMesh\";\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public get material(): Material {\r\n        return this._lineMaterial;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public set material(value: Material) {\r\n        this._lineMaterial = value;\r\n        this._lineMaterial.fillMode = Material.LineListDrawMode;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public get checkCollisions(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public set checkCollisions(value: boolean) {\r\n        // Just ignore it\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _bind(): Mesh {\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n        const colorEffect = this._lineMaterial.getEffect();\r\n\r\n        // VBOs\r\n        const indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();\r\n        if (!this._userInstancedBuffersStorage) {\r\n            this._geometry._bind(colorEffect, indexToBind);\r\n        } else {\r\n            this._geometry._bind(colorEffect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);\r\n        }\r\n\r\n        // Color\r\n        if (!this.useVertexColor && this._isShaderMaterial(this._lineMaterial)) {\r\n            const { r, g, b } = this.color;\r\n            this._color4.set(r, g, b, this.alpha);\r\n            this._lineMaterial.setColor4(\"color\", this._color4);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param subMesh\r\n     * @param fillMode\r\n     * @param instancesCount\r\n     * @hidden\r\n     */\r\n    public _draw(subMesh: SubMesh, fillMode: number, instancesCount?: number): Mesh {\r\n        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {\r\n            return this;\r\n        }\r\n\r\n        const engine = this.getScene().getEngine();\r\n\r\n        // Draw order\r\n\r\n        if (this._unIndexed) {\r\n            engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);\r\n        } else {\r\n            engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the line mesh\r\n     * @param doNotRecurse If children should be disposed\r\n     */\r\n    public dispose(doNotRecurse?: boolean): void {\r\n        this._lineMaterial.dispose(false, false, true);\r\n        super.dispose(doNotRecurse);\r\n    }\r\n\r\n    /**\r\n     * Returns a new LineMesh object cloned from the current one.\r\n     * @param name\r\n     * @param newParent\r\n     * @param doNotCloneChildren\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null, doNotCloneChildren?: boolean): LinesMesh {\r\n        return new LinesMesh(name, this.getScene(), newParent, this, doNotCloneChildren);\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedLinesMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/divingDeeper/mesh/copies/instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedLinesMesh\r\n     */\r\n    public createInstance(name: string): InstancedLinesMesh {\r\n        const instance = new InstancedLinesMesh(name, this);\r\n\r\n        if (this.instancedBuffers) {\r\n            instance.instancedBuffers = {};\r\n\r\n            for (const key in this.instancedBuffers) {\r\n                instance.instancedBuffers[key] = this.instancedBuffers[key];\r\n            }\r\n        }\r\n\r\n        return instance;\r\n    }\r\n\r\n    /**\r\n     * Serializes this ground mesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.color = this.color.asArray();\r\n        serializationObject.alpha = this.alpha;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized ground mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the ground mesh in\r\n     * @returns the created ground mesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): LinesMesh {\r\n        const result = new LinesMesh(parsedMesh.name, scene);\r\n\r\n        result.color = Color3.FromArray(parsedMesh.color);\r\n        result.alpha = parsedMesh.alpha;\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates an instance based on a source LinesMesh\r\n */\r\nexport class InstancedLinesMesh extends InstancedMesh {\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Initialized with the intersectionThreshold value of the source LinesMesh\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    constructor(name: string, source: LinesMesh) {\r\n        super(name, source);\r\n        this.intersectionThreshold = source.intersectionThreshold;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"InstancedLinesMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"InstancedLinesMesh\";\r\n    }\r\n}\r\n"]}