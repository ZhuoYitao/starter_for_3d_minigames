{"version":3,"file":"mesh.vertexData.js","sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/mesh.vertexData.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Nullable, FloatArray, IndicesArray, DeepImmutable } from \"../types\";\r\nimport type { Matrix, Vector2 } from \"../Maths/math.vector\";\r\nimport { Vector3, Vector4, TmpVectors } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { Color3 } from \"../Maths/math.color\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { nativeOverride } from \"../Misc/decorators\";\r\nimport type { Coroutine } from \"../Misc/coroutine\";\r\nimport { makeSyncFunction, runCoroutineSync } from \"../Misc/coroutine\";\r\nimport type { ICreateCapsuleOptions } from \"./Builders/capsuleBuilder\";\r\nimport { RuntimeError, ErrorCodes } from \"../Misc/error\";\r\n\r\ndeclare type Geometry = import(\"../Meshes/geometry\").Geometry;\r\ndeclare type Mesh = import(\"../Meshes/mesh\").Mesh;\r\n\r\ndeclare type PolyhedronData = import(\"./geodesicMesh\").PolyhedronData;\r\n\r\n/**\r\n * Define an interface for all classes that will get and set the data on vertices\r\n */\r\nexport interface IGetSetVerticesData {\r\n    /**\r\n     * Gets a boolean indicating if specific vertex data is present\r\n     * @param kind defines the vertex data kind to use\r\n     * @returns true is data kind is present\r\n     */\r\n    isVerticesDataPresent(kind: string): boolean;\r\n    /**\r\n     * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns a float array containing vertex data\r\n     */\r\n    getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray>;\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns the indices array or an empty array if the mesh has no geometry\r\n     */\r\n    getIndices(copyWhenShared?: boolean, forceCopy?: boolean): Nullable<IndicesArray>;\r\n    /**\r\n     * Set specific vertex data\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the vertex data to use\r\n     * @param updatable defines if the vertex must be flagged as updatable (false as default)\r\n     * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified\r\n     */\r\n    setVerticesData(kind: string, data: FloatArray, updatable: boolean): void;\r\n    /**\r\n     * Update a specific associated vertex buffer\r\n     * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @param data defines the data source\r\n     * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for \"position\" kind\r\n     * @param makeItUnique defines if the geometry associated with the mesh must be cloned to make the change only for this mesh (and not all meshes associated with the same geometry)\r\n     */\r\n    updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): void;\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the indices to store in the index buffer\r\n     * @param totalVertices defines the total number of vertices (could be null)\r\n     * @param updatable defines if the index buffer must be flagged as updatable (false by default)\r\n     */\r\n    setIndices(indices: IndicesArray, totalVertices: Nullable<number>, updatable?: boolean): void;\r\n}\r\n\r\n/**\r\n * This class contains the various kinds of data on every vertex of a mesh used in determining its shape and appearance\r\n */\r\nexport class VertexData {\r\n    /**\r\n     * Mesh side orientation : usually the external or front surface\r\n     */\r\n    public static readonly FRONTSIDE = 0;\r\n    /**\r\n     * Mesh side orientation : usually the internal or back surface\r\n     */\r\n    public static readonly BACKSIDE = 1;\r\n    /**\r\n     * Mesh side orientation : both internal and external or front and back surfaces\r\n     */\r\n    public static readonly DOUBLESIDE = 2;\r\n    /**\r\n     * Mesh side orientation : by default, `FRONTSIDE`\r\n     */\r\n    public static readonly DEFAULTSIDE = 0;\r\n\r\n    /**\r\n     * An array of the x, y, z position of each vertex  [...., x, y, z, .....]\r\n     */\r\n    public positions: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the x, y, z normal vector of each vertex  [...., x, y, z, .....]\r\n     */\r\n    public normals: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the x, y, z tangent vector of each vertex  [...., x, y, z, .....]\r\n     */\r\n    public tangents: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A second array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs2: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A third array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs3: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A fourth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs4: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A fifth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs5: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A sixth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs6: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the r, g, b, a, color of each vertex  [...., r, g, b, a, .....]\r\n     */\r\n    public colors: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array containing the list of indices to the array of matrices produced by bones, each vertex have up to 4 indices (8 if the matricesIndicesExtra is set).\r\n     */\r\n    public matricesIndices: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array containing the list of weights defining the weight of each indexed matrix in the final computation\r\n     */\r\n    public matricesWeights: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array extending the number of possible indices\r\n     */\r\n    public matricesIndicesExtra: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array extending the number of possible weights when the number of indices is extended\r\n     */\r\n    public matricesWeightsExtra: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of i, j, k the three vertex indices required for each triangular facet  [...., i, j, k .....]\r\n     */\r\n    public indices: Nullable<IndicesArray>;\r\n\r\n    /**\r\n     * Uses the passed data array to set the set the values for the specified kind of data\r\n     * @param data a linear array of floating numbers\r\n     * @param kind the type of data that is being set, eg positions, colors etc\r\n     */\r\n    public set(data: FloatArray, kind: string) {\r\n        if (!data.length) {\r\n            Logger.Warn(`Setting vertex data kind '${kind}' with an empty array`);\r\n        }\r\n\r\n        switch (kind) {\r\n            case VertexBuffer.PositionKind:\r\n                this.positions = data;\r\n                break;\r\n            case VertexBuffer.NormalKind:\r\n                this.normals = data;\r\n                break;\r\n            case VertexBuffer.TangentKind:\r\n                this.tangents = data;\r\n                break;\r\n            case VertexBuffer.UVKind:\r\n                this.uvs = data;\r\n                break;\r\n            case VertexBuffer.UV2Kind:\r\n                this.uvs2 = data;\r\n                break;\r\n            case VertexBuffer.UV3Kind:\r\n                this.uvs3 = data;\r\n                break;\r\n            case VertexBuffer.UV4Kind:\r\n                this.uvs4 = data;\r\n                break;\r\n            case VertexBuffer.UV5Kind:\r\n                this.uvs5 = data;\r\n                break;\r\n            case VertexBuffer.UV6Kind:\r\n                this.uvs6 = data;\r\n                break;\r\n            case VertexBuffer.ColorKind:\r\n                this.colors = data;\r\n                break;\r\n            case VertexBuffer.MatricesIndicesKind:\r\n                this.matricesIndices = data;\r\n                break;\r\n            case VertexBuffer.MatricesWeightsKind:\r\n                this.matricesWeights = data;\r\n                break;\r\n            case VertexBuffer.MatricesIndicesExtraKind:\r\n                this.matricesIndicesExtra = data;\r\n                break;\r\n            case VertexBuffer.MatricesWeightsExtraKind:\r\n                this.matricesWeightsExtra = data;\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Associates the vertexData to the passed Mesh.\r\n     * Sets it as updatable or not (default `false`)\r\n     * @param mesh the mesh the vertexData is applied to\r\n     * @param updatable when used and having the value true allows new data to update the vertexData\r\n     * @returns the VertexData\r\n     */\r\n    public applyToMesh(mesh: Mesh, updatable?: boolean): VertexData {\r\n        this._applyTo(mesh, updatable, false);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Associates the vertexData to the passed Geometry.\r\n     * Sets it as updatable or not (default `false`)\r\n     * @param geometry the geometry the vertexData is applied to\r\n     * @param updatable when used and having the value true allows new data to update the vertexData\r\n     * @returns VertexData\r\n     */\r\n    public applyToGeometry(geometry: Geometry, updatable?: boolean): VertexData {\r\n        this._applyTo(geometry, updatable, false);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the associated mesh\r\n     * @param mesh the mesh to be updated\r\n     * @returns VertexData\r\n     */\r\n    public updateMesh(mesh: Mesh): VertexData {\r\n        this._update(mesh);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the associated geometry\r\n     * @param geometry the geometry to be updated\r\n     * @returns VertexData.\r\n     */\r\n    public updateGeometry(geometry: Geometry): VertexData {\r\n        this._update(geometry);\r\n        return this;\r\n    }\r\n\r\n    private readonly _applyTo = makeSyncFunction(this._applyToCoroutine.bind(this));\r\n\r\n    /**\r\n     * @param meshOrGeometry\r\n     * @param updatable\r\n     * @param isAsync\r\n     * @hidden\r\n     */\r\n    public *_applyToCoroutine(meshOrGeometry: IGetSetVerticesData, updatable: boolean = false, isAsync: boolean): Coroutine<VertexData> {\r\n        if (this.positions) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.PositionKind, this.positions, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.normals) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.NormalKind, this.normals, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.tangents) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.TangentKind, this.tangents, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UVKind, this.uvs, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV2Kind, this.uvs2, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV3Kind, this.uvs3, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV4Kind, this.uvs4, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV5Kind, this.uvs5, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV6Kind, this.uvs6, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.colors) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.ColorKind, this.colors, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.indices) {\r\n            meshOrGeometry.setIndices(this.indices, null, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        } else {\r\n            meshOrGeometry.setIndices([], null);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private _update(meshOrGeometry: IGetSetVerticesData, updateExtends?: boolean, makeItUnique?: boolean): VertexData {\r\n        if (this.positions) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.PositionKind, this.positions, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.normals) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.NormalKind, this.normals, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.tangents) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.TangentKind, this.tangents, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UVKind, this.uvs, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV2Kind, this.uvs2, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV3Kind, this.uvs3, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV4Kind, this.uvs4, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV5Kind, this.uvs5, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV6Kind, this.uvs6, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.colors) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.ColorKind, this.colors, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.indices) {\r\n            meshOrGeometry.setIndices(this.indices, null);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    @nativeOverride.filter((...[coordinates]: Parameters<typeof VertexData._TransformVector3Coordinates>) => !Array.isArray(coordinates))\r\n    private static _TransformVector3Coordinates(coordinates: FloatArray, transformation: DeepImmutable<Matrix>, offset = 0, length = coordinates.length) {\r\n        const coordinate = TmpVectors.Vector3[0];\r\n        const transformedCoordinate = TmpVectors.Vector3[1];\r\n        for (let index = offset; index < offset + length; index += 3) {\r\n            Vector3.FromArrayToRef(coordinates, index, coordinate);\r\n            Vector3.TransformCoordinatesToRef(coordinate, transformation, transformedCoordinate);\r\n            coordinates[index] = transformedCoordinate.x;\r\n            coordinates[index + 1] = transformedCoordinate.y;\r\n            coordinates[index + 2] = transformedCoordinate.z;\r\n        }\r\n    }\r\n\r\n    @nativeOverride.filter((...[normals]: Parameters<typeof VertexData._TransformVector3Normals>) => !Array.isArray(normals))\r\n    private static _TransformVector3Normals(normals: FloatArray, transformation: DeepImmutable<Matrix>, offset = 0, length = normals.length) {\r\n        const normal = TmpVectors.Vector3[0];\r\n        const transformedNormal = TmpVectors.Vector3[1];\r\n        for (let index = offset; index < offset + length; index += 3) {\r\n            Vector3.FromArrayToRef(normals, index, normal);\r\n            Vector3.TransformNormalToRef(normal, transformation, transformedNormal);\r\n            normals[index] = transformedNormal.x;\r\n            normals[index + 1] = transformedNormal.y;\r\n            normals[index + 2] = transformedNormal.z;\r\n        }\r\n    }\r\n\r\n    @nativeOverride.filter((...[normals]: Parameters<typeof VertexData._TransformVector4Normals>) => !Array.isArray(normals))\r\n    private static _TransformVector4Normals(normals: FloatArray, transformation: DeepImmutable<Matrix>, offset = 0, length = normals.length) {\r\n        const normal = TmpVectors.Vector4[0];\r\n        const transformedNormal = TmpVectors.Vector4[1];\r\n        for (let index = offset; index < offset + length; index += 4) {\r\n            Vector4.FromArrayToRef(normals, index, normal);\r\n            Vector4.TransformNormalToRef(normal, transformation, transformedNormal);\r\n            normals[index] = transformedNormal.x;\r\n            normals[index + 1] = transformedNormal.y;\r\n            normals[index + 2] = transformedNormal.z;\r\n            normals[index + 3] = transformedNormal.w;\r\n        }\r\n    }\r\n\r\n    @nativeOverride.filter((...[indices]: Parameters<typeof VertexData._FlipFaces>) => !Array.isArray(indices))\r\n    private static _FlipFaces(indices: IndicesArray, offset = 0, length = indices.length) {\r\n        for (let index = offset; index < offset + length; index += 3) {\r\n            const tmp = indices[index + 1];\r\n            indices[index + 1] = indices[index + 2];\r\n            indices[index + 2] = tmp;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transforms each position and each normal of the vertexData according to the passed Matrix\r\n     * @param matrix the transforming matrix\r\n     * @returns the VertexData\r\n     */\r\n    public transform(matrix: Matrix): VertexData {\r\n        const flip = matrix.determinant() < 0;\r\n        if (this.positions) {\r\n            VertexData._TransformVector3Coordinates(this.positions, matrix);\r\n        }\r\n\r\n        if (this.normals) {\r\n            VertexData._TransformVector3Normals(this.normals, matrix);\r\n        }\r\n\r\n        if (this.tangents) {\r\n            VertexData._TransformVector4Normals(this.tangents, matrix);\r\n        }\r\n\r\n        if (flip && this.indices) {\r\n            VertexData._FlipFaces(this.indices);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Merges the passed VertexData into the current one\r\n     * @param others the VertexData to be merged into the current one\r\n     * @param use32BitsIndices defines a boolean indicating if indices must be store in a 32 bits array\r\n     * @param forceCloneIndices defines a boolean indicating if indices are forced to be cloned\r\n     * @returns the modified VertexData\r\n     */\r\n    public merge(others: VertexData | VertexData[], use32BitsIndices = false, forceCloneIndices = false) {\r\n        const vertexDatas: [vertexData: VertexData, transform?: Matrix][] = Array.isArray(others) ? others.map((other) => [other, undefined]) : [[others, undefined]];\r\n        return runCoroutineSync(this._mergeCoroutine(undefined, vertexDatas, use32BitsIndices, false, forceCloneIndices));\r\n    }\r\n\r\n    /**\r\n     * @param transform\r\n     * @param vertexDatas\r\n     * @param use32BitsIndices\r\n     * @param isAsync\r\n     * @param forceCloneIndices\r\n     * @hidden\r\n     */\r\n    public *_mergeCoroutine(\r\n        transform: Matrix | undefined,\r\n        vertexDatas: (readonly [vertexData: VertexData, transform?: Matrix])[],\r\n        use32BitsIndices = false,\r\n        isAsync: boolean,\r\n        forceCloneIndices: boolean\r\n    ): Coroutine<VertexData> {\r\n        this._validate();\r\n\r\n        const others = vertexDatas.map((vertexData) => vertexData[0]);\r\n\r\n        for (const other of others) {\r\n            other._validate();\r\n\r\n            if (\r\n                !this.normals !== !other.normals ||\r\n                !this.tangents !== !other.tangents ||\r\n                !this.uvs !== !other.uvs ||\r\n                !this.uvs2 !== !other.uvs2 ||\r\n                !this.uvs3 !== !other.uvs3 ||\r\n                !this.uvs4 !== !other.uvs4 ||\r\n                !this.uvs5 !== !other.uvs5 ||\r\n                !this.uvs6 !== !other.uvs6 ||\r\n                !this.colors !== !other.colors ||\r\n                !this.matricesIndices !== !other.matricesIndices ||\r\n                !this.matricesWeights !== !other.matricesWeights ||\r\n                !this.matricesIndicesExtra !== !other.matricesIndicesExtra ||\r\n                !this.matricesWeightsExtra !== !other.matricesWeightsExtra\r\n            ) {\r\n                throw new Error(\"Cannot merge vertex data that do not have the same set of attributes\");\r\n            }\r\n        }\r\n\r\n        const totalIndices = others.reduce((indexSum, vertexData) => indexSum + (vertexData.indices?.length ?? 0), this.indices?.length ?? 0);\r\n        const sliceIndices = forceCloneIndices || others.some((vertexData) => vertexData.indices === this.indices);\r\n        let indices = sliceIndices ? this.indices?.slice() : this.indices;\r\n        if (totalIndices > 0) {\r\n            let indicesOffset = indices?.length ?? 0;\r\n\r\n            if (!indices) {\r\n                indices = new Array<number>(totalIndices);\r\n            }\r\n\r\n            if (indices.length !== totalIndices) {\r\n                if (Array.isArray(indices)) {\r\n                    indices.length = totalIndices;\r\n                } else {\r\n                    const temp = use32BitsIndices || indices instanceof Uint32Array ? new Uint32Array(totalIndices) : new Uint16Array(totalIndices);\r\n                    temp.set(indices);\r\n                    indices = temp;\r\n                }\r\n\r\n                if (transform && transform.determinant() < 0) {\r\n                    VertexData._FlipFaces(indices, 0, indicesOffset);\r\n                }\r\n            }\r\n\r\n            let positionsOffset = this.positions ? this.positions.length / 3 : 0;\r\n            for (const [other, transform] of vertexDatas) {\r\n                if (other.indices) {\r\n                    for (let index = 0; index < other.indices.length; index++) {\r\n                        indices[indicesOffset + index] = other.indices[index] + positionsOffset;\r\n                    }\r\n\r\n                    if (transform && transform.determinant() < 0) {\r\n                        VertexData._FlipFaces(indices, indicesOffset, other.indices.length);\r\n                    }\r\n\r\n                    // The call to _validate already checked for positions\r\n                    positionsOffset += other.positions!.length / 3;\r\n                    indicesOffset += other.indices.length;\r\n\r\n                    if (isAsync) {\r\n                        yield;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.indices = indices!;\r\n\r\n        this.positions = VertexData._MergeElement(\r\n            VertexBuffer.PositionKind,\r\n            this.positions,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].positions, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.normals = VertexData._MergeElement(\r\n            VertexBuffer.NormalKind,\r\n            this.normals,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].normals, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.tangents = VertexData._MergeElement(\r\n            VertexBuffer.TangentKind,\r\n            this.tangents,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].tangents, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.uvs = VertexData._MergeElement(\r\n            VertexBuffer.UVKind,\r\n            this.uvs,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].uvs, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.uvs2 = VertexData._MergeElement(\r\n            VertexBuffer.UV2Kind,\r\n            this.uvs2,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].uvs2, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.uvs3 = VertexData._MergeElement(\r\n            VertexBuffer.UV3Kind,\r\n            this.uvs3,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].uvs3, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.uvs4 = VertexData._MergeElement(\r\n            VertexBuffer.UV4Kind,\r\n            this.uvs4,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].uvs4, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.uvs5 = VertexData._MergeElement(\r\n            VertexBuffer.UV5Kind,\r\n            this.uvs5,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].uvs5, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.uvs6 = VertexData._MergeElement(\r\n            VertexBuffer.UV6Kind,\r\n            this.uvs6,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].uvs6, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.colors = VertexData._MergeElement(\r\n            VertexBuffer.ColorKind,\r\n            this.colors,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].colors, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.matricesIndices = VertexData._MergeElement(\r\n            VertexBuffer.MatricesIndicesKind,\r\n            this.matricesIndices,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].matricesIndices, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.matricesWeights = VertexData._MergeElement(\r\n            VertexBuffer.MatricesWeightsKind,\r\n            this.matricesWeights,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].matricesWeights, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.matricesIndicesExtra = VertexData._MergeElement(\r\n            VertexBuffer.MatricesIndicesExtraKind,\r\n            this.matricesIndicesExtra,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].matricesIndicesExtra, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.matricesWeightsExtra = VertexData._MergeElement(\r\n            VertexBuffer.MatricesWeightsExtraKind,\r\n            this.matricesWeightsExtra,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].matricesWeightsExtra, other[1]])\r\n        );\r\n\r\n        return this;\r\n    }\r\n\r\n    private static _MergeElement(\r\n        kind: string,\r\n        source: Nullable<FloatArray>,\r\n        transform: Matrix | undefined,\r\n        others: readonly (readonly [element: Nullable<FloatArray>, transform?: Matrix])[]\r\n    ): Nullable<FloatArray> {\r\n        const nonNullOthers = others.filter((other): other is [element: FloatArray, transform?: Matrix] => other[0] !== null && other[0] !== undefined);\r\n\r\n        // If there is no source to copy and no other non-null sources then skip this element.\r\n        if (!source && nonNullOthers.length == 0) {\r\n            return source;\r\n        }\r\n\r\n        if (!source) {\r\n            return this._MergeElement(kind, nonNullOthers[0][0], nonNullOthers[0][1], nonNullOthers.slice(1));\r\n        }\r\n\r\n        const len = nonNullOthers.reduce((sumLen, elements) => sumLen + elements[0].length, source.length);\r\n\r\n        const transformRange =\r\n            kind === VertexBuffer.PositionKind\r\n                ? VertexData._TransformVector3Coordinates\r\n                : kind === VertexBuffer.NormalKind\r\n                ? VertexData._TransformVector3Normals\r\n                : kind === VertexBuffer.TangentKind\r\n                ? VertexData._TransformVector4Normals\r\n                : () => {};\r\n\r\n        if (source instanceof Float32Array) {\r\n            // use non-loop method when the source is Float32Array\r\n            const ret32 = new Float32Array(len);\r\n            ret32.set(source);\r\n            transform && transformRange(ret32, transform, 0, source.length);\r\n\r\n            let offset = source.length;\r\n            for (const [vertexData, transform] of nonNullOthers) {\r\n                ret32.set(vertexData, offset);\r\n                transform && transformRange(ret32, transform, offset, vertexData.length);\r\n                offset += vertexData.length;\r\n            }\r\n            return ret32;\r\n        } else {\r\n            // don't use concat as it is super slow, just loop for other cases\r\n            const ret = new Array<number>(len);\r\n            for (let i = 0; i < source.length; i++) {\r\n                ret[i] = source[i];\r\n            }\r\n            transform && transformRange(ret, transform, 0, source.length);\r\n\r\n            let offset = source.length;\r\n            for (const [vertexData, transform] of nonNullOthers) {\r\n                for (let i = 0; i < vertexData.length; i++) {\r\n                    ret[offset + i] = vertexData[i];\r\n                }\r\n                transform && transformRange(ret, transform, offset, vertexData.length);\r\n                offset += vertexData.length;\r\n            }\r\n            return ret;\r\n        }\r\n    }\r\n\r\n    private _validate(): void {\r\n        if (!this.positions) {\r\n            throw new RuntimeError(\"Positions are required\", ErrorCodes.MeshInvalidPositionsError);\r\n        }\r\n\r\n        const getElementCount = (kind: string, values: FloatArray) => {\r\n            const stride = VertexBuffer.DeduceStride(kind);\r\n            if (values.length % stride !== 0) {\r\n                throw new Error(\"The \" + kind + \"s array count must be a multiple of \" + stride);\r\n            }\r\n\r\n            return values.length / stride;\r\n        };\r\n\r\n        const positionsElementCount = getElementCount(VertexBuffer.PositionKind, this.positions);\r\n\r\n        const validateElementCount = (kind: string, values: FloatArray) => {\r\n            const elementCount = getElementCount(kind, values);\r\n            if (elementCount !== positionsElementCount) {\r\n                throw new Error(\"The \" + kind + \"s element count (\" + elementCount + \") does not match the positions count (\" + positionsElementCount + \")\");\r\n            }\r\n        };\r\n\r\n        if (this.normals) {\r\n            validateElementCount(VertexBuffer.NormalKind, this.normals);\r\n        }\r\n        if (this.tangents) {\r\n            validateElementCount(VertexBuffer.TangentKind, this.tangents);\r\n        }\r\n        if (this.uvs) {\r\n            validateElementCount(VertexBuffer.UVKind, this.uvs);\r\n        }\r\n        if (this.uvs2) {\r\n            validateElementCount(VertexBuffer.UV2Kind, this.uvs2);\r\n        }\r\n        if (this.uvs3) {\r\n            validateElementCount(VertexBuffer.UV3Kind, this.uvs3);\r\n        }\r\n        if (this.uvs4) {\r\n            validateElementCount(VertexBuffer.UV4Kind, this.uvs4);\r\n        }\r\n        if (this.uvs5) {\r\n            validateElementCount(VertexBuffer.UV5Kind, this.uvs5);\r\n        }\r\n        if (this.uvs6) {\r\n            validateElementCount(VertexBuffer.UV6Kind, this.uvs6);\r\n        }\r\n        if (this.colors) {\r\n            validateElementCount(VertexBuffer.ColorKind, this.colors);\r\n        }\r\n        if (this.matricesIndices) {\r\n            validateElementCount(VertexBuffer.MatricesIndicesKind, this.matricesIndices);\r\n        }\r\n        if (this.matricesWeights) {\r\n            validateElementCount(VertexBuffer.MatricesWeightsKind, this.matricesWeights);\r\n        }\r\n        if (this.matricesIndicesExtra) {\r\n            validateElementCount(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra);\r\n        }\r\n        if (this.matricesWeightsExtra) {\r\n            validateElementCount(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes the VertexData\r\n     * @returns a serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        if (this.positions) {\r\n            serializationObject.positions = this.positions;\r\n        }\r\n\r\n        if (this.normals) {\r\n            serializationObject.normals = this.normals;\r\n        }\r\n\r\n        if (this.tangents) {\r\n            serializationObject.tangents = this.tangents;\r\n        }\r\n\r\n        if (this.uvs) {\r\n            serializationObject.uvs = this.uvs;\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            serializationObject.uvs2 = this.uvs2;\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            serializationObject.uvs3 = this.uvs3;\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            serializationObject.uvs4 = this.uvs4;\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            serializationObject.uvs5 = this.uvs5;\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            serializationObject.uvs6 = this.uvs6;\r\n        }\r\n\r\n        if (this.colors) {\r\n            serializationObject.colors = this.colors;\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            serializationObject.matricesIndices = this.matricesIndices;\r\n            serializationObject.matricesIndices._isExpanded = true;\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            serializationObject.matricesWeights = this.matricesWeights;\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            serializationObject.matricesIndicesExtra = this.matricesIndicesExtra;\r\n            serializationObject.matricesIndicesExtra._isExpanded = true;\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            serializationObject.matricesWeightsExtra = this.matricesWeightsExtra;\r\n        }\r\n\r\n        serializationObject.indices = this.indices;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Extracts the vertexData from a mesh\r\n     * @param mesh the mesh from which to extract the VertexData\r\n     * @param copyWhenShared defines if the VertexData must be cloned when shared between multiple meshes, optional, default false\r\n     * @param forceCopy indicating that the VertexData must be cloned, optional, default false\r\n     * @returns the object VertexData associated to the passed mesh\r\n     */\r\n    public static ExtractFromMesh(mesh: Mesh, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        return VertexData._ExtractFrom(mesh, copyWhenShared, forceCopy);\r\n    }\r\n\r\n    /**\r\n     * Extracts the vertexData from the geometry\r\n     * @param geometry the geometry from which to extract the VertexData\r\n     * @param copyWhenShared defines if the VertexData must be cloned when the geometry is shared between multiple meshes, optional, default false\r\n     * @param forceCopy indicating that the VertexData must be cloned, optional, default false\r\n     * @returns the object VertexData associated to the passed mesh\r\n     */\r\n    public static ExtractFromGeometry(geometry: Geometry, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        return VertexData._ExtractFrom(geometry, copyWhenShared, forceCopy);\r\n    }\r\n\r\n    private static _ExtractFrom(meshOrGeometry: IGetSetVerticesData, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        const result = new VertexData();\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.PositionKind)) {\r\n            result.positions = meshOrGeometry.getVerticesData(VertexBuffer.PositionKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            result.normals = meshOrGeometry.getVerticesData(VertexBuffer.NormalKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            result.tangents = meshOrGeometry.getVerticesData(VertexBuffer.TangentKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n            result.uvs = meshOrGeometry.getVerticesData(VertexBuffer.UVKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n            result.uvs2 = meshOrGeometry.getVerticesData(VertexBuffer.UV2Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\r\n            result.uvs3 = meshOrGeometry.getVerticesData(VertexBuffer.UV3Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\r\n            result.uvs4 = meshOrGeometry.getVerticesData(VertexBuffer.UV4Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\r\n            result.uvs5 = meshOrGeometry.getVerticesData(VertexBuffer.UV5Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\r\n            result.uvs6 = meshOrGeometry.getVerticesData(VertexBuffer.UV6Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            result.colors = meshOrGeometry.getVerticesData(VertexBuffer.ColorKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\r\n            result.matricesIndices = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\r\n            result.matricesWeights = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesExtraKind)) {\r\n            result.matricesIndicesExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesExtraKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {\r\n            result.matricesWeightsExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsExtraKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        result.indices = meshOrGeometry.getIndices(copyWhenShared, forceCopy);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Ribbon\r\n     * @param options an object used to set the following optional parameters for the ribbon, required but can be empty\r\n     * * pathArray array of paths, each of which an array of successive Vector3\r\n     * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false\r\n     * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false\r\n     * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false\r\n     * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional\r\n     * * colors a linear array, of length 4 * number of vertices, of custom color values, optional\r\n     * @param options.pathArray\r\n     * @param options.closeArray\r\n     * @param options.closePath\r\n     * @param options.offset\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @param options.invertUV\r\n     * @param options.uvs\r\n     * @param options.colors\r\n     * @returns the VertexData of the ribbon\r\n     * @deprecated use CreateRibbonVertexData instead\r\n     */\r\n    public static CreateRibbon(options: {\r\n        pathArray: Vector3[][];\r\n        closeArray?: boolean;\r\n        closePath?: boolean;\r\n        offset?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        invertUV?: boolean;\r\n        uvs?: Vector2[];\r\n        colors?: Color4[];\r\n    }): VertexData {\r\n        throw _WarnImport(\"ribbonBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a box\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * size sets the width, height and depth of the box to the value of size, optional default 1\r\n     * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\r\n     * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\r\n     * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\r\n     * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n     * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.size\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.depth\r\n     * @param options.faceUV\r\n     * @param options.faceColors\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the box\r\n     * @deprecated Please use CreateBoxVertexData from the BoxBuilder file instead\r\n     */\r\n    public static CreateBox(options: {\r\n        size?: number;\r\n        width?: number;\r\n        height?: number;\r\n        depth?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"boxBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a tiled box\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * faceTiles sets the pattern, tile size and number of tiles for a face\r\n     * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n     * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * @param options.pattern\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.depth\r\n     * @param options.tileSize\r\n     * @param options.tileWidth\r\n     * @param options.tileHeight\r\n     * @param options.alignHorizontal\r\n     * @param options.alignVertical\r\n     * @param options.faceUV\r\n     * @param options.faceColors\r\n     * @param options.sideOrientation\r\n     * @returns the VertexData of the box\r\n     * @deprecated Please use CreateTiledBoxVertexData instead\r\n     */\r\n    public static CreateTiledBox(options: {\r\n        pattern?: number;\r\n        width?: number;\r\n        height?: number;\r\n        depth?: number;\r\n        tileSize?: number;\r\n        tileWidth?: number;\r\n        tileHeight?: number;\r\n        alignHorizontal?: number;\r\n        alignVertical?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        sideOrientation?: number;\r\n    }): VertexData {\r\n        throw _WarnImport(\"tiledBoxBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a tiled plane\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * pattern a limited pattern arrangement depending on the number\r\n     * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\r\n     * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\r\n     * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.pattern\r\n     * @param options.tileSize\r\n     * @param options.tileWidth\r\n     * @param options.tileHeight\r\n     * @param options.size\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.alignHorizontal\r\n     * @param options.alignVertical\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the tiled plane\r\n     * @deprecated use CreateTiledPlaneVertexData instead\r\n     */\r\n    public static CreateTiledPlane(options: {\r\n        pattern?: number;\r\n        tileSize?: number;\r\n        tileWidth?: number;\r\n        tileHeight?: number;\r\n        size?: number;\r\n        width?: number;\r\n        height?: number;\r\n        alignHorizontal?: number;\r\n        alignVertical?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"tiledPlaneBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for an ellipsoid, defaults to a sphere\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * segments sets the number of horizontal strips optional, default 32\r\n     * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\r\n     * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\r\n     * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\r\n     * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\r\n     * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\r\n     * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.segments\r\n     * @param options.diameter\r\n     * @param options.diameterX\r\n     * @param options.diameterY\r\n     * @param options.diameterZ\r\n     * @param options.arc\r\n     * @param options.slice\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the ellipsoid\r\n     * @deprecated use CreateSphereVertexData instead\r\n     */\r\n    public static CreateSphere(options: {\r\n        segments?: number;\r\n        diameter?: number;\r\n        diameterX?: number;\r\n        diameterY?: number;\r\n        diameterZ?: number;\r\n        arc?: number;\r\n        slice?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"sphereBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a cylinder, cone or prism\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * height sets the height (y direction) of the cylinder, optional, default 2\r\n     * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\r\n     * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\r\n     * * diameter sets the diameter of the top and bottom of the cone, optional default 1\r\n     * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n     * * subdivisions` the number of rings along the cylinder height, optional, default 1\r\n     * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\r\n     * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n     * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n     * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false\r\n     * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.height\r\n     * @param options.diameterTop\r\n     * @param options.diameterBottom\r\n     * @param options.diameter\r\n     * @param options.tessellation\r\n     * @param options.subdivisions\r\n     * @param options.arc\r\n     * @param options.faceColors\r\n     * @param options.faceUV\r\n     * @param options.hasRings\r\n     * @param options.enclose\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the cylinder, cone or prism\r\n     * @deprecated please use CreateCylinderVertexData instead\r\n     */\r\n    public static CreateCylinder(options: {\r\n        height?: number;\r\n        diameterTop?: number;\r\n        diameterBottom?: number;\r\n        diameter?: number;\r\n        tessellation?: number;\r\n        subdivisions?: number;\r\n        arc?: number;\r\n        faceColors?: Color4[];\r\n        faceUV?: Vector4[];\r\n        hasRings?: boolean;\r\n        enclose?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"cylinderBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a torus\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * diameter the diameter of the torus, optional default 1\r\n     * * thickness the diameter of the tube forming the torus, optional default 0.5\r\n     * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.diameter\r\n     * @param options.thickness\r\n     * @param options.tessellation\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the torus\r\n     * @deprecated use CreateTorusVertexData instead\r\n     */\r\n    public static CreateTorus(options: {\r\n        diameter?: number;\r\n        thickness?: number;\r\n        tessellation?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"torusBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the LineSystem\r\n     * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\r\n     *  - lines an array of lines, each line being an array of successive Vector3\r\n     *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\r\n     * @param options.lines\r\n     * @param options.colors\r\n     * @returns the VertexData of the LineSystem\r\n     * @deprecated use CreateLineSystemVertexData instead\r\n     */\r\n    public static CreateLineSystem(options: { lines: Vector3[][]; colors?: Nullable<Color4[][]> }): VertexData {\r\n        throw _WarnImport(\"linesBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Create the VertexData for a DashedLines\r\n     * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\r\n     *  - points an array successive Vector3\r\n     *  - dashSize the size of the dashes relative to the dash number, optional, default 3\r\n     *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\r\n     *  - dashNb the intended total number of dashes, optional, default 200\r\n     * @param options.points\r\n     * @param options.dashSize\r\n     * @param options.gapSize\r\n     * @param options.dashNb\r\n     * @returns the VertexData for the DashedLines\r\n     * @deprecated use CreateDashedLinesVertexData instead\r\n     */\r\n    public static CreateDashedLines(options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number }): VertexData {\r\n        throw _WarnImport(\"linesBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Ground\r\n     * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n     *  - width the width (x direction) of the ground, optional, default 1\r\n     *  - height the height (z direction) of the ground, optional, default 1\r\n     *  - subdivisions the number of subdivisions per side, optional, default 1\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.subdivisions\r\n     * @param options.subdivisionsX\r\n     * @param options.subdivisionsY\r\n     * @returns the VertexData of the Ground\r\n     * @deprecated Please use CreateGroundVertexData instead\r\n     */\r\n    public static CreateGround(options: { width?: number; height?: number; subdivisions?: number; subdivisionsX?: number; subdivisionsY?: number }): VertexData {\r\n        throw _WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a TiledGround by subdividing the ground into tiles\r\n     * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n     * * xmin the ground minimum X coordinate, optional, default -1\r\n     * * zmin the ground minimum Z coordinate, optional, default -1\r\n     * * xmax the ground maximum X coordinate, optional, default 1\r\n     * * zmax the ground maximum Z coordinate, optional, default 1\r\n     * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\r\n     * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\r\n     * @param options.xmin\r\n     * @param options.zmin\r\n     * @param options.xmax\r\n     * @param options.zmax\r\n     * @param options.subdivisions\r\n     * @param options.subdivisions.w\r\n     * @param options.subdivisions.h\r\n     * @param options.precision\r\n     * @param options.precision.w\r\n     * @param options.precision.h\r\n     * @returns the VertexData of the TiledGround\r\n     * @deprecated use CreateTiledGroundVertexData instead\r\n     */\r\n    public static CreateTiledGround(options: {\r\n        xmin: number;\r\n        zmin: number;\r\n        xmax: number;\r\n        zmax: number;\r\n        subdivisions?: { w: number; h: number };\r\n        precision?: { w: number; h: number };\r\n    }): VertexData {\r\n        throw _WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the Ground designed from a heightmap\r\n     * @param options an object used to set the following parameters for the Ground, required and provided by CreateGroundFromHeightMap\r\n     * * width the width (x direction) of the ground\r\n     * * height the height (z direction) of the ground\r\n     * * subdivisions the number of subdivisions per side\r\n     * * minHeight the minimum altitude on the ground, optional, default 0\r\n     * * maxHeight the maximum altitude on the ground, optional default 1\r\n     * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\r\n     * * buffer the array holding the image color data\r\n     * * bufferWidth the width of image\r\n     * * bufferHeight the height of image\r\n     * * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.subdivisions\r\n     * @param options.minHeight\r\n     * @param options.maxHeight\r\n     * @param options.colorFilter\r\n     * @param options.buffer\r\n     * @param options.bufferWidth\r\n     * @param options.bufferHeight\r\n     * @param options.alphaFilter\r\n     * @returns the VertexData of the Ground designed from a heightmap\r\n     * @deprecated use CreateGroundFromHeightMapVertexData instead\r\n     */\r\n    public static CreateGroundFromHeightMap(options: {\r\n        width: number;\r\n        height: number;\r\n        subdivisions: number;\r\n        minHeight: number;\r\n        maxHeight: number;\r\n        colorFilter: Color3;\r\n        buffer: Uint8Array;\r\n        bufferWidth: number;\r\n        bufferHeight: number;\r\n        alphaFilter: number;\r\n    }): VertexData {\r\n        throw _WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Plane\r\n     * @param options an object used to set the following optional parameters for the plane, required but can be empty\r\n     * * size sets the width and height of the plane to the value of size, optional default 1\r\n     * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size\r\n     * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.size\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the box\r\n     * @deprecated use CreatePlaneVertexData instead\r\n     */\r\n    public static CreatePlane(options: { size?: number; width?: number; height?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 }): VertexData {\r\n        throw _WarnImport(\"planeBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the Disc or regular Polygon\r\n     * @param options an object used to set the following optional parameters for the disc, required but can be empty\r\n     * * radius the radius of the disc, optional default 0.5\r\n     * * tessellation the number of polygon sides, optional, default 64\r\n     * * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.radius\r\n     * @param options.tessellation\r\n     * @param options.arc\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the box\r\n     * @deprecated use CreateDiscVertexData instead\r\n     */\r\n    public static CreateDisc(options: { radius?: number; tessellation?: number; arc?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 }): VertexData {\r\n        throw _WarnImport(\"discBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()\r\n     * All parameters are provided by CreatePolygon as needed\r\n     * @param polygon a mesh built from polygonTriangulation.build()\r\n     * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n     * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n     * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param wrap a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side\r\n     * @returns the VertexData of the Polygon\r\n     * @deprecated use CreatePolygonVertexData instead\r\n     */\r\n    public static CreatePolygon(polygon: Mesh, sideOrientation: number, fUV?: Vector4[], fColors?: Color4[], frontUVs?: Vector4, backUVs?: Vector4, wrap?: boolean): VertexData {\r\n        throw _WarnImport(\"polygonBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the IcoSphere\r\n     * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty\r\n     * * radius the radius of the IcoSphere, optional default 1\r\n     * * radiusX allows stretching in the x direction, optional, default radius\r\n     * * radiusY allows stretching in the y direction, optional, default radius\r\n     * * radiusZ allows stretching in the z direction, optional, default radius\r\n     * * flat when true creates a flat shaded mesh, optional, default true\r\n     * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.radius\r\n     * @param options.radiusX\r\n     * @param options.radiusY\r\n     * @param options.radiusZ\r\n     * @param options.flat\r\n     * @param options.subdivisions\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the IcoSphere\r\n     * @deprecated use CreateIcoSphereVertexData instead\r\n     */\r\n    public static CreateIcoSphere(options: {\r\n        radius?: number;\r\n        radiusX?: number;\r\n        radiusY?: number;\r\n        radiusZ?: number;\r\n        flat?: boolean;\r\n        subdivisions?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"icoSphereBuilder\");\r\n    }\r\n\r\n    // inspired from // http://stemkoski.github.io/Three.js/Polyhedra.html\r\n    /**\r\n     * Creates the VertexData for a Polyhedron\r\n     * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n     * * type provided types are:\r\n     *  * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\r\n     *  * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\r\n     * * size the size of the IcoSphere, optional default 1\r\n     * * sizeX allows stretching in the x direction, optional, default size\r\n     * * sizeY allows stretching in the y direction, optional, default size\r\n     * * sizeZ allows stretching in the z direction, optional, default size\r\n     * * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor\r\n     * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n     * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n     * * flat when true creates a flat shaded mesh, optional, default true\r\n     * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.type\r\n     * @param options.size\r\n     * @param options.sizeX\r\n     * @param options.sizeY\r\n     * @param options.sizeZ\r\n     * @param options.custom\r\n     * @param options.faceUV\r\n     * @param options.faceColors\r\n     * @param options.flat\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the Polyhedron\r\n     * @deprecated use CreatePolyhedronVertexData instead\r\n     */\r\n    public static CreatePolyhedron(options: {\r\n        type?: number;\r\n        size?: number;\r\n        sizeX?: number;\r\n        sizeY?: number;\r\n        sizeZ?: number;\r\n        custom?: any;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        flat?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"polyhedronBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Capsule, inspired from https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\r\n     * @param options an object used to set the following optional parameters for the capsule, required but can be empty\r\n     * @returns the VertexData of the Capsule\r\n     * @deprecated Please use CreateCapsuleVertexData from the capsuleBuilder file instead\r\n     */\r\n    public static CreateCapsule(\r\n        options: ICreateCapsuleOptions = {\r\n            orientation: Vector3.Up(),\r\n            subdivisions: 2,\r\n            tessellation: 16,\r\n            height: 1,\r\n            radius: 0.25,\r\n            capSubdivisions: 6,\r\n        }\r\n    ): VertexData {\r\n        throw _WarnImport(\"capsuleBuilder\");\r\n    }\r\n\r\n    // based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\r\n    /**\r\n     * Creates the VertexData for a TorusKnot\r\n     * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\r\n     * * radius the radius of the torus knot, optional, default 2\r\n     * * tube the thickness of the tube, optional, default 0.5\r\n     * * radialSegments the number of sides on each tube segments, optional, default 32\r\n     * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\r\n     * * p the number of windings around the z axis, optional,  default 2\r\n     * * q the number of windings around the x axis, optional,  default 3\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.radius\r\n     * @param options.tube\r\n     * @param options.radialSegments\r\n     * @param options.tubularSegments\r\n     * @param options.p\r\n     * @param options.q\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the Torus Knot\r\n     * @deprecated use CreateTorusKnotVertexData instead\r\n     */\r\n    public static CreateTorusKnot(options: {\r\n        radius?: number;\r\n        tube?: number;\r\n        radialSegments?: number;\r\n        tubularSegments?: number;\r\n        p?: number;\r\n        q?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"torusKnotBuilder\");\r\n    }\r\n\r\n    // Tools\r\n\r\n    /**\r\n     * Compute normals for given positions and indices\r\n     * @param positions an array of vertex positions, [...., x, y, z, ......]\r\n     * @param indices an array of indices in groups of three for each triangular facet, [...., i, j, k, ......]\r\n     * @param normals an array of vertex normals, [...., x, y, z, ......]\r\n     * @param options an object used to set the following optional parameters for the TorusKnot, optional\r\n     * * facetNormals : optional array of facet normals (vector3)\r\n     * * facetPositions : optional array of facet positions (vector3)\r\n     * * facetPartitioning : optional partitioning array. facetPositions is required for facetPartitioning computation\r\n     * * ratio : optional partitioning ratio / bounding box, required for facetPartitioning computation\r\n     * * bInfo : optional bounding info, required for facetPartitioning computation\r\n     * * bbSize : optional bounding box size data, required for facetPartitioning computation\r\n     * * subDiv : optional partitioning data about subdivisions on  each axis (int), required for facetPartitioning computation\r\n     * * useRightHandedSystem: optional boolean to for right handed system computation\r\n     * * depthSort : optional boolean to enable the facet depth sort computation\r\n     * * distanceTo : optional Vector3 to compute the facet depth from this location\r\n     * * depthSortedFacets : optional array of depthSortedFacets to store the facet distances from the reference location\r\n     * @param options.facetNormals\r\n     * @param options.facetPositions\r\n     * @param options.facetPartitioning\r\n     * @param options.ratio\r\n     * @param options.bInfo\r\n     * @param options.bbSize\r\n     * @param options.subDiv\r\n     * @param options.useRightHandedSystem\r\n     * @param options.depthSort\r\n     * @param options.distanceTo\r\n     * @param options.depthSortedFacets\r\n     */\r\n    public static ComputeNormals(\r\n        positions: any,\r\n        indices: any,\r\n        normals: any,\r\n        options?: {\r\n            facetNormals?: any;\r\n            facetPositions?: any;\r\n            facetPartitioning?: any;\r\n            ratio?: number;\r\n            bInfo?: any;\r\n            bbSize?: Vector3;\r\n            subDiv?: any;\r\n            useRightHandedSystem?: boolean;\r\n            depthSort?: boolean;\r\n            distanceTo?: Vector3;\r\n            depthSortedFacets?: any;\r\n        }\r\n    ): void {\r\n        // temporary scalar variables\r\n        let index = 0; // facet index\r\n        let p1p2x = 0.0; // p1p2 vector x coordinate\r\n        let p1p2y = 0.0; // p1p2 vector y coordinate\r\n        let p1p2z = 0.0; // p1p2 vector z coordinate\r\n        let p3p2x = 0.0; // p3p2 vector x coordinate\r\n        let p3p2y = 0.0; // p3p2 vector y coordinate\r\n        let p3p2z = 0.0; // p3p2 vector z coordinate\r\n        let faceNormalx = 0.0; // facet normal x coordinate\r\n        let faceNormaly = 0.0; // facet normal y coordinate\r\n        let faceNormalz = 0.0; // facet normal z coordinate\r\n        let length = 0.0; // facet normal length before normalization\r\n        let v1x = 0; // vector1 x index in the positions array\r\n        let v1y = 0; // vector1 y index in the positions array\r\n        let v1z = 0; // vector1 z index in the positions array\r\n        let v2x = 0; // vector2 x index in the positions array\r\n        let v2y = 0; // vector2 y index in the positions array\r\n        let v2z = 0; // vector2 z index in the positions array\r\n        let v3x = 0; // vector3 x index in the positions array\r\n        let v3y = 0; // vector3 y index in the positions array\r\n        let v3z = 0; // vector3 z index in the positions array\r\n        let computeFacetNormals = false;\r\n        let computeFacetPositions = false;\r\n        let computeFacetPartitioning = false;\r\n        let computeDepthSort = false;\r\n        let faceNormalSign = 1;\r\n        let ratio = 0;\r\n        let distanceTo: Nullable<Vector3> = null;\r\n        if (options) {\r\n            computeFacetNormals = options.facetNormals ? true : false;\r\n            computeFacetPositions = options.facetPositions ? true : false;\r\n            computeFacetPartitioning = options.facetPartitioning ? true : false;\r\n            faceNormalSign = options.useRightHandedSystem === true ? -1 : 1;\r\n            ratio = options.ratio || 0;\r\n            computeDepthSort = options.depthSort ? true : false;\r\n            distanceTo = <Vector3>options.distanceTo;\r\n            if (computeDepthSort) {\r\n                if (distanceTo === undefined) {\r\n                    distanceTo = Vector3.Zero();\r\n                }\r\n            }\r\n        }\r\n\r\n        // facetPartitioning reinit if needed\r\n        let xSubRatio = 0;\r\n        let ySubRatio = 0;\r\n        let zSubRatio = 0;\r\n        let subSq = 0;\r\n        if (computeFacetPartitioning && options && options.bbSize) {\r\n            //let bbSizeMax = options.bbSize.x > options.bbSize.y ? options.bbSize.x : options.bbSize.y;\r\n            //bbSizeMax = bbSizeMax > options.bbSize.z ? bbSizeMax : options.bbSize.z;\r\n            xSubRatio = (options.subDiv.X * ratio) / options.bbSize.x;\r\n            ySubRatio = (options.subDiv.Y * ratio) / options.bbSize.y;\r\n            zSubRatio = (options.subDiv.Z * ratio) / options.bbSize.z;\r\n            subSq = options.subDiv.max * options.subDiv.max;\r\n            options.facetPartitioning.length = 0;\r\n        }\r\n\r\n        // reset the normals\r\n        for (index = 0; index < positions.length; index++) {\r\n            normals[index] = 0.0;\r\n        }\r\n\r\n        // Loop : 1 indice triplet = 1 facet\r\n        const nbFaces = (indices.length / 3) | 0;\r\n        for (index = 0; index < nbFaces; index++) {\r\n            // get the indexes of the coordinates of each vertex of the facet\r\n            v1x = indices[index * 3] * 3;\r\n            v1y = v1x + 1;\r\n            v1z = v1x + 2;\r\n            v2x = indices[index * 3 + 1] * 3;\r\n            v2y = v2x + 1;\r\n            v2z = v2x + 2;\r\n            v3x = indices[index * 3 + 2] * 3;\r\n            v3y = v3x + 1;\r\n            v3z = v3x + 2;\r\n\r\n            p1p2x = positions[v1x] - positions[v2x]; // compute two vectors per facet : p1p2 and p3p2\r\n            p1p2y = positions[v1y] - positions[v2y];\r\n            p1p2z = positions[v1z] - positions[v2z];\r\n\r\n            p3p2x = positions[v3x] - positions[v2x];\r\n            p3p2y = positions[v3y] - positions[v2y];\r\n            p3p2z = positions[v3z] - positions[v2z];\r\n\r\n            // compute the face normal with the cross product\r\n            faceNormalx = faceNormalSign * (p1p2y * p3p2z - p1p2z * p3p2y);\r\n            faceNormaly = faceNormalSign * (p1p2z * p3p2x - p1p2x * p3p2z);\r\n            faceNormalz = faceNormalSign * (p1p2x * p3p2y - p1p2y * p3p2x);\r\n            // normalize this normal and store it in the array facetData\r\n            length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\r\n            length = length === 0 ? 1.0 : length;\r\n            faceNormalx /= length;\r\n            faceNormaly /= length;\r\n            faceNormalz /= length;\r\n\r\n            if (computeFacetNormals && options) {\r\n                options.facetNormals[index].x = faceNormalx;\r\n                options.facetNormals[index].y = faceNormaly;\r\n                options.facetNormals[index].z = faceNormalz;\r\n            }\r\n\r\n            if (computeFacetPositions && options) {\r\n                // compute and the facet barycenter coordinates in the array facetPositions\r\n                options.facetPositions[index].x = (positions[v1x] + positions[v2x] + positions[v3x]) / 3.0;\r\n                options.facetPositions[index].y = (positions[v1y] + positions[v2y] + positions[v3y]) / 3.0;\r\n                options.facetPositions[index].z = (positions[v1z] + positions[v2z] + positions[v3z]) / 3.0;\r\n            }\r\n\r\n            if (computeFacetPartitioning && options) {\r\n                // store the facet indexes in arrays in the main facetPartitioning array :\r\n                // compute each facet vertex (+ facet barycenter) index in the partiniong array\r\n                const ox = Math.floor((options.facetPositions[index].x - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const oy = Math.floor((options.facetPositions[index].y - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const oz = Math.floor((options.facetPositions[index].z - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                const b1x = Math.floor((positions[v1x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const b1y = Math.floor((positions[v1y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const b1z = Math.floor((positions[v1z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                const b2x = Math.floor((positions[v2x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const b2y = Math.floor((positions[v2y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const b2z = Math.floor((positions[v2z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                const b3x = Math.floor((positions[v3x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const b3y = Math.floor((positions[v3y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const b3z = Math.floor((positions[v3z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n\r\n                const block_idx_v1 = b1x + options.subDiv.max * b1y + subSq * b1z;\r\n                const block_idx_v2 = b2x + options.subDiv.max * b2y + subSq * b2z;\r\n                const block_idx_v3 = b3x + options.subDiv.max * b3y + subSq * b3z;\r\n                const block_idx_o = ox + options.subDiv.max * oy + subSq * oz;\r\n\r\n                options.facetPartitioning[block_idx_o] = options.facetPartitioning[block_idx_o] ? options.facetPartitioning[block_idx_o] : new Array();\r\n                options.facetPartitioning[block_idx_v1] = options.facetPartitioning[block_idx_v1] ? options.facetPartitioning[block_idx_v1] : new Array();\r\n                options.facetPartitioning[block_idx_v2] = options.facetPartitioning[block_idx_v2] ? options.facetPartitioning[block_idx_v2] : new Array();\r\n                options.facetPartitioning[block_idx_v3] = options.facetPartitioning[block_idx_v3] ? options.facetPartitioning[block_idx_v3] : new Array();\r\n\r\n                // push each facet index in each block containing the vertex\r\n                options.facetPartitioning[block_idx_v1].push(index);\r\n                if (block_idx_v2 != block_idx_v1) {\r\n                    options.facetPartitioning[block_idx_v2].push(index);\r\n                }\r\n                if (!(block_idx_v3 == block_idx_v2 || block_idx_v3 == block_idx_v1)) {\r\n                    options.facetPartitioning[block_idx_v3].push(index);\r\n                }\r\n                if (!(block_idx_o == block_idx_v1 || block_idx_o == block_idx_v2 || block_idx_o == block_idx_v3)) {\r\n                    options.facetPartitioning[block_idx_o].push(index);\r\n                }\r\n            }\r\n\r\n            if (computeDepthSort && options && options.facetPositions) {\r\n                const dsf = options.depthSortedFacets[index];\r\n                dsf.ind = index * 3;\r\n                dsf.sqDistance = Vector3.DistanceSquared(options.facetPositions[index], distanceTo!);\r\n            }\r\n\r\n            // compute the normals anyway\r\n            normals[v1x] += faceNormalx; // accumulate all the normals per face\r\n            normals[v1y] += faceNormaly;\r\n            normals[v1z] += faceNormalz;\r\n            normals[v2x] += faceNormalx;\r\n            normals[v2y] += faceNormaly;\r\n            normals[v2z] += faceNormalz;\r\n            normals[v3x] += faceNormalx;\r\n            normals[v3y] += faceNormaly;\r\n            normals[v3z] += faceNormalz;\r\n        }\r\n        // last normalization of each normal\r\n        for (index = 0; index < normals.length / 3; index++) {\r\n            faceNormalx = normals[index * 3];\r\n            faceNormaly = normals[index * 3 + 1];\r\n            faceNormalz = normals[index * 3 + 2];\r\n\r\n            length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\r\n            length = length === 0 ? 1.0 : length;\r\n            faceNormalx /= length;\r\n            faceNormaly /= length;\r\n            faceNormalz /= length;\r\n\r\n            normals[index * 3] = faceNormalx;\r\n            normals[index * 3 + 1] = faceNormaly;\r\n            normals[index * 3 + 2] = faceNormalz;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param sideOrientation\r\n     * @param positions\r\n     * @param indices\r\n     * @param normals\r\n     * @param uvs\r\n     * @param frontUVs\r\n     * @param backUVs\r\n     * @hidden\r\n     */\r\n    public static _ComputeSides(\r\n        sideOrientation: number,\r\n        positions: FloatArray,\r\n        indices: FloatArray | IndicesArray,\r\n        normals: FloatArray,\r\n        uvs: FloatArray,\r\n        frontUVs?: Vector4,\r\n        backUVs?: Vector4\r\n    ) {\r\n        const li: number = indices.length;\r\n        const ln: number = normals.length;\r\n        let i: number;\r\n        let n: number;\r\n        sideOrientation = sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n        switch (sideOrientation) {\r\n            case VertexData.FRONTSIDE:\r\n                // nothing changed\r\n                break;\r\n\r\n            case VertexData.BACKSIDE:\r\n                // indices\r\n                for (i = 0; i < li; i += 3) {\r\n                    const tmp = indices[i];\r\n                    indices[i] = indices[i + 2];\r\n                    indices[i + 2] = tmp;\r\n                }\r\n                // normals\r\n                for (n = 0; n < ln; n++) {\r\n                    normals[n] = -normals[n];\r\n                }\r\n                break;\r\n\r\n            case VertexData.DOUBLESIDE: {\r\n                // positions\r\n                const lp: number = positions.length;\r\n                const l: number = lp / 3;\r\n                for (let p = 0; p < lp; p++) {\r\n                    positions[lp + p] = positions[p];\r\n                }\r\n                // indices\r\n                for (i = 0; i < li; i += 3) {\r\n                    indices[i + li] = indices[i + 2] + l;\r\n                    indices[i + 1 + li] = indices[i + 1] + l;\r\n                    indices[i + 2 + li] = indices[i] + l;\r\n                }\r\n                // normals\r\n                for (n = 0; n < ln; n++) {\r\n                    normals[ln + n] = -normals[n];\r\n                }\r\n\r\n                // uvs\r\n                const lu: number = uvs.length;\r\n                let u: number = 0;\r\n                for (u = 0; u < lu; u++) {\r\n                    uvs[u + lu] = uvs[u];\r\n                }\r\n                frontUVs = frontUVs ? frontUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\r\n                backUVs = backUVs ? backUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\r\n                u = 0;\r\n                for (i = 0; i < lu / 2; i++) {\r\n                    uvs[u] = frontUVs.x + (frontUVs.z - frontUVs.x) * uvs[u];\r\n                    uvs[u + 1] = frontUVs.y + (frontUVs.w - frontUVs.y) * uvs[u + 1];\r\n                    uvs[u + lu] = backUVs.x + (backUVs.z - backUVs.x) * uvs[u + lu];\r\n                    uvs[u + lu + 1] = backUVs.y + (backUVs.w - backUVs.y) * uvs[u + lu + 1];\r\n                    u += 2;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Applies VertexData created from the imported parameters to the geometry\r\n     * @param parsedVertexData the parsed data from an imported file\r\n     * @param geometry the geometry to apply the VertexData to\r\n     */\r\n    public static ImportVertexData(parsedVertexData: any, geometry: Geometry) {\r\n        const vertexData = new VertexData();\r\n\r\n        // positions\r\n        const positions = parsedVertexData.positions;\r\n        if (positions) {\r\n            vertexData.set(positions, VertexBuffer.PositionKind);\r\n        }\r\n\r\n        // normals\r\n        const normals = parsedVertexData.normals;\r\n        if (normals) {\r\n            vertexData.set(normals, VertexBuffer.NormalKind);\r\n        }\r\n\r\n        // tangents\r\n        const tangents = parsedVertexData.tangents;\r\n        if (tangents) {\r\n            vertexData.set(tangents, VertexBuffer.TangentKind);\r\n        }\r\n\r\n        // uvs\r\n        const uvs = parsedVertexData.uvs;\r\n        if (uvs) {\r\n            vertexData.set(uvs, VertexBuffer.UVKind);\r\n        }\r\n\r\n        // uv2s\r\n        const uv2s = parsedVertexData.uv2s;\r\n        if (uv2s) {\r\n            vertexData.set(uv2s, VertexBuffer.UV2Kind);\r\n        }\r\n\r\n        // uv3s\r\n        const uv3s = parsedVertexData.uv3s;\r\n        if (uv3s) {\r\n            vertexData.set(uv3s, VertexBuffer.UV3Kind);\r\n        }\r\n\r\n        // uv4s\r\n        const uv4s = parsedVertexData.uv4s;\r\n        if (uv4s) {\r\n            vertexData.set(uv4s, VertexBuffer.UV4Kind);\r\n        }\r\n\r\n        // uv5s\r\n        const uv5s = parsedVertexData.uv5s;\r\n        if (uv5s) {\r\n            vertexData.set(uv5s, VertexBuffer.UV5Kind);\r\n        }\r\n\r\n        // uv6s\r\n        const uv6s = parsedVertexData.uv6s;\r\n        if (uv6s) {\r\n            vertexData.set(uv6s, VertexBuffer.UV6Kind);\r\n        }\r\n\r\n        // colors\r\n        const colors = parsedVertexData.colors;\r\n        if (colors) {\r\n            vertexData.set(Color4.CheckColors4(colors, positions.length / 3), VertexBuffer.ColorKind);\r\n        }\r\n\r\n        // matricesIndices\r\n        const matricesIndices = parsedVertexData.matricesIndices;\r\n        if (matricesIndices) {\r\n            vertexData.set(matricesIndices, VertexBuffer.MatricesIndicesKind);\r\n        }\r\n\r\n        // matricesWeights\r\n        const matricesWeights = parsedVertexData.matricesWeights;\r\n        if (matricesWeights) {\r\n            vertexData.set(matricesWeights, VertexBuffer.MatricesWeightsKind);\r\n        }\r\n\r\n        // indices\r\n        const indices = parsedVertexData.indices;\r\n        if (indices) {\r\n            vertexData.indices = indices;\r\n        }\r\n\r\n        geometry.setAllVerticesData(vertexData, parsedVertexData.updatable);\r\n    }\r\n}\r\n"]}