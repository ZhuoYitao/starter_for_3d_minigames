{"version":3,"file":"geometry.js","sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/geometry.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Nullable, FloatArray, DataArray, IndicesArray } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Vector2 } from \"../Maths/math.vector\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { IGetSetVerticesData } from \"../Meshes/mesh.vertexData\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { SceneLoaderFlags } from \"../Loading/sceneLoaderFlags\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { Tags } from \"../Misc/tags\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { extractMinAndMax } from \"../Maths/math.functions\";\r\nimport type { AbstractScene } from \"../abstractScene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { CompatibilityOptions } from \"../Compat/compatibilityOptions\";\r\n\r\ndeclare type Mesh = import(\"../Meshes/mesh\").Mesh;\r\n\r\n/**\r\n * Class used to store geometry data (vertex buffers + index buffer)\r\n */\r\nexport class Geometry implements IGetSetVerticesData {\r\n    // Members\r\n    /**\r\n     * Gets or sets the ID of the geometry\r\n     */\r\n    public id: string;\r\n    /**\r\n     * Gets or sets the unique ID of the geometry\r\n     */\r\n    public uniqueId: number;\r\n    /**\r\n     * Gets the delay loading state of the geometry (none by default which means not delayed)\r\n     */\r\n    public delayLoadState = Constants.DELAYLOADSTATE_NONE;\r\n    /**\r\n     * Gets the file containing the data to load when running in delay load state\r\n     */\r\n    public delayLoadingFile: Nullable<string>;\r\n    /**\r\n     * Callback called when the geometry is updated\r\n     */\r\n    public onGeometryUpdated: (geometry: Geometry, kind?: string) => void;\r\n\r\n    // Private\r\n    private _scene: Scene;\r\n    private _engine: Engine;\r\n    private _meshes: Mesh[];\r\n    private _totalVertices = 0;\r\n    /** @hidden */\r\n    public _loadedUniqueId: string;\r\n    /** @hidden */\r\n    public _indices: IndicesArray;\r\n    /** @hidden */\r\n    public _vertexBuffers: { [key: string]: VertexBuffer };\r\n    private _isDisposed = false;\r\n    private _extend: { minimum: Vector3; maximum: Vector3 };\r\n    private _boundingBias: Vector2;\r\n    /** @hidden */\r\n    public _delayInfo: Array<string>;\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _indexBufferIsUpdatable = false;\r\n    /** @hidden */\r\n    public _boundingInfo: Nullable<BoundingInfo>;\r\n    /** @hidden */\r\n    public _delayLoadingFunction: Nullable<(any: any, geometry: Geometry) => void>;\r\n    /** @hidden */\r\n    public _softwareSkinningFrameId: number;\r\n    private _vertexArrayObjects: { [key: string]: WebGLVertexArrayObject };\r\n    private _updatable: boolean;\r\n\r\n    // Cache\r\n    /** @hidden */\r\n    public _positions: Nullable<Vector3[]>;\r\n    private _positionsCache: Vector3[] = [];\r\n\r\n    /** @hidden */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    /**\r\n     *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\r\n     */\r\n    public get boundingBias(): Vector2 {\r\n        return this._boundingBias;\r\n    }\r\n\r\n    /**\r\n     *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\r\n     */\r\n    public set boundingBias(value: Vector2) {\r\n        if (this._boundingBias) {\r\n            this._boundingBias.copyFrom(value);\r\n        } else {\r\n            this._boundingBias = value.clone();\r\n        }\r\n\r\n        this._updateBoundingInfo(true, null);\r\n    }\r\n\r\n    /**\r\n     * Static function used to attach a new empty geometry to a mesh\r\n     * @param mesh defines the mesh to attach the geometry to\r\n     * @returns the new Geometry\r\n     */\r\n    public static CreateGeometryForMesh(mesh: Mesh): Geometry {\r\n        const geometry = new Geometry(Geometry.RandomId(), mesh.getScene());\r\n\r\n        geometry.applyToMesh(mesh);\r\n\r\n        return geometry;\r\n    }\r\n\r\n    /** Get the list of meshes using this geometry */\r\n    public get meshes(): Mesh[] {\r\n        return this._meshes;\r\n    }\r\n\r\n    /**\r\n     * If set to true (false by default), the bounding info applied to the meshes sharing this geometry will be the bounding info defined at the class level\r\n     * and won't be computed based on the vertex positions (which is what we get when useBoundingInfoFromGeometry = false)\r\n     */\r\n    public useBoundingInfoFromGeometry = false;\r\n\r\n    /**\r\n     * Creates a new geometry\r\n     * @param id defines the unique ID\r\n     * @param scene defines the hosting scene\r\n     * @param vertexData defines the VertexData used to get geometry data\r\n     * @param updatable defines if geometry must be updatable (false by default)\r\n     * @param mesh defines the mesh that will be associated with the geometry\r\n     */\r\n    constructor(id: string, scene?: Scene, vertexData?: VertexData, updatable: boolean = false, mesh: Nullable<Mesh> = null) {\r\n        this._scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        if (!this._scene) {\r\n            return;\r\n        }\r\n        this.id = id;\r\n        this.uniqueId = this._scene.getUniqueId();\r\n        this._engine = this._scene.getEngine();\r\n        this._meshes = [];\r\n        //Init vertex buffer cache\r\n        this._vertexBuffers = {};\r\n        this._indices = [];\r\n        this._updatable = updatable;\r\n\r\n        // vertexData\r\n        if (vertexData) {\r\n            this.setAllVerticesData(vertexData, updatable);\r\n        } else {\r\n            this._totalVertices = 0;\r\n            this._indices = [];\r\n        }\r\n\r\n        if (this._engine.getCaps().vertexArrayObject) {\r\n            this._vertexArrayObjects = {};\r\n        }\r\n\r\n        // applyToMesh\r\n        if (mesh) {\r\n            this.applyToMesh(mesh);\r\n            mesh.computeWorldMatrix(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current extend of the geometry\r\n     */\r\n    public get extend(): { minimum: Vector3; maximum: Vector3 } {\r\n        return this._extend;\r\n    }\r\n\r\n    /**\r\n     * Gets the hosting scene\r\n     * @returns the hosting Scene\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Gets the hosting engine\r\n     * @returns the hosting Engine\r\n     */\r\n    public getEngine(): Engine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Defines if the geometry is ready to use\r\n     * @returns true if the geometry is ready to be used\r\n     */\r\n    public isReady(): boolean {\r\n        return this.delayLoadState === Constants.DELAYLOADSTATE_LOADED || this.delayLoadState === Constants.DELAYLOADSTATE_NONE;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating that the geometry should not be serialized\r\n     */\r\n    public get doNotSerialize(): boolean {\r\n        for (let index = 0; index < this._meshes.length; index++) {\r\n            if (!this._meshes[index].doNotSerialize) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        if (this._vertexArrayObjects) {\r\n            this._vertexArrayObjects = {};\r\n        }\r\n\r\n        // Index buffer\r\n        if (this._meshes.length !== 0 && this._indices) {\r\n            this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable);\r\n        }\r\n\r\n        // Vertex buffers\r\n        for (const key in this._vertexBuffers) {\r\n            const vertexBuffer = <VertexBuffer>this._vertexBuffers[key];\r\n            vertexBuffer._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Affects all geometry data in one call\r\n     * @param vertexData defines the geometry data\r\n     * @param updatable defines if the geometry must be flagged as updatable (false as default)\r\n     */\r\n    public setAllVerticesData(vertexData: VertexData, updatable?: boolean): void {\r\n        vertexData.applyToGeometry(this, updatable);\r\n        this._notifyUpdate();\r\n    }\r\n\r\n    /**\r\n     * Set specific vertex data\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the vertex data to use\r\n     * @param updatable defines if the vertex must be flagged as updatable (false as default)\r\n     * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified\r\n     */\r\n    public setVerticesData(kind: string, data: FloatArray, updatable: boolean = false, stride?: number): void {\r\n        if (updatable && Array.isArray(data)) {\r\n            // to avoid converting to Float32Array at each draw call in engine.updateDynamicVertexBuffer, we make the conversion a single time here\r\n            data = new Float32Array(data);\r\n        }\r\n        const buffer = new VertexBuffer(this._engine, data, kind, updatable, this._meshes.length === 0, stride);\r\n        this.setVerticesBuffer(buffer);\r\n    }\r\n\r\n    /**\r\n     * Removes a specific vertex data\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     */\r\n    public removeVerticesData(kind: string) {\r\n        if (this._vertexBuffers[kind]) {\r\n            this._vertexBuffers[kind].dispose();\r\n            delete this._vertexBuffers[kind];\r\n        }\r\n\r\n        if (this._vertexArrayObjects) {\r\n            this._disposeVertexArrayObjects();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Affect a vertex buffer to the geometry. the vertexBuffer.getKind() function is used to determine where to store the data\r\n     * @param buffer defines the vertex buffer to use\r\n     * @param totalVertices defines the total number of vertices for position kind (could be null)\r\n     * @param disposeExistingBuffer disposes the existing buffer, if any (default: true)\r\n     */\r\n    public setVerticesBuffer(buffer: VertexBuffer, totalVertices: Nullable<number> = null, disposeExistingBuffer = true): void {\r\n        const kind = buffer.getKind();\r\n        if (this._vertexBuffers[kind] && disposeExistingBuffer) {\r\n            this._vertexBuffers[kind].dispose();\r\n        }\r\n\r\n        if (buffer._buffer) {\r\n            buffer._buffer._increaseReferences();\r\n        }\r\n\r\n        this._vertexBuffers[kind] = buffer;\r\n        const meshes = this._meshes;\r\n        const numOfMeshes = meshes.length;\r\n\r\n        if (kind === VertexBuffer.PositionKind) {\r\n            const data = <FloatArray>buffer.getData();\r\n            if (totalVertices != null) {\r\n                this._totalVertices = totalVertices;\r\n            } else {\r\n                if (data != null) {\r\n                    this._totalVertices = data.length / (buffer.type === VertexBuffer.BYTE ? buffer.byteStride : buffer.byteStride / 4);\r\n                }\r\n            }\r\n\r\n            this._updateExtend(data);\r\n            this._resetPointsArrayCache();\r\n\r\n            for (let index = 0; index < numOfMeshes; index++) {\r\n                const mesh = meshes[index];\r\n                mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);\r\n                mesh._createGlobalSubMesh(false);\r\n                mesh.computeWorldMatrix(true);\r\n                mesh.synchronizeInstances();\r\n            }\r\n        }\r\n\r\n        this._notifyUpdate(kind);\r\n    }\r\n\r\n    /**\r\n     * Update a specific vertex buffer\r\n     * This function will directly update the underlying DataBuffer according to the passed numeric array or Float32Array\r\n     * It will do nothing if the buffer is not updatable\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the data to use\r\n     * @param offset defines the offset in the target buffer where to store the data\r\n     * @param useBytes set to true if the offset is in bytes\r\n     */\r\n    public updateVerticesDataDirectly(kind: string, data: DataArray, offset: number, useBytes: boolean = false): void {\r\n        const vertexBuffer = this.getVertexBuffer(kind);\r\n\r\n        if (!vertexBuffer) {\r\n            return;\r\n        }\r\n\r\n        vertexBuffer.updateDirectly(data, offset, useBytes);\r\n        this._notifyUpdate(kind);\r\n    }\r\n\r\n    /**\r\n     * Update a specific vertex buffer\r\n     * This function will create a new buffer if the current one is not updatable\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the data to use\r\n     * @param updateExtends defines if the geometry extends must be recomputed (false by default)\r\n     */\r\n    public updateVerticesData(kind: string, data: FloatArray, updateExtends: boolean = false): void {\r\n        const vertexBuffer = this.getVertexBuffer(kind);\r\n\r\n        if (!vertexBuffer) {\r\n            return;\r\n        }\r\n\r\n        vertexBuffer.update(data);\r\n\r\n        if (kind === VertexBuffer.PositionKind) {\r\n            this._updateBoundingInfo(updateExtends, data);\r\n        }\r\n        this._notifyUpdate(kind);\r\n    }\r\n\r\n    private _updateBoundingInfo(updateExtends: boolean, data: Nullable<FloatArray>) {\r\n        if (updateExtends) {\r\n            this._updateExtend(data);\r\n        }\r\n\r\n        this._resetPointsArrayCache();\r\n\r\n        if (updateExtends) {\r\n            const meshes = this._meshes;\r\n            for (const mesh of meshes) {\r\n                if (mesh.hasBoundingInfo) {\r\n                    mesh.getBoundingInfo().reConstruct(this._extend.minimum, this._extend.maximum);\r\n                } else {\r\n                    mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);\r\n                }\r\n\r\n                const subMeshes = mesh.subMeshes;\r\n                for (const subMesh of subMeshes) {\r\n                    subMesh.refreshBoundingInfo();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param effect\r\n     * @param indexToBind\r\n     * @hidden\r\n     */\r\n    public _bind(\r\n        effect: Nullable<Effect>,\r\n        indexToBind?: Nullable<DataBuffer>,\r\n        overrideVertexBuffers?: { [kind: string]: Nullable<VertexBuffer> },\r\n        overrideVertexArrayObjects?: { [key: string]: WebGLVertexArrayObject }\r\n    ): void {\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        if (indexToBind === undefined) {\r\n            indexToBind = this._indexBuffer;\r\n        }\r\n        const vbs = this.getVertexBuffers();\r\n\r\n        if (!vbs) {\r\n            return;\r\n        }\r\n\r\n        if (indexToBind != this._indexBuffer || (!this._vertexArrayObjects && !overrideVertexArrayObjects)) {\r\n            this._engine.bindBuffers(vbs, indexToBind, effect, overrideVertexBuffers);\r\n            return;\r\n        }\r\n\r\n        const vaos = overrideVertexArrayObjects ? overrideVertexArrayObjects : this._vertexArrayObjects;\r\n\r\n        // Using VAO\r\n        if (!vaos[effect.key]) {\r\n            vaos[effect.key] = this._engine.recordVertexArrayObject(vbs, indexToBind, effect, overrideVertexBuffers);\r\n        }\r\n\r\n        this._engine.bindVertexArrayObject(vaos[effect.key], indexToBind);\r\n    }\r\n\r\n    /**\r\n     * Gets total number of vertices\r\n     * @returns the total number of vertices\r\n     */\r\n    public getTotalVertices(): number {\r\n        if (!this.isReady()) {\r\n            return 0;\r\n        }\r\n\r\n        return this._totalVertices;\r\n    }\r\n\r\n    /**\r\n     * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns a float array containing vertex data\r\n     */\r\n    public getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray> {\r\n        const vertexBuffer = this.getVertexBuffer(kind);\r\n        if (!vertexBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return vertexBuffer.getFloatData(this._totalVertices, forceCopy || (copyWhenShared && this._meshes.length !== 1));\r\n    }\r\n\r\n    /**\r\n     * Returns a boolean defining if the vertex data for the requested `kind` is updatable\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @returns true if the vertex buffer with the specified kind is updatable\r\n     */\r\n    public isVertexBufferUpdatable(kind: string): boolean {\r\n        const vb = this._vertexBuffers[kind];\r\n\r\n        if (!vb) {\r\n            return false;\r\n        }\r\n\r\n        return vb.isUpdatable();\r\n    }\r\n\r\n    /**\r\n     * Gets a specific vertex buffer\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @returns a VertexBuffer\r\n     */\r\n    public getVertexBuffer(kind: string): Nullable<VertexBuffer> {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        return this._vertexBuffers[kind];\r\n    }\r\n\r\n    /**\r\n     * Returns all vertex buffers\r\n     * @return an object holding all vertex buffers indexed by kind\r\n     */\r\n    public getVertexBuffers(): Nullable<{ [key: string]: VertexBuffer }> {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        return this._vertexBuffers;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if specific vertex buffer is present\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @returns true if data is present\r\n     */\r\n    public isVerticesDataPresent(kind: string): boolean {\r\n        if (!this._vertexBuffers) {\r\n            if (this._delayInfo) {\r\n                return this._delayInfo.indexOf(kind) !== -1;\r\n            }\r\n            return false;\r\n        }\r\n        return this._vertexBuffers[kind] !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Gets a list of all attached data kinds (Position, normal, etc...)\r\n     * @returns a list of string containing all kinds\r\n     */\r\n    public getVerticesDataKinds(): string[] {\r\n        const result = [];\r\n        let kind;\r\n        if (!this._vertexBuffers && this._delayInfo) {\r\n            for (kind in this._delayInfo) {\r\n                result.push(kind);\r\n            }\r\n        } else {\r\n            for (kind in this._vertexBuffers) {\r\n                result.push(kind);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Update index buffer\r\n     * @param indices defines the indices to store in the index buffer\r\n     * @param offset defines the offset in the target buffer where to store the data\r\n     * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\r\n     */\r\n    public updateIndices(indices: IndicesArray, offset?: number, gpuMemoryOnly = false): void {\r\n        if (!this._indexBuffer) {\r\n            return;\r\n        }\r\n\r\n        if (!this._indexBufferIsUpdatable) {\r\n            this.setIndices(indices, null, true);\r\n        } else {\r\n            const needToUpdateSubMeshes = indices.length !== this._indices.length;\r\n\r\n            if (!gpuMemoryOnly) {\r\n                this._indices = indices.slice();\r\n            }\r\n            this._engine.updateDynamicIndexBuffer(this._indexBuffer, indices, offset);\r\n            if (needToUpdateSubMeshes) {\r\n                for (const mesh of this._meshes) {\r\n                    mesh._createGlobalSubMesh(true);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the indices to store in the index buffer\r\n     * @param totalVertices defines the total number of vertices (could be null)\r\n     * @param updatable defines if the index buffer must be flagged as updatable (false by default)\r\n     */\r\n    public setIndices(indices: IndicesArray, totalVertices: Nullable<number> = null, updatable: boolean = false): void {\r\n        if (this._indexBuffer) {\r\n            this._engine._releaseBuffer(this._indexBuffer);\r\n        }\r\n\r\n        this._indices = indices;\r\n        this._indexBufferIsUpdatable = updatable;\r\n        if (this._meshes.length !== 0 && this._indices) {\r\n            this._indexBuffer = this._engine.createIndexBuffer(this._indices, updatable);\r\n        }\r\n\r\n        if (totalVertices != undefined) {\r\n            // including null and undefined\r\n            this._totalVertices = totalVertices;\r\n        }\r\n\r\n        for (const mesh of this._meshes) {\r\n            mesh._createGlobalSubMesh(true);\r\n            mesh.synchronizeInstances();\r\n        }\r\n\r\n        this._notifyUpdate();\r\n    }\r\n\r\n    /**\r\n     * Return the total number of indices\r\n     * @returns the total number of indices\r\n     */\r\n    public getTotalIndices(): number {\r\n        if (!this.isReady()) {\r\n            return 0;\r\n        }\r\n        return this._indices.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the index buffer array\r\n     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns the index buffer array\r\n     */\r\n    public getIndices(copyWhenShared?: boolean, forceCopy?: boolean): Nullable<IndicesArray> {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        const orig = this._indices;\r\n        if (!forceCopy && (!copyWhenShared || this._meshes.length === 1)) {\r\n            return orig;\r\n        } else {\r\n            return Tools.Slice(orig);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the index buffer\r\n     * @return the index buffer\r\n     */\r\n    public getIndexBuffer(): Nullable<DataBuffer> {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        return this._indexBuffer;\r\n    }\r\n\r\n    /**\r\n     * @param effect\r\n     * @hidden\r\n     */\r\n    public _releaseVertexArrayObject(effect: Nullable<Effect> = null) {\r\n        if (!effect || !this._vertexArrayObjects) {\r\n            return;\r\n        }\r\n\r\n        if (this._vertexArrayObjects[effect.key]) {\r\n            this._engine.releaseVertexArrayObject(this._vertexArrayObjects[effect.key]);\r\n            delete this._vertexArrayObjects[effect.key];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release the associated resources for a specific mesh\r\n     * @param mesh defines the source mesh\r\n     * @param shouldDispose defines if the geometry must be disposed if there is no more mesh pointing to it\r\n     */\r\n    public releaseForMesh(mesh: Mesh, shouldDispose?: boolean): void {\r\n        const meshes = this._meshes;\r\n        const index = meshes.indexOf(mesh);\r\n\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        meshes.splice(index, 1);\r\n\r\n        if (this._vertexArrayObjects) {\r\n            mesh._invalidateInstanceVertexArrayObject();\r\n        }\r\n\r\n        mesh._geometry = null;\r\n\r\n        if (meshes.length === 0 && shouldDispose) {\r\n            this.dispose();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply current geometry to a given mesh\r\n     * @param mesh defines the mesh to apply geometry to\r\n     */\r\n    public applyToMesh(mesh: Mesh): void {\r\n        if (mesh._geometry === this) {\r\n            return;\r\n        }\r\n\r\n        const previousGeometry = mesh._geometry;\r\n        if (previousGeometry) {\r\n            previousGeometry.releaseForMesh(mesh);\r\n        }\r\n\r\n        if (this._vertexArrayObjects) {\r\n            mesh._invalidateInstanceVertexArrayObject();\r\n        }\r\n\r\n        const meshes = this._meshes;\r\n\r\n        // must be done before setting vertexBuffers because of mesh._createGlobalSubMesh()\r\n        mesh._geometry = this;\r\n        mesh._internalAbstractMeshDataInfo._positions = null;\r\n\r\n        this._scene.pushGeometry(this);\r\n\r\n        meshes.push(mesh);\r\n\r\n        if (this.isReady()) {\r\n            this._applyToMesh(mesh);\r\n        } else if (this._boundingInfo) {\r\n            mesh.setBoundingInfo(this._boundingInfo);\r\n        }\r\n    }\r\n\r\n    private _updateExtend(data: Nullable<FloatArray> = null) {\r\n        if (this.useBoundingInfoFromGeometry && this._boundingInfo) {\r\n            this._extend = {\r\n                minimum: this._boundingInfo.minimum.clone(),\r\n                maximum: this._boundingInfo.maximum.clone(),\r\n            };\r\n        } else {\r\n            if (!data) {\r\n                data = this.getVerticesData(VertexBuffer.PositionKind)!;\r\n                // This can happen if the buffer comes from a Hardware Buffer where\r\n                // The data have not been uploaded by Babylon. (ex: Compute Shaders and Storage Buffers)\r\n                if (!data) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            this._extend = extractMinAndMax(data, 0, this._totalVertices, this.boundingBias, 3);\r\n        }\r\n    }\r\n\r\n    private _applyToMesh(mesh: Mesh): void {\r\n        const numOfMeshes = this._meshes.length;\r\n\r\n        // vertexBuffers\r\n        for (const kind in this._vertexBuffers) {\r\n            if (numOfMeshes === 1) {\r\n                this._vertexBuffers[kind].create();\r\n            }\r\n\r\n            if (kind === VertexBuffer.PositionKind) {\r\n                if (!this._extend) {\r\n                    this._updateExtend();\r\n                }\r\n                mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);\r\n\r\n                mesh._createGlobalSubMesh(false);\r\n\r\n                //bounding info was just created again, world matrix should be applied again.\r\n                mesh._updateBoundingInfo();\r\n            }\r\n        }\r\n\r\n        // indexBuffer\r\n        if (numOfMeshes === 1 && this._indices && this._indices.length > 0) {\r\n            this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable);\r\n        }\r\n\r\n        // morphTargets\r\n        mesh._syncGeometryWithMorphTargetManager();\r\n\r\n        // instances\r\n        mesh.synchronizeInstances();\r\n    }\r\n\r\n    private _notifyUpdate(kind?: string) {\r\n        if (this.onGeometryUpdated) {\r\n            this.onGeometryUpdated(this, kind);\r\n        }\r\n\r\n        if (this._vertexArrayObjects) {\r\n            this._disposeVertexArrayObjects();\r\n        }\r\n\r\n        for (const mesh of this._meshes) {\r\n            mesh._markSubMeshesAsAttributesDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load the geometry if it was flagged as delay loaded\r\n     * @param scene defines the hosting scene\r\n     * @param onLoaded defines a callback called when the geometry is loaded\r\n     */\r\n    public load(scene: Scene, onLoaded?: () => void): void {\r\n        if (this.delayLoadState === Constants.DELAYLOADSTATE_LOADING) {\r\n            return;\r\n        }\r\n\r\n        if (this.isReady()) {\r\n            if (onLoaded) {\r\n                onLoaded();\r\n            }\r\n            return;\r\n        }\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_LOADING;\r\n\r\n        this._queueLoad(scene, onLoaded);\r\n    }\r\n\r\n    private _queueLoad(scene: Scene, onLoaded?: () => void): void {\r\n        if (!this.delayLoadingFile) {\r\n            return;\r\n        }\r\n\r\n        scene._addPendingData(this);\r\n        scene._loadFile(\r\n            this.delayLoadingFile,\r\n            (data) => {\r\n                if (!this._delayLoadingFunction) {\r\n                    return;\r\n                }\r\n\r\n                this._delayLoadingFunction(JSON.parse(data as string), this);\r\n\r\n                this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\r\n                this._delayInfo = [];\r\n\r\n                scene._removePendingData(this);\r\n\r\n                const meshes = this._meshes;\r\n                const numOfMeshes = meshes.length;\r\n                for (let index = 0; index < numOfMeshes; index++) {\r\n                    this._applyToMesh(meshes[index]);\r\n                }\r\n\r\n                if (onLoaded) {\r\n                    onLoaded();\r\n                }\r\n            },\r\n            undefined,\r\n            true\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Invert the geometry to move from a right handed system to a left handed one.\r\n     */\r\n    public toLeftHanded(): void {\r\n        // Flip faces\r\n        const tIndices = this.getIndices(false);\r\n        if (tIndices != null && tIndices.length > 0) {\r\n            for (let i = 0; i < tIndices.length; i += 3) {\r\n                const tTemp = tIndices[i + 0];\r\n                tIndices[i + 0] = tIndices[i + 2];\r\n                tIndices[i + 2] = tTemp;\r\n            }\r\n            this.setIndices(tIndices);\r\n        }\r\n\r\n        // Negate position.z\r\n        const tPositions = this.getVerticesData(VertexBuffer.PositionKind, false);\r\n        if (tPositions != null && tPositions.length > 0) {\r\n            for (let i = 0; i < tPositions.length; i += 3) {\r\n                tPositions[i + 2] = -tPositions[i + 2];\r\n            }\r\n            this.setVerticesData(VertexBuffer.PositionKind, tPositions, false);\r\n        }\r\n\r\n        // Negate normal.z\r\n        const tNormals = this.getVerticesData(VertexBuffer.NormalKind, false);\r\n        if (tNormals != null && tNormals.length > 0) {\r\n            for (let i = 0; i < tNormals.length; i += 3) {\r\n                tNormals[i + 2] = -tNormals[i + 2];\r\n            }\r\n            this.setVerticesData(VertexBuffer.NormalKind, tNormals, false);\r\n        }\r\n    }\r\n\r\n    // Cache\r\n    /** @hidden */\r\n    public _resetPointsArrayCache(): void {\r\n        this._positions = null;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _generatePointsArray(): boolean {\r\n        if (this._positions) {\r\n            return true;\r\n        }\r\n\r\n        const data = this.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n        if (!data || data.length === 0) {\r\n            return false;\r\n        }\r\n\r\n        for (let index = this._positionsCache.length * 3, arrayIdx = this._positionsCache.length; index < data.length; index += 3, ++arrayIdx) {\r\n            this._positionsCache[arrayIdx] = Vector3.FromArray(data, index);\r\n        }\r\n\r\n        for (let index = 0, arrayIdx = 0; index < data.length; index += 3, ++arrayIdx) {\r\n            this._positionsCache[arrayIdx].set(data[0 + index], data[1 + index], data[2 + index]);\r\n        }\r\n\r\n        // just in case the number of positions was reduced, splice the array\r\n        this._positionsCache.length = data.length / 3;\r\n\r\n        this._positions = this._positionsCache;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating if the geometry is disposed\r\n     * @returns true if the geometry was disposed\r\n     */\r\n    public isDisposed(): boolean {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    private _disposeVertexArrayObjects(): void {\r\n        if (this._vertexArrayObjects) {\r\n            for (const kind in this._vertexArrayObjects) {\r\n                this._engine.releaseVertexArrayObject(this._vertexArrayObjects[kind]);\r\n            }\r\n            this._vertexArrayObjects = {}; // Will trigger a rebuild of the VAO if supported\r\n\r\n            const meshes = this._meshes;\r\n            const numOfMeshes = meshes.length;\r\n            for (let index = 0; index < numOfMeshes; index++) {\r\n                meshes[index]._invalidateInstanceVertexArrayObject();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Free all associated resources\r\n     */\r\n    public dispose(): void {\r\n        const meshes = this._meshes;\r\n        const numOfMeshes = meshes.length;\r\n        let index: number;\r\n        for (index = 0; index < numOfMeshes; index++) {\r\n            this.releaseForMesh(meshes[index]);\r\n        }\r\n        this._meshes = [];\r\n\r\n        this._disposeVertexArrayObjects();\r\n\r\n        for (const kind in this._vertexBuffers) {\r\n            this._vertexBuffers[kind].dispose();\r\n        }\r\n        this._vertexBuffers = {};\r\n        this._totalVertices = 0;\r\n\r\n        if (this._indexBuffer) {\r\n            this._engine._releaseBuffer(this._indexBuffer);\r\n        }\r\n        this._indexBuffer = null;\r\n        this._indices = [];\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_NONE;\r\n        this.delayLoadingFile = null;\r\n        this._delayLoadingFunction = null;\r\n        this._delayInfo = [];\r\n\r\n        this._boundingInfo = null;\r\n\r\n        this._scene.removeGeometry(this);\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.geometries.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.geometries.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        this._isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * Clone the current geometry into a new geometry\r\n     * @param id defines the unique ID of the new geometry\r\n     * @returns a new geometry object\r\n     */\r\n    public copy(id: string): Geometry {\r\n        const vertexData = new VertexData();\r\n\r\n        vertexData.indices = [];\r\n\r\n        const indices = this.getIndices();\r\n        if (indices) {\r\n            for (let index = 0; index < indices.length; index++) {\r\n                (<number[]>vertexData.indices).push(indices[index]);\r\n            }\r\n        }\r\n\r\n        let updatable = false;\r\n        let stopChecking = false;\r\n        let kind;\r\n        for (kind in this._vertexBuffers) {\r\n            // using slice() to make a copy of the array and not just reference it\r\n            const data = this.getVerticesData(kind);\r\n\r\n            if (data) {\r\n                if (data instanceof Float32Array) {\r\n                    vertexData.set(new Float32Array(<Float32Array>data), kind);\r\n                } else {\r\n                    vertexData.set((<number[]>data).slice(0), kind);\r\n                }\r\n                if (!stopChecking) {\r\n                    const vb = this.getVertexBuffer(kind);\r\n\r\n                    if (vb) {\r\n                        updatable = vb.isUpdatable();\r\n                        stopChecking = !updatable;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const geometry = new Geometry(id, this._scene, vertexData, updatable);\r\n\r\n        geometry.delayLoadState = this.delayLoadState;\r\n        geometry.delayLoadingFile = this.delayLoadingFile;\r\n        geometry._delayLoadingFunction = this._delayLoadingFunction;\r\n\r\n        for (kind in this._delayInfo) {\r\n            geometry._delayInfo = geometry._delayInfo || [];\r\n            geometry._delayInfo.push(kind);\r\n        }\r\n\r\n        // Bounding info\r\n        geometry._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);\r\n\r\n        return geometry;\r\n    }\r\n\r\n    /**\r\n     * Serialize the current geometry info (and not the vertices data) into a JSON object\r\n     * @return a JSON representation of the current geometry data (without the vertices data)\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.id = this.id;\r\n        serializationObject.uniqueId = this.uniqueId;\r\n        serializationObject.updatable = this._updatable;\r\n\r\n        if (Tags && Tags.HasTags(this)) {\r\n            serializationObject.tags = Tags.GetTags(this);\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private _toNumberArray(origin: Nullable<Float32Array | IndicesArray>): number[] {\r\n        if (Array.isArray(origin)) {\r\n            return origin;\r\n        } else {\r\n            return Array.prototype.slice.call(origin);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release any memory retained by the cached data on the Geometry.\r\n     *\r\n     * Call this function to reduce memory footprint of the mesh.\r\n     * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)\r\n     */\r\n    public clearCachedData(): void {\r\n        this._indices = [];\r\n        this._resetPointsArrayCache();\r\n\r\n        for (const vbName in this._vertexBuffers) {\r\n            if (!Object.prototype.hasOwnProperty.call(this._vertexBuffers, vbName)) {\r\n                continue;\r\n            }\r\n            this._vertexBuffers[vbName]._buffer._data = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serialize all vertices data into a JSON object\r\n     * @returns a JSON representation of the current geometry data\r\n     */\r\n    public serializeVerticeData(): any {\r\n        const serializationObject = this.serialize();\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\r\n            serializationObject.positions = this._toNumberArray(this.getVerticesData(VertexBuffer.PositionKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {\r\n                serializationObject.positions._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            serializationObject.normals = this._toNumberArray(this.getVerticesData(VertexBuffer.NormalKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {\r\n                serializationObject.normals._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            serializationObject.tangents = this._toNumberArray(this.getVerticesData(VertexBuffer.TangentKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.TangentKind)) {\r\n                serializationObject.tangents._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n            serializationObject.uvs = this._toNumberArray(this.getVerticesData(VertexBuffer.UVKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UVKind)) {\r\n                serializationObject.uvs._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n            serializationObject.uv2s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV2Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV2Kind)) {\r\n                serializationObject.uv2s._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\r\n            serializationObject.uv3s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV3Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV3Kind)) {\r\n                serializationObject.uv3s._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\r\n            serializationObject.uv4s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV4Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV4Kind)) {\r\n                serializationObject.uv4s._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\r\n            serializationObject.uv5s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV5Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV5Kind)) {\r\n                serializationObject.uv5s._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\r\n            serializationObject.uv6s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV6Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV6Kind)) {\r\n                serializationObject.uv6s._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            serializationObject.colors = this._toNumberArray(this.getVerticesData(VertexBuffer.ColorKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.ColorKind)) {\r\n                serializationObject.colors._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\r\n            serializationObject.matricesIndices = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesIndicesKind));\r\n            serializationObject.matricesIndices._isExpanded = true;\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.MatricesIndicesKind)) {\r\n                serializationObject.matricesIndices._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\r\n            serializationObject.matricesWeights = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesWeightsKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.MatricesWeightsKind)) {\r\n                serializationObject.matricesWeights._updatable = true;\r\n            }\r\n        }\r\n\r\n        serializationObject.indices = this._toNumberArray(this.getIndices());\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Extracts a clone of a mesh geometry\r\n     * @param mesh defines the source mesh\r\n     * @param id defines the unique ID of the new geometry object\r\n     * @returns the new geometry object\r\n     */\r\n    public static ExtractFromMesh(mesh: Mesh, id: string): Nullable<Geometry> {\r\n        const geometry = mesh._geometry;\r\n\r\n        if (!geometry) {\r\n            return null;\r\n        }\r\n\r\n        return geometry.copy(id);\r\n    }\r\n\r\n    /**\r\n     * You should now use Tools.RandomId(), this method is still here for legacy reasons.\r\n     * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523\r\n     * Be aware Math.random() could cause collisions, but:\r\n     * \"All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide\"\r\n     * @returns a string containing a new GUID\r\n     */\r\n    public static RandomId(): string {\r\n        return Tools.RandomId();\r\n    }\r\n\r\n    private static _GetGeometryByLoadedUniqueId(uniqueId: string, scene: Scene) {\r\n        for (let index = 0; index < scene.geometries.length; index++) {\r\n            if (scene.geometries[index]._loadedUniqueId === uniqueId) {\r\n                return scene.geometries[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @param parsedGeometry\r\n     * @param mesh\r\n     * @hidden\r\n     */\r\n    public static _ImportGeometry(parsedGeometry: any, mesh: Mesh): void {\r\n        const scene = mesh.getScene();\r\n\r\n        // Geometry\r\n        const geometryUniqueId = parsedGeometry.geometryUniqueId;\r\n        const geometryId = parsedGeometry.geometryId;\r\n        if (geometryUniqueId || geometryId) {\r\n            const geometry = geometryUniqueId ? this._GetGeometryByLoadedUniqueId(geometryUniqueId, scene) : scene.getGeometryById(geometryId);\r\n            if (geometry) {\r\n                geometry.applyToMesh(mesh);\r\n            }\r\n        } else if (parsedGeometry instanceof ArrayBuffer) {\r\n            const binaryInfo = mesh._binaryInfo;\r\n\r\n            if (binaryInfo.positionsAttrDesc && binaryInfo.positionsAttrDesc.count > 0) {\r\n                const positionsData = new Float32Array(parsedGeometry, binaryInfo.positionsAttrDesc.offset, binaryInfo.positionsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.PositionKind, positionsData, false);\r\n            }\r\n\r\n            if (binaryInfo.normalsAttrDesc && binaryInfo.normalsAttrDesc.count > 0) {\r\n                const normalsData = new Float32Array(parsedGeometry, binaryInfo.normalsAttrDesc.offset, binaryInfo.normalsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.NormalKind, normalsData, false);\r\n            }\r\n\r\n            if (binaryInfo.tangetsAttrDesc && binaryInfo.tangetsAttrDesc.count > 0) {\r\n                const tangentsData = new Float32Array(parsedGeometry, binaryInfo.tangetsAttrDesc.offset, binaryInfo.tangetsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.TangentKind, tangentsData, false);\r\n            }\r\n\r\n            if (binaryInfo.uvsAttrDesc && binaryInfo.uvsAttrDesc.count > 0) {\r\n                const uvsData = new Float32Array(parsedGeometry, binaryInfo.uvsAttrDesc.offset, binaryInfo.uvsAttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvsData.length; index += 2) {\r\n                        uvsData[index] = 1 - uvsData[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UVKind, uvsData, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs2AttrDesc && binaryInfo.uvs2AttrDesc.count > 0) {\r\n                const uvs2Data = new Float32Array(parsedGeometry, binaryInfo.uvs2AttrDesc.offset, binaryInfo.uvs2AttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvs2Data.length; index += 2) {\r\n                        uvs2Data[index] = 1 - uvs2Data[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UV2Kind, uvs2Data, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs3AttrDesc && binaryInfo.uvs3AttrDesc.count > 0) {\r\n                const uvs3Data = new Float32Array(parsedGeometry, binaryInfo.uvs3AttrDesc.offset, binaryInfo.uvs3AttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvs3Data.length; index += 2) {\r\n                        uvs3Data[index] = 1 - uvs3Data[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UV3Kind, uvs3Data, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs4AttrDesc && binaryInfo.uvs4AttrDesc.count > 0) {\r\n                const uvs4Data = new Float32Array(parsedGeometry, binaryInfo.uvs4AttrDesc.offset, binaryInfo.uvs4AttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvs4Data.length; index += 2) {\r\n                        uvs4Data[index] = 1 - uvs4Data[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UV4Kind, uvs4Data, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs5AttrDesc && binaryInfo.uvs5AttrDesc.count > 0) {\r\n                const uvs5Data = new Float32Array(parsedGeometry, binaryInfo.uvs5AttrDesc.offset, binaryInfo.uvs5AttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvs5Data.length; index += 2) {\r\n                        uvs5Data[index] = 1 - uvs5Data[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UV5Kind, uvs5Data, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs6AttrDesc && binaryInfo.uvs6AttrDesc.count > 0) {\r\n                const uvs6Data = new Float32Array(parsedGeometry, binaryInfo.uvs6AttrDesc.offset, binaryInfo.uvs6AttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvs6Data.length; index += 2) {\r\n                        uvs6Data[index] = 1 - uvs6Data[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UV6Kind, uvs6Data, false);\r\n            }\r\n\r\n            if (binaryInfo.colorsAttrDesc && binaryInfo.colorsAttrDesc.count > 0) {\r\n                const colorsData = new Float32Array(parsedGeometry, binaryInfo.colorsAttrDesc.offset, binaryInfo.colorsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.ColorKind, colorsData, false, binaryInfo.colorsAttrDesc.stride);\r\n            }\r\n\r\n            if (binaryInfo.matricesIndicesAttrDesc && binaryInfo.matricesIndicesAttrDesc.count > 0) {\r\n                const matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesAttrDesc.offset, binaryInfo.matricesIndicesAttrDesc.count);\r\n                const floatIndices = [];\r\n                for (let i = 0; i < matricesIndicesData.length; i++) {\r\n                    const index = matricesIndicesData[i];\r\n                    floatIndices.push(index & 0x000000ff);\r\n                    floatIndices.push((index & 0x0000ff00) >> 8);\r\n                    floatIndices.push((index & 0x00ff0000) >> 16);\r\n                    floatIndices.push((index >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, false);\r\n            }\r\n\r\n            if (binaryInfo.matricesIndicesExtraAttrDesc && binaryInfo.matricesIndicesExtraAttrDesc.count > 0) {\r\n                const matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesExtraAttrDesc.offset, binaryInfo.matricesIndicesExtraAttrDesc.count);\r\n                const floatIndices = [];\r\n                for (let i = 0; i < matricesIndicesData.length; i++) {\r\n                    const index = matricesIndicesData[i];\r\n                    floatIndices.push(index & 0x000000ff);\r\n                    floatIndices.push((index & 0x0000ff00) >> 8);\r\n                    floatIndices.push((index & 0x00ff0000) >> 16);\r\n                    floatIndices.push((index >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, false);\r\n            }\r\n\r\n            if (binaryInfo.matricesWeightsAttrDesc && binaryInfo.matricesWeightsAttrDesc.count > 0) {\r\n                const matricesWeightsData = new Float32Array(parsedGeometry, binaryInfo.matricesWeightsAttrDesc.offset, binaryInfo.matricesWeightsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsData, false);\r\n            }\r\n\r\n            if (binaryInfo.indicesAttrDesc && binaryInfo.indicesAttrDesc.count > 0) {\r\n                const indicesData = new Int32Array(parsedGeometry, binaryInfo.indicesAttrDesc.offset, binaryInfo.indicesAttrDesc.count);\r\n                mesh.setIndices(indicesData, null);\r\n            }\r\n\r\n            if (binaryInfo.subMeshesAttrDesc && binaryInfo.subMeshesAttrDesc.count > 0) {\r\n                const subMeshesData = new Int32Array(parsedGeometry, binaryInfo.subMeshesAttrDesc.offset, binaryInfo.subMeshesAttrDesc.count * 5);\r\n\r\n                mesh.subMeshes = [];\r\n                for (let i = 0; i < binaryInfo.subMeshesAttrDesc.count; i++) {\r\n                    const materialIndex = subMeshesData[i * 5 + 0];\r\n                    const verticesStart = subMeshesData[i * 5 + 1];\r\n                    const verticesCount = subMeshesData[i * 5 + 2];\r\n                    const indexStart = subMeshesData[i * 5 + 3];\r\n                    const indexCount = subMeshesData[i * 5 + 4];\r\n\r\n                    SubMesh.AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, <AbstractMesh>mesh);\r\n                }\r\n            }\r\n        } else if (parsedGeometry.positions && parsedGeometry.normals && parsedGeometry.indices) {\r\n            mesh.setVerticesData(VertexBuffer.PositionKind, parsedGeometry.positions, parsedGeometry.positions._updatable);\r\n\r\n            mesh.setVerticesData(VertexBuffer.NormalKind, parsedGeometry.normals, parsedGeometry.normals._updatable);\r\n\r\n            if (parsedGeometry.tangents) {\r\n                mesh.setVerticesData(VertexBuffer.TangentKind, parsedGeometry.tangents, parsedGeometry.tangents._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs) {\r\n                mesh.setVerticesData(VertexBuffer.UVKind, parsedGeometry.uvs, parsedGeometry.uvs._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs2) {\r\n                mesh.setVerticesData(VertexBuffer.UV2Kind, parsedGeometry.uvs2, parsedGeometry.uvs2._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs3) {\r\n                mesh.setVerticesData(VertexBuffer.UV3Kind, parsedGeometry.uvs3, parsedGeometry.uvs3._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs4) {\r\n                mesh.setVerticesData(VertexBuffer.UV4Kind, parsedGeometry.uvs4, parsedGeometry.uvs4._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs5) {\r\n                mesh.setVerticesData(VertexBuffer.UV5Kind, parsedGeometry.uvs5, parsedGeometry.uvs5._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs6) {\r\n                mesh.setVerticesData(VertexBuffer.UV6Kind, parsedGeometry.uvs6, parsedGeometry.uvs6._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.colors) {\r\n                mesh.setVerticesData(VertexBuffer.ColorKind, Color4.CheckColors4(parsedGeometry.colors, parsedGeometry.positions.length / 3), parsedGeometry.colors._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.matricesIndices) {\r\n                if (!parsedGeometry.matricesIndices._isExpanded) {\r\n                    const floatIndices = [];\r\n\r\n                    for (let i = 0; i < parsedGeometry.matricesIndices.length; i++) {\r\n                        const matricesIndex = parsedGeometry.matricesIndices[i];\r\n\r\n                        floatIndices.push(matricesIndex & 0x000000ff);\r\n                        floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\r\n                        floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\r\n                        floatIndices.push((matricesIndex >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                    }\r\n\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, parsedGeometry.matricesIndices._updatable);\r\n                } else {\r\n                    delete parsedGeometry.matricesIndices._isExpanded;\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, parsedGeometry.matricesIndices, parsedGeometry.matricesIndices._updatable);\r\n                }\r\n            }\r\n\r\n            if (parsedGeometry.matricesIndicesExtra) {\r\n                if (!parsedGeometry.matricesIndicesExtra._isExpanded) {\r\n                    const floatIndices = [];\r\n\r\n                    for (let i = 0; i < parsedGeometry.matricesIndicesExtra.length; i++) {\r\n                        const matricesIndex = parsedGeometry.matricesIndicesExtra[i];\r\n\r\n                        floatIndices.push(matricesIndex & 0x000000ff);\r\n                        floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\r\n                        floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\r\n                        floatIndices.push((matricesIndex >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                    }\r\n\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, parsedGeometry.matricesIndicesExtra._updatable);\r\n                } else {\r\n                    delete parsedGeometry.matricesIndices._isExpanded;\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, parsedGeometry.matricesIndicesExtra, parsedGeometry.matricesIndicesExtra._updatable);\r\n                }\r\n            }\r\n\r\n            if (parsedGeometry.matricesWeights) {\r\n                Geometry._CleanMatricesWeights(parsedGeometry, mesh);\r\n                mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, parsedGeometry.matricesWeights, parsedGeometry.matricesWeights._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.matricesWeightsExtra) {\r\n                mesh.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, parsedGeometry.matricesWeightsExtra, parsedGeometry.matricesWeights._updatable);\r\n            }\r\n\r\n            mesh.setIndices(parsedGeometry.indices, null);\r\n        }\r\n\r\n        // SubMeshes\r\n        if (parsedGeometry.subMeshes) {\r\n            mesh.subMeshes = [];\r\n            for (let subIndex = 0; subIndex < parsedGeometry.subMeshes.length; subIndex++) {\r\n                const parsedSubMesh = parsedGeometry.subMeshes[subIndex];\r\n\r\n                SubMesh.AddToMesh(\r\n                    parsedSubMesh.materialIndex,\r\n                    parsedSubMesh.verticesStart,\r\n                    parsedSubMesh.verticesCount,\r\n                    parsedSubMesh.indexStart,\r\n                    parsedSubMesh.indexCount,\r\n                    <AbstractMesh>mesh\r\n                );\r\n            }\r\n        }\r\n\r\n        // Flat shading\r\n        if (mesh._shouldGenerateFlatShading) {\r\n            mesh.convertToFlatShadedMesh();\r\n            mesh._shouldGenerateFlatShading = false;\r\n        }\r\n\r\n        // Update\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        scene.onMeshImportedObservable.notifyObservers(<AbstractMesh>mesh);\r\n    }\r\n\r\n    private static _CleanMatricesWeights(parsedGeometry: any, mesh: Mesh): void {\r\n        const epsilon: number = 1e-3;\r\n        if (!SceneLoaderFlags.CleanBoneMatrixWeights) {\r\n            return;\r\n        }\r\n        let noInfluenceBoneIndex = 0.0;\r\n        if (parsedGeometry.skeletonId > -1) {\r\n            const skeleton = mesh.getScene().getLastSkeletonById(parsedGeometry.skeletonId);\r\n\r\n            if (!skeleton) {\r\n                return;\r\n            }\r\n            noInfluenceBoneIndex = skeleton.bones.length;\r\n        } else {\r\n            return;\r\n        }\r\n        const matricesIndices = <FloatArray>mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);\r\n        const matricesIndicesExtra = <FloatArray>mesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);\r\n        const matricesWeights = parsedGeometry.matricesWeights;\r\n        const matricesWeightsExtra = parsedGeometry.matricesWeightsExtra;\r\n        const influencers = parsedGeometry.numBoneInfluencer;\r\n        const size = matricesWeights.length;\r\n\r\n        for (let i = 0; i < size; i += 4) {\r\n            let weight = 0.0;\r\n            let firstZeroWeight = -1;\r\n            for (let j = 0; j < 4; j++) {\r\n                const w = matricesWeights[i + j];\r\n                weight += w;\r\n                if (w < epsilon && firstZeroWeight < 0) {\r\n                    firstZeroWeight = j;\r\n                }\r\n            }\r\n            if (matricesWeightsExtra) {\r\n                for (let j = 0; j < 4; j++) {\r\n                    const w = matricesWeightsExtra[i + j];\r\n                    weight += w;\r\n                    if (w < epsilon && firstZeroWeight < 0) {\r\n                        firstZeroWeight = j + 4;\r\n                    }\r\n                }\r\n            }\r\n            if (firstZeroWeight < 0 || firstZeroWeight > influencers - 1) {\r\n                firstZeroWeight = influencers - 1;\r\n            }\r\n            if (weight > epsilon) {\r\n                const mweight = 1.0 / weight;\r\n                for (let j = 0; j < 4; j++) {\r\n                    matricesWeights[i + j] *= mweight;\r\n                }\r\n                if (matricesWeightsExtra) {\r\n                    for (let j = 0; j < 4; j++) {\r\n                        matricesWeightsExtra[i + j] *= mweight;\r\n                    }\r\n                }\r\n            } else {\r\n                if (firstZeroWeight >= 4) {\r\n                    matricesWeightsExtra[i + firstZeroWeight - 4] = 1.0 - weight;\r\n                    matricesIndicesExtra[i + firstZeroWeight - 4] = noInfluenceBoneIndex;\r\n                } else {\r\n                    matricesWeights[i + firstZeroWeight] = 1.0 - weight;\r\n                    matricesIndices[i + firstZeroWeight] = noInfluenceBoneIndex;\r\n                }\r\n            }\r\n        }\r\n\r\n        mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, matricesIndices);\r\n        if (parsedGeometry.matricesWeightsExtra) {\r\n            mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, matricesIndicesExtra);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new geometry from persisted data (Using .babylon file format)\r\n     * @param parsedVertexData defines the persisted data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root url to use to load assets (like delayed data)\r\n     * @returns the new geometry object\r\n     */\r\n    public static Parse(parsedVertexData: any, scene: Scene, rootUrl: string): Nullable<Geometry> {\r\n        const geometry = new Geometry(parsedVertexData.id, scene, undefined, parsedVertexData.updatable);\r\n        geometry._loadedUniqueId = parsedVertexData.uniqueId;\r\n\r\n        if (Tags) {\r\n            Tags.AddTagsTo(geometry, parsedVertexData.tags);\r\n        }\r\n\r\n        if (parsedVertexData.delayLoadingFile) {\r\n            geometry.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n            geometry.delayLoadingFile = rootUrl + parsedVertexData.delayLoadingFile;\r\n            geometry._boundingInfo = new BoundingInfo(Vector3.FromArray(parsedVertexData.boundingBoxMinimum), Vector3.FromArray(parsedVertexData.boundingBoxMaximum));\r\n\r\n            geometry._delayInfo = [];\r\n            if (parsedVertexData.hasUVs) {\r\n                geometry._delayInfo.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs2) {\r\n                geometry._delayInfo.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs3) {\r\n                geometry._delayInfo.push(VertexBuffer.UV3Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs4) {\r\n                geometry._delayInfo.push(VertexBuffer.UV4Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs5) {\r\n                geometry._delayInfo.push(VertexBuffer.UV5Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs6) {\r\n                geometry._delayInfo.push(VertexBuffer.UV6Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasColors) {\r\n                geometry._delayInfo.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            if (parsedVertexData.hasMatricesIndices) {\r\n                geometry._delayInfo.push(VertexBuffer.MatricesIndicesKind);\r\n            }\r\n\r\n            if (parsedVertexData.hasMatricesWeights) {\r\n                geometry._delayInfo.push(VertexBuffer.MatricesWeightsKind);\r\n            }\r\n\r\n            geometry._delayLoadingFunction = VertexData.ImportVertexData;\r\n        } else {\r\n            VertexData.ImportVertexData(parsedVertexData, geometry);\r\n        }\r\n\r\n        scene.pushGeometry(geometry, true);\r\n\r\n        return geometry;\r\n    }\r\n}\r\n"]}