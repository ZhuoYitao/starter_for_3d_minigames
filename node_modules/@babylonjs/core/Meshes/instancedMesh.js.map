{"version":3,"file":"instancedMesh.js","sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/instancedMesh.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport { Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Node } from \"../node\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { Skeleton } from \"../Bones/skeleton\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport { TransformNode } from \"./transformNode\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\nMesh._instancedMeshFactory = (name: string, mesh: Mesh): InstancedMesh => {\r\n    const instance = new InstancedMesh(name, mesh);\r\n\r\n    if (mesh.instancedBuffers) {\r\n        instance.instancedBuffers = {};\r\n\r\n        for (const key in mesh.instancedBuffers) {\r\n            instance.instancedBuffers[key] = mesh.instancedBuffers[key];\r\n        }\r\n    }\r\n\r\n    return instance;\r\n};\r\n\r\n/**\r\n * Creates an instance based on a source mesh.\r\n */\r\nexport class InstancedMesh extends AbstractMesh {\r\n    private _sourceMesh: Mesh;\r\n    private _currentLOD: Mesh;\r\n    private _billboardWorldMatrix: Matrix;\r\n\r\n    /** @hidden */\r\n    public _indexInSourceMeshInstanceArray = -1;\r\n    /** @hidden */\r\n    public _distanceToCamera: number = 0;\r\n    /** @hidden */\r\n    public _previousWorldMatrix: Nullable<Matrix>;\r\n\r\n    constructor(name: string, source: Mesh) {\r\n        super(name, source.getScene());\r\n\r\n        source.addInstance(this);\r\n\r\n        this._sourceMesh = source;\r\n\r\n        this._unIndexed = source._unIndexed;\r\n\r\n        this.position.copyFrom(source.position);\r\n        this.rotation.copyFrom(source.rotation);\r\n        this.scaling.copyFrom(source.scaling);\r\n\r\n        if (source.rotationQuaternion) {\r\n            this.rotationQuaternion = source.rotationQuaternion.clone();\r\n        }\r\n\r\n        this.animations = Tools.Slice(source.animations);\r\n        for (const range of source.getAnimationRanges()) {\r\n            if (range != null) {\r\n                this.createAnimationRange(range.name, range.from, range.to);\r\n            }\r\n        }\r\n\r\n        this.infiniteDistance = source.infiniteDistance;\r\n\r\n        this.setPivotMatrix(source.getPivotMatrix());\r\n\r\n        this.refreshBoundingInfo(true, true);\r\n        this._syncSubMeshes();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"InstancedMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"InstancedMesh\";\r\n    }\r\n\r\n    /** Gets the list of lights affecting that mesh */\r\n    public get lightSources(): Light[] {\r\n        return this._sourceMesh._lightSources;\r\n    }\r\n\r\n    public _resyncLightSources(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    public _resyncLightSource(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    public _removeLightSource(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * If the source mesh receives shadows\r\n     */\r\n    public get receiveShadows(): boolean {\r\n        return this._sourceMesh.receiveShadows;\r\n    }\r\n\r\n    /**\r\n     * The material of the source mesh\r\n     */\r\n    public get material(): Nullable<Material> {\r\n        return this._sourceMesh.material;\r\n    }\r\n\r\n    /**\r\n     * Visibility of the source mesh\r\n     */\r\n    public get visibility(): number {\r\n        return this._sourceMesh.visibility;\r\n    }\r\n\r\n    /**\r\n     * Skeleton of the source mesh\r\n     */\r\n    public get skeleton(): Nullable<Skeleton> {\r\n        return this._sourceMesh.skeleton;\r\n    }\r\n\r\n    /**\r\n     * Rendering ground id of the source mesh\r\n     */\r\n    public get renderingGroupId(): number {\r\n        return this._sourceMesh.renderingGroupId;\r\n    }\r\n\r\n    public set renderingGroupId(value: number) {\r\n        if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {\r\n            return;\r\n        }\r\n\r\n        //no-op with warning\r\n        Logger.Warn(\"Note - setting renderingGroupId of an instanced mesh has no effect on the scene\");\r\n    }\r\n\r\n    /**\r\n     * Returns the total number of vertices (integer).\r\n     */\r\n    public getTotalVertices(): number {\r\n        return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;\r\n    }\r\n\r\n    /**\r\n     * Returns a positive integer : the total number of indices in this mesh geometry.\r\n     * @returns the number of indices or zero if the mesh has no geometry.\r\n     */\r\n    public getTotalIndices(): number {\r\n        return this._sourceMesh.getTotalIndices();\r\n    }\r\n\r\n    /**\r\n     * The source mesh of the instance\r\n     */\r\n    public get sourceMesh(): Mesh {\r\n        return this._sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedMesh\r\n     */\r\n    public createInstance(name: string): InstancedMesh {\r\n        return this._sourceMesh.createInstance(name);\r\n    }\r\n\r\n    /**\r\n     * Is this node ready to be used/rendered\r\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\r\n     * @return {boolean} is it ready\r\n     */\r\n    public isReady(completeCheck = false): boolean {\r\n        return this._sourceMesh.isReady(completeCheck, true);\r\n    }\r\n\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param kind kind of verticies to retrieve (eg. positions, normals, uvs, etc.)\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @returns a float array or a Float32Array of the requested kind of data : positions, normals, uvs, etc.\r\n     */\r\n    public getVerticesData(kind: string, copyWhenShared?: boolean): Nullable<FloatArray> {\r\n        return this._sourceMesh.getVerticesData(kind, copyWhenShared);\r\n    }\r\n\r\n    /**\r\n     * Sets the vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initially none) or updater.\r\n     * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).\r\n     * Note that a new underlying VertexBuffer object is created each call.\r\n     * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     * @param kind\r\n     * @param data\r\n     * @param updatable\r\n     * @param stride\r\n     */\r\n    public setVerticesData(kind: string, data: FloatArray, updatable?: boolean, stride?: number): AbstractMesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setVerticesData(kind, data, updatable, stride);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Updates the existing vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, it is simply returned as it is.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * No new underlying VertexBuffer object is created.\r\n     * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     * @param kind\r\n     * @param data\r\n     * @param updateExtends\r\n     * @param makeItUnique\r\n     */\r\n    public updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): Mesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh indices.\r\n     * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).\r\n     * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\r\n     * This method creates a new index buffer each call.\r\n     * Returns the Mesh.\r\n     * @param indices\r\n     * @param totalVertices\r\n     */\r\n    public setIndices(indices: IndicesArray, totalVertices: Nullable<number> = null): Mesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setIndices(indices, totalVertices);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Boolean : True if the mesh owns the requested kind of data.\r\n     * @param kind\r\n     */\r\n    public isVerticesDataPresent(kind: string): boolean {\r\n        return this._sourceMesh.isVerticesDataPresent(kind);\r\n    }\r\n\r\n    /**\r\n     * Returns an array of indices (IndicesArray).\r\n     */\r\n    public getIndices(): Nullable<IndicesArray> {\r\n        return this._sourceMesh.getIndices();\r\n    }\r\n\r\n    public get _positions(): Nullable<Vector3[]> {\r\n        return this._sourceMesh._positions;\r\n    }\r\n\r\n    /**\r\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\r\n     * This means the mesh underlying bounding box and sphere are recomputed.\r\n     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n     * @param applyMorph  defines whether to apply the morph target before computing the bounding info\r\n     * @returns the current mesh\r\n     */\r\n    public refreshBoundingInfo(applySkeleton: boolean = false, applyMorph: boolean = false): InstancedMesh {\r\n        if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {\r\n            return this;\r\n        }\r\n\r\n        const bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;\r\n        this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton, applyMorph), bias);\r\n        return this;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _preActivate(): InstancedMesh {\r\n        if (this._currentLOD) {\r\n            this._currentLOD._preActivate();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param renderId\r\n     * @param intermediateRendering\r\n     * @hidden\r\n     */\r\n    public _activate(renderId: number, intermediateRendering: boolean): boolean {\r\n        if (!this._sourceMesh.subMeshes) {\r\n            Logger.Warn(\"Instances should only be created for meshes with geometry.\");\r\n        }\r\n\r\n        if (this._currentLOD) {\r\n            const differentSign = this._currentLOD._getWorldMatrixDeterminant() >= 0 !== this._getWorldMatrixDeterminant() >= 0;\r\n            if (differentSign) {\r\n                this._internalAbstractMeshDataInfo._actAsRegularMesh = true;\r\n                return true;\r\n            }\r\n            this._internalAbstractMeshDataInfo._actAsRegularMesh = false;\r\n\r\n            this._currentLOD._registerInstanceForRenderId(this, renderId);\r\n\r\n            if (intermediateRendering) {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;\r\n                    return true;\r\n                }\r\n            } else {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _postActivate(): void {\r\n        if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer of the source mesh\r\n            this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);\r\n            this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());\r\n        } else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer defined for this instance\r\n            this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);\r\n        }\r\n    }\r\n\r\n    public getWorldMatrix(): Matrix {\r\n        if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {\r\n            if (!this._billboardWorldMatrix) {\r\n                this._billboardWorldMatrix = new Matrix();\r\n            }\r\n            const tempMaster = this._currentLOD._masterMesh;\r\n            this._currentLOD._masterMesh = this;\r\n            TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);\r\n            this._currentLOD.position.set(0, 0, 0);\r\n            this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(true));\r\n            this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);\r\n            this._currentLOD._masterMesh = tempMaster;\r\n            return this._billboardWorldMatrix;\r\n        }\r\n\r\n        return super.getWorldMatrix();\r\n    }\r\n\r\n    public get isAnInstance(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns the current associated LOD AbstractMesh.\r\n     * @param camera\r\n     */\r\n    public getLOD(camera: Camera): AbstractMesh {\r\n        if (!camera) {\r\n            return this;\r\n        }\r\n\r\n        const sourceMeshLODLevels = this.sourceMesh.getLODLevels();\r\n        if (!sourceMeshLODLevels || sourceMeshLODLevels.length === 0) {\r\n            this._currentLOD = this.sourceMesh;\r\n        } else {\r\n            const boundingInfo = this.getBoundingInfo();\r\n            this._currentLOD = <Mesh>this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);\r\n        }\r\n\r\n        return this._currentLOD;\r\n    }\r\n\r\n    /**\r\n     * @param renderId\r\n     * @hidden\r\n     */\r\n    public _preActivateForIntermediateRendering(renderId: number): Mesh {\r\n        return <Mesh>this.sourceMesh._preActivateForIntermediateRendering(renderId);\r\n    }\r\n\r\n    /** @hidden */\r\n    public _syncSubMeshes(): InstancedMesh {\r\n        this.releaseSubMeshes();\r\n        if (this._sourceMesh.subMeshes) {\r\n            for (let index = 0; index < this._sourceMesh.subMeshes.length; index++) {\r\n                this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _generatePointsArray(): boolean {\r\n        return this._sourceMesh._generatePointsArray();\r\n    }\r\n\r\n    /** @hidden */\r\n    public _updateBoundingInfo(): AbstractMesh {\r\n        if (this.hasBoundingInfo) {\r\n            this.getBoundingInfo().update(this.worldMatrixFromCache);\r\n        } else {\r\n            this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache);\r\n        }\r\n        this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedMesh from the current mesh.\r\n     * - name (string) : the cloned mesh name\r\n     * - newParent (optional Node) : the optional Node to parent the clone to.\r\n     * - doNotCloneChildren (optional boolean, default `false`) : if `true` the model children aren't cloned.\r\n     *\r\n     * Returns the clone.\r\n     * @param name\r\n     * @param newParent\r\n     * @param doNotCloneChildren\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null, doNotCloneChildren?: boolean): InstancedMesh {\r\n        const result = this._sourceMesh.createInstance(name);\r\n\r\n        // Deep copy\r\n        DeepCopier.DeepCopy(\r\n            this,\r\n            result,\r\n            [\r\n                \"name\",\r\n                \"subMeshes\",\r\n                \"uniqueId\",\r\n                \"parent\",\r\n                \"lightSources\",\r\n                \"receiveShadows\",\r\n                \"material\",\r\n                \"visibility\",\r\n                \"skeleton\",\r\n                \"sourceMesh\",\r\n                \"isAnInstance\",\r\n                \"facetNb\",\r\n                \"isFacetDataEnabled\",\r\n                \"isBlocked\",\r\n                \"useBones\",\r\n                \"hasInstances\",\r\n                \"collider\",\r\n                \"edgesRenderer\",\r\n                \"forward\",\r\n                \"up\",\r\n                \"right\",\r\n                \"absolutePosition\",\r\n                \"absoluteScaling\",\r\n                \"absoluteRotationQuaternion\",\r\n                \"isWorldMatrixFrozen\",\r\n                \"nonUniformScaling\",\r\n                \"behaviors\",\r\n                \"worldMatrixFromCache\",\r\n                \"hasThinInstances\",\r\n            ],\r\n            []\r\n        );\r\n\r\n        // Bounding info\r\n        this.refreshBoundingInfo();\r\n\r\n        // Parent\r\n        if (newParent) {\r\n            result.parent = newParent;\r\n        }\r\n\r\n        if (!doNotCloneChildren) {\r\n            // Children\r\n            for (let index = 0; index < this.getScene().meshes.length; index++) {\r\n                const mesh = this.getScene().meshes[index];\r\n\r\n                if (mesh.parent === this) {\r\n                    mesh.clone(mesh.name, result);\r\n                }\r\n            }\r\n        }\r\n\r\n        result.computeWorldMatrix(true);\r\n\r\n        this.onClonedObservable.notifyObservers(result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Disposes the InstancedMesh.\r\n     * Returns nothing.\r\n     * @param doNotRecurse\r\n     * @param disposeMaterialAndTextures\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        // Remove from mesh\r\n        this._sourceMesh.removeInstance(this);\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n}\r\n\r\ndeclare module \"./mesh\" {\r\n    export interface Mesh {\r\n        /**\r\n         * Register a custom buffer that will be instanced\r\n         * @see https://doc.babylonjs.com/how_to/how_to_use_instances#custom-buffers\r\n         * @param kind defines the buffer kind\r\n         * @param stride defines the stride in floats\r\n         */\r\n        registerInstancedBuffer(kind: string, stride: number): void;\r\n\r\n        /**\r\n         * Invalidate VertexArrayObjects belonging to the mesh (but not to the Geometry of the mesh).\r\n         */\r\n        _invalidateInstanceVertexArrayObject(): void;\r\n\r\n        /**\r\n         * true to use the edge renderer for all instances of this mesh\r\n         */\r\n        edgesShareWithInstances: boolean;\r\n\r\n        /** @hidden */\r\n        _userInstancedBuffersStorage: {\r\n            data: { [key: string]: Float32Array };\r\n            sizes: { [key: string]: number };\r\n            vertexBuffers: { [key: string]: Nullable<VertexBuffer> };\r\n            strides: { [key: string]: number };\r\n            vertexArrayObjects?: { [key: string]: WebGLVertexArrayObject };\r\n        };\r\n    }\r\n}\r\n\r\ndeclare module \"./abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /**\r\n         * Object used to store instanced buffers defined by user\r\n         * @see https://doc.babylonjs.com/how_to/how_to_use_instances#custom-buffers\r\n         */\r\n        instancedBuffers: { [key: string]: any };\r\n    }\r\n}\r\n\r\nMesh.prototype.registerInstancedBuffer = function (kind: string, stride: number): void {\r\n    // Remove existing one\r\n    this._userInstancedBuffersStorage?.vertexBuffers[kind]?.dispose();\r\n\r\n    // Creates the instancedBuffer field if not present\r\n    if (!this.instancedBuffers) {\r\n        this.instancedBuffers = {};\r\n\r\n        for (const instance of this.instances) {\r\n            instance.instancedBuffers = {};\r\n        }\r\n\r\n        this._userInstancedBuffersStorage = {\r\n            data: {},\r\n            vertexBuffers: {},\r\n            strides: {},\r\n            sizes: {},\r\n            vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : undefined,\r\n        };\r\n    }\r\n\r\n    // Creates an empty property for this kind\r\n    this.instancedBuffers[kind] = null;\r\n\r\n    this._userInstancedBuffersStorage.strides[kind] = stride;\r\n    this._userInstancedBuffersStorage.sizes[kind] = stride * 32; // Initial size\r\n    this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);\r\n    this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\r\n\r\n    for (const instance of this.instances) {\r\n        instance.instancedBuffers[kind] = null;\r\n    }\r\n\r\n    this._invalidateInstanceVertexArrayObject();\r\n};\r\n\r\nMesh.prototype._processInstancedBuffers = function (visibleInstances: InstancedMesh[], renderSelf: boolean) {\r\n    const instanceCount = visibleInstances.length;\r\n\r\n    for (const kind in this.instancedBuffers) {\r\n        let size = this._userInstancedBuffersStorage.sizes[kind];\r\n        const stride = this._userInstancedBuffersStorage.strides[kind];\r\n\r\n        // Resize if required\r\n        const expectedSize = (instanceCount + 1) * stride;\r\n\r\n        while (size < expectedSize) {\r\n            size *= 2;\r\n        }\r\n\r\n        if (this._userInstancedBuffersStorage.data[kind].length != size) {\r\n            this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);\r\n            this._userInstancedBuffersStorage.sizes[kind] = size;\r\n            if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind]!.dispose();\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\r\n            }\r\n        }\r\n\r\n        const data = this._userInstancedBuffersStorage.data[kind];\r\n\r\n        // Update data buffer\r\n        let offset = 0;\r\n        if (renderSelf) {\r\n            const value = this.instancedBuffers[kind];\r\n\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            } else if (value.copyToArray) {\r\n                value.copyToArray(data, offset);\r\n            } else {\r\n                data[offset] = value;\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n\r\n        for (let instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {\r\n            const instance = visibleInstances[instanceIndex]!;\r\n\r\n            const value = instance.instancedBuffers[kind];\r\n\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            } else if (value.copyToArray) {\r\n                value.copyToArray(data, offset);\r\n            } else {\r\n                data[offset] = value;\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n\r\n        // Update vertex buffer\r\n        if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(\r\n                this.getEngine(),\r\n                this._userInstancedBuffersStorage.data[kind],\r\n                kind,\r\n                true,\r\n                false,\r\n                stride,\r\n                true\r\n            );\r\n            this._invalidateInstanceVertexArrayObject();\r\n        } else {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind]!.updateDirectly(data, 0);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype._invalidateInstanceVertexArrayObject = function () {\r\n    if (!this._userInstancedBuffersStorage || this._userInstancedBuffersStorage.vertexArrayObjects === undefined) {\r\n        return;\r\n    }\r\n\r\n    for (const kind in this._userInstancedBuffersStorage.vertexArrayObjects) {\r\n        this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[kind]);\r\n    }\r\n\r\n    this._userInstancedBuffersStorage.vertexArrayObjects = {};\r\n};\r\n\r\nMesh.prototype._disposeInstanceSpecificData = function () {\r\n    if (this._instanceDataStorage.instancesBuffer) {\r\n        this._instanceDataStorage.instancesBuffer.dispose();\r\n        this._instanceDataStorage.instancesBuffer = null;\r\n    }\r\n\r\n    while (this.instances.length) {\r\n        this.instances[0].dispose();\r\n    }\r\n\r\n    for (const kind in this.instancedBuffers) {\r\n        if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind]!.dispose();\r\n        }\r\n    }\r\n\r\n    this._invalidateInstanceVertexArrayObject();\r\n\r\n    this.instancedBuffers = {};\r\n};\r\n"]}