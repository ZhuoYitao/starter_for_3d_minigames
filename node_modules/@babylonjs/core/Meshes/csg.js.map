{"version":3,"file":"csg.js","sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/csg.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Constants } from \"../Engines/constants\";\r\n/**\r\n * Unique ID when we import meshes from Babylon to CSG\r\n */\r\nlet currentCSGMeshId = 0;\r\n\r\n/**\r\n * Represents a vertex of a polygon. Use your own vertex class instead of this\r\n * one to provide additional features like texture coordinates and vertex\r\n * colors. Custom vertex classes need to provide a `pos` property and `clone()`,\r\n * `flip()`, and `interpolate()` methods that behave analogous to the ones\r\n * defined by `BABYLON.CSG.Vertex`. This class provides `normal` so convenience\r\n * functions like `BABYLON.CSG.sphere()` can return a smooth vertex normal, but `normal`\r\n * is not used anywhere else.\r\n * Same goes for uv, it allows to keep the original vertex uv coordinates of the 2 meshes\r\n */\r\nclass Vertex {\r\n    /**\r\n     * Initializes the vertex\r\n     * @param pos The position of the vertex\r\n     * @param normal The normal of the vertex\r\n     * @param uv The texture coordinate of the vertex\r\n     * @param vertColor The RGBA color of the vertex\r\n     */\r\n    constructor(\r\n        /**\r\n         * The position of the vertex\r\n         */\r\n        public pos: Vector3,\r\n        /**\r\n         * The normal of the vertex\r\n         */\r\n        public normal: Vector3,\r\n        /**\r\n         * The texture coordinate of the vertex\r\n         */\r\n        public uv?: Vector2,\r\n        /**\r\n         * The texture coordinate of the vertex\r\n         */\r\n        public vertColor?: Color4\r\n    ) {}\r\n\r\n    /**\r\n     * Make a clone, or deep copy, of the vertex\r\n     * @returns A new Vertex\r\n     */\r\n    public clone(): Vertex {\r\n        return new Vertex(this.pos.clone(), this.normal.clone(), this.uv?.clone(), this.vertColor?.clone());\r\n    }\r\n\r\n    /**\r\n     * Invert all orientation-specific data (e.g. vertex normal). Called when the\r\n     * orientation of a polygon is flipped.\r\n     */\r\n    public flip(): void {\r\n        this.normal = this.normal.scale(-1);\r\n    }\r\n\r\n    /**\r\n     * Create a new vertex between this vertex and `other` by linearly\r\n     * interpolating all properties using a parameter of `t`. Subclasses should\r\n     * override this to interpolate additional properties.\r\n     * @param other the vertex to interpolate against\r\n     * @param t The factor used to linearly interpolate between the vertices\r\n     */\r\n    public interpolate(other: Vertex, t: number): Vertex {\r\n        return new Vertex(\r\n            Vector3.Lerp(this.pos, other.pos, t),\r\n            Vector3.Lerp(this.normal, other.normal, t),\r\n            this.uv && other.uv ? Vector2.Lerp(this.uv, other.uv, t) : undefined,\r\n            this.vertColor && other.vertColor ? Color4.Lerp(this.vertColor, other.vertColor, t) : undefined\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a plane in 3D space.\r\n */\r\nclass Plane {\r\n    /**\r\n     * Initializes the plane\r\n     * @param normal The normal for the plane\r\n     * @param w\r\n     */\r\n    constructor(public normal: Vector3, public w: number) {}\r\n\r\n    /**\r\n     * `CSG.Plane.EPSILON` is the tolerance used by `splitPolygon()` to decide if a\r\n     * point is on the plane\r\n     */\r\n    static EPSILON = 1e-5;\r\n\r\n    /**\r\n     * Construct a plane from three points\r\n     * @param a Point a\r\n     * @param b Point b\r\n     * @param c Point c\r\n     */\r\n    public static FromPoints(a: Vector3, b: Vector3, c: Vector3): Nullable<Plane> {\r\n        const v0 = c.subtract(a);\r\n        const v1 = b.subtract(a);\r\n\r\n        if (v0.lengthSquared() === 0 || v1.lengthSquared() === 0) {\r\n            return null;\r\n        }\r\n\r\n        const n = Vector3.Normalize(Vector3.Cross(v0, v1));\r\n        return new Plane(n, Vector3.Dot(n, a));\r\n    }\r\n\r\n    /**\r\n     * Clone, or make a deep copy of the plane\r\n     * @returns a new Plane\r\n     */\r\n    public clone(): Plane {\r\n        return new Plane(this.normal.clone(), this.w);\r\n    }\r\n\r\n    /**\r\n     * Flip the face of the plane\r\n     */\r\n    public flip() {\r\n        this.normal.scaleInPlace(-1);\r\n        this.w = -this.w;\r\n    }\r\n\r\n    /**\r\n     * Split `polygon` by this plane if needed, then put the polygon or polygon\r\n     * fragments in the appropriate lists. Coplanar polygons go into either\r\n    `* coplanarFront` or `coplanarBack` depending on their orientation with\r\n     * respect to this plane. Polygons in front or in back of this plane go into\r\n     * either `front` or `back`\r\n     * @param polygon The polygon to be split\r\n     * @param coplanarFront Will contain polygons coplanar with the plane that are oriented to the front of the plane\r\n     * @param coplanarBack Will contain polygons coplanar with the plane that are oriented to the back of the plane\r\n     * @param front Will contain the polygons in front of the plane\r\n     * @param back Will contain the polygons begind the plane\r\n     */\r\n    public splitPolygon(polygon: Polygon, coplanarFront: Polygon[], coplanarBack: Polygon[], front: Polygon[], back: Polygon[]): void {\r\n        const COPLANAR = 0;\r\n        const FRONT = 1;\r\n        const BACK = 2;\r\n        const SPANNING = 3;\r\n\r\n        // Classify each point as well as the entire polygon into one of the above\r\n        // four classes.\r\n        let polygonType = 0;\r\n        const types = [];\r\n        let i: number;\r\n        let t: number;\r\n        for (i = 0; i < polygon.vertices.length; i++) {\r\n            t = Vector3.Dot(this.normal, polygon.vertices[i].pos) - this.w;\r\n            const type = t < -Plane.EPSILON ? BACK : t > Plane.EPSILON ? FRONT : COPLANAR;\r\n            polygonType |= type;\r\n            types.push(type);\r\n        }\r\n\r\n        // Put the polygon in the correct list, splitting it when necessary\r\n        switch (polygonType) {\r\n            case COPLANAR:\r\n                (Vector3.Dot(this.normal, polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);\r\n                break;\r\n            case FRONT:\r\n                front.push(polygon);\r\n                break;\r\n            case BACK:\r\n                back.push(polygon);\r\n                break;\r\n            case SPANNING: {\r\n                const f = [],\r\n                    b = [];\r\n                for (i = 0; i < polygon.vertices.length; i++) {\r\n                    const j = (i + 1) % polygon.vertices.length;\r\n                    const ti = types[i],\r\n                        tj = types[j];\r\n                    const vi = polygon.vertices[i],\r\n                        vj = polygon.vertices[j];\r\n                    if (ti !== BACK) {\r\n                        f.push(vi);\r\n                    }\r\n                    if (ti !== FRONT) {\r\n                        b.push(ti !== BACK ? vi.clone() : vi);\r\n                    }\r\n                    if ((ti | tj) === SPANNING) {\r\n                        t = (this.w - Vector3.Dot(this.normal, vi.pos)) / Vector3.Dot(this.normal, vj.pos.subtract(vi.pos));\r\n                        const v = vi.interpolate(vj, t);\r\n                        f.push(v);\r\n                        b.push(v.clone());\r\n                    }\r\n                }\r\n                let poly: Polygon;\r\n                if (f.length >= 3) {\r\n                    poly = new Polygon(f, polygon.shared);\r\n                    if (poly.plane) {\r\n                        front.push(poly);\r\n                    }\r\n                }\r\n\r\n                if (b.length >= 3) {\r\n                    poly = new Polygon(b, polygon.shared);\r\n\r\n                    if (poly.plane) {\r\n                        back.push(poly);\r\n                    }\r\n                }\r\n\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a convex polygon. The vertices used to initialize a polygon must\r\n * be coplanar and form a convex loop.\r\n *\r\n * Each convex polygon has a `shared` property, which is shared between all\r\n * polygons that are clones of each other or were split from the same polygon.\r\n * This can be used to define per-polygon properties (such as surface color)\r\n */\r\nclass Polygon {\r\n    /**\r\n     * Vertices of the polygon\r\n     */\r\n    public vertices: Vertex[];\r\n    /**\r\n     * Properties that are shared across all polygons\r\n     */\r\n    public shared: any;\r\n    /**\r\n     * A plane formed from the vertices of the polygon\r\n     */\r\n    public plane: Plane;\r\n\r\n    /**\r\n     * Initializes the polygon\r\n     * @param vertices The vertices of the polygon\r\n     * @param shared The properties shared across all polygons\r\n     */\r\n    constructor(vertices: Vertex[], shared: any) {\r\n        this.vertices = vertices;\r\n        this.shared = shared;\r\n        this.plane = <Plane>Plane.FromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);\r\n    }\r\n\r\n    /**\r\n     * Clones, or makes a deep copy, or the polygon\r\n     */\r\n    public clone(): Polygon {\r\n        const vertices = this.vertices.map((v) => v.clone());\r\n        return new Polygon(vertices, this.shared);\r\n    }\r\n\r\n    /**\r\n     * Flips the faces of the polygon\r\n     */\r\n    public flip() {\r\n        this.vertices.reverse().map((v) => {\r\n            v.flip();\r\n        });\r\n        this.plane.flip();\r\n    }\r\n}\r\n\r\n/**\r\n * Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\r\n * by picking a polygon to split along. That polygon (and all other coplanar\r\n * polygons) are added directly to that node and the other polygons are added to\r\n * the front and/or back subtrees. This is not a leafy BSP tree since there is\r\n * no distinction between internal and leaf nodes\r\n */\r\nclass Node {\r\n    private _plane: Nullable<Plane> = null;\r\n    private _front: Nullable<Node> = null;\r\n    private _back: Nullable<Node> = null;\r\n    private _polygons = new Array<Polygon>();\r\n\r\n    /**\r\n     * Initializes the node\r\n     * @param polygons A collection of polygons held in the node\r\n     */\r\n    constructor(polygons?: Array<Polygon>) {\r\n        if (polygons) {\r\n            this.build(polygons);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones, or makes a deep copy, of the node\r\n     * @returns The cloned node\r\n     */\r\n    public clone(): Node {\r\n        const node = new Node();\r\n        node._plane = this._plane && this._plane.clone();\r\n        node._front = this._front && this._front.clone();\r\n        node._back = this._back && this._back.clone();\r\n        node._polygons = this._polygons.map((p) => p.clone());\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * Convert solid space to empty space and empty space to solid space\r\n     */\r\n    public invert(): void {\r\n        for (let i = 0; i < this._polygons.length; i++) {\r\n            this._polygons[i].flip();\r\n        }\r\n        if (this._plane) {\r\n            this._plane.flip();\r\n        }\r\n        if (this._front) {\r\n            this._front.invert();\r\n        }\r\n        if (this._back) {\r\n            this._back.invert();\r\n        }\r\n        const temp = this._front;\r\n        this._front = this._back;\r\n        this._back = temp;\r\n    }\r\n\r\n    /**\r\n     * Recursively remove all polygons in `polygons` that are inside this BSP\r\n     * tree.\r\n     * @param polygons Polygons to remove from the BSP\r\n     * @returns Polygons clipped from the BSP\r\n     */\r\n    clipPolygons(polygons: Polygon[]): Polygon[] {\r\n        if (!this._plane) {\r\n            return polygons.slice();\r\n        }\r\n        let front = new Array<Polygon>(),\r\n            back = new Array<Polygon>();\r\n        for (let i = 0; i < polygons.length; i++) {\r\n            this._plane.splitPolygon(polygons[i], front, back, front, back);\r\n        }\r\n        if (this._front) {\r\n            front = this._front.clipPolygons(front);\r\n        }\r\n        if (this._back) {\r\n            back = this._back.clipPolygons(back);\r\n        } else {\r\n            back = [];\r\n        }\r\n        return front.concat(back);\r\n    }\r\n\r\n    /**\r\n     * Remove all polygons in this BSP tree that are inside the other BSP tree\r\n     * `bsp`.\r\n     * @param bsp BSP containing polygons to remove from this BSP\r\n     */\r\n    clipTo(bsp: Node): void {\r\n        this._polygons = bsp.clipPolygons(this._polygons);\r\n        if (this._front) {\r\n            this._front.clipTo(bsp);\r\n        }\r\n        if (this._back) {\r\n            this._back.clipTo(bsp);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return a list of all polygons in this BSP tree\r\n     * @returns List of all polygons in this BSP tree\r\n     */\r\n    allPolygons(): Polygon[] {\r\n        let polygons = this._polygons.slice();\r\n        if (this._front) {\r\n            polygons = polygons.concat(this._front.allPolygons());\r\n        }\r\n        if (this._back) {\r\n            polygons = polygons.concat(this._back.allPolygons());\r\n        }\r\n        return polygons;\r\n    }\r\n\r\n    /**\r\n     * Build a BSP tree out of `polygons`. When called on an existing tree, the\r\n     * new polygons are filtered down to the bottom of the tree and become new\r\n     * nodes there. Each set of polygons is partitioned using the first polygon\r\n     * (no heuristic is used to pick a good split)\r\n     * @param polygons Polygons used to construct the BSP tree\r\n     */\r\n    build(polygons: Polygon[]): void {\r\n        if (!polygons.length) {\r\n            return;\r\n        }\r\n        if (!this._plane) {\r\n            this._plane = polygons[0].plane.clone();\r\n        }\r\n        const front = new Array<Polygon>(),\r\n            back = new Array<Polygon>();\r\n        for (let i = 0; i < polygons.length; i++) {\r\n            this._plane.splitPolygon(polygons[i], this._polygons, this._polygons, front, back);\r\n        }\r\n        if (front.length) {\r\n            if (!this._front) {\r\n                this._front = new Node();\r\n            }\r\n            this._front.build(front);\r\n        }\r\n        if (back.length) {\r\n            if (!this._back) {\r\n                this._back = new Node();\r\n            }\r\n            this._back.build(back);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Class for building Constructive Solid Geometry\r\n */\r\nexport class CSG {\r\n    private _polygons = new Array<Polygon>();\r\n    /**\r\n     * The world matrix\r\n     */\r\n    public matrix: Matrix;\r\n    /**\r\n     * Stores the position\r\n     */\r\n    public position: Vector3;\r\n    /**\r\n     * Stores the rotation\r\n     */\r\n    public rotation: Vector3;\r\n    /**\r\n     * Stores the rotation quaternion\r\n     */\r\n    public rotationQuaternion: Nullable<Quaternion>;\r\n    /**\r\n     * Stores the scaling vector\r\n     */\r\n    public scaling: Vector3;\r\n\r\n    /**\r\n     * Convert the Mesh to CSG\r\n     * @param mesh The Mesh to convert to CSG\r\n     * @param absolute If true, the final (local) matrix transformation is set to the identity and not to that of `mesh`. It can help when dealing with right-handed meshes (default: false)\r\n     * @returns A new CSG from the Mesh\r\n     */\r\n    public static FromMesh(mesh: Mesh, absolute = false): CSG {\r\n        let vertex: Vertex,\r\n            normal: Vector3,\r\n            uv: Vector2 | undefined = undefined,\r\n            position: Vector3,\r\n            vertColor: Color4 | undefined = undefined,\r\n            polygon: Polygon,\r\n            vertices;\r\n        const polygons = new Array<Polygon>();\r\n        let matrix: Matrix,\r\n            meshPosition: Vector3,\r\n            meshRotation: Vector3,\r\n            meshRotationQuaternion: Nullable<Quaternion> = null,\r\n            meshScaling: Vector3;\r\n\r\n        let invertWinding = false;\r\n        if (mesh instanceof Mesh) {\r\n            mesh.computeWorldMatrix(true);\r\n            matrix = mesh.getWorldMatrix();\r\n            meshPosition = mesh.position.clone();\r\n            meshRotation = mesh.rotation.clone();\r\n            if (mesh.rotationQuaternion) {\r\n                meshRotationQuaternion = mesh.rotationQuaternion.clone();\r\n            }\r\n            meshScaling = mesh.scaling.clone();\r\n            if (mesh.material && absolute) {\r\n                invertWinding = mesh.material.sideOrientation === Constants.MATERIAL_ClockWiseSideOrientation;\r\n            }\r\n        } else {\r\n            throw \"BABYLON.CSG: Wrong Mesh type, must be BABYLON.Mesh\";\r\n        }\r\n\r\n        const indices = <IndicesArray>mesh.getIndices(),\r\n            positions = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind),\r\n            normals = <FloatArray>mesh.getVerticesData(VertexBuffer.NormalKind),\r\n            uvs = <FloatArray>mesh.getVerticesData(VertexBuffer.UVKind),\r\n            vertColors = <FloatArray>mesh.getVerticesData(VertexBuffer.ColorKind);\r\n\r\n        const subMeshes = mesh.subMeshes;\r\n\r\n        for (let sm = 0, sml = subMeshes.length; sm < sml; sm++) {\r\n            for (let i = subMeshes[sm].indexStart, il = subMeshes[sm].indexCount + subMeshes[sm].indexStart; i < il; i += 3) {\r\n                vertices = [];\r\n                for (let j = 0; j < 3; j++) {\r\n                    const indexIndices = j === 0 ? i + j : invertWinding ? i + 3 - j : i + j;\r\n                    const sourceNormal = new Vector3(normals[indices[indexIndices] * 3], normals[indices[indexIndices] * 3 + 1], normals[indices[indexIndices] * 3 + 2]);\r\n                    if (uvs) {\r\n                        uv = new Vector2(uvs[indices[indexIndices] * 2], uvs[indices[indexIndices] * 2 + 1]);\r\n                    }\r\n                    if (vertColors) {\r\n                        vertColor = new Color4(\r\n                            vertColors[indices[indexIndices] * 4],\r\n                            vertColors[indices[indexIndices] * 4 + 1],\r\n                            vertColors[indices[indexIndices] * 4 + 2],\r\n                            vertColors[indices[indexIndices] * 4 + 3]\r\n                        );\r\n                    }\r\n                    const sourcePosition = new Vector3(positions[indices[indexIndices] * 3], positions[indices[indexIndices] * 3 + 1], positions[indices[indexIndices] * 3 + 2]);\r\n                    position = Vector3.TransformCoordinates(sourcePosition, matrix);\r\n                    normal = Vector3.TransformNormal(sourceNormal, matrix);\r\n\r\n                    vertex = new Vertex(position, normal, uv, vertColor);\r\n                    vertices.push(vertex);\r\n                }\r\n\r\n                polygon = new Polygon(vertices, { subMeshId: sm, meshId: currentCSGMeshId, materialIndex: subMeshes[sm].materialIndex });\r\n\r\n                // To handle the case of degenerated triangle\r\n                // polygon.plane == null <=> the polygon does not represent 1 single plane <=> the triangle is degenerated\r\n                if (polygon.plane) {\r\n                    polygons.push(polygon);\r\n                }\r\n            }\r\n        }\r\n\r\n        const csg = CSG._FromPolygons(polygons);\r\n        csg.matrix = absolute ? Matrix.Identity() : matrix;\r\n        csg.position = absolute ? Vector3.Zero() : meshPosition;\r\n        csg.rotation = absolute ? Vector3.Zero() : meshRotation;\r\n        csg.scaling = absolute ? Vector3.One() : meshScaling;\r\n        csg.rotationQuaternion = absolute && meshRotationQuaternion ? Quaternion.Identity() : meshRotationQuaternion;\r\n        currentCSGMeshId++;\r\n\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Construct a CSG solid from a list of `CSG.Polygon` instances.\r\n     * @param polygons Polygons used to construct a CSG solid\r\n     */\r\n    private static _FromPolygons(polygons: Polygon[]): CSG {\r\n        const csg = new CSG();\r\n        csg._polygons = polygons;\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Clones, or makes a deep copy, of the CSG\r\n     * @returns A new CSG\r\n     */\r\n    public clone(): CSG {\r\n        const csg = new CSG();\r\n        csg._polygons = this._polygons.map((p) => p.clone());\r\n        csg.copyTransformAttributes(this);\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Unions this CSG with another CSG\r\n     * @param csg The CSG to union against this CSG\r\n     * @returns The unioned CSG\r\n     */\r\n    public union(csg: CSG): CSG {\r\n        const a = new Node(this.clone()._polygons);\r\n        const b = new Node(csg.clone()._polygons);\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\r\n    }\r\n\r\n    /**\r\n     * Unions this CSG with another CSG in place\r\n     * @param csg The CSG to union against this CSG\r\n     */\r\n    public unionInPlace(csg: CSG): void {\r\n        const a = new Node(this._polygons);\r\n        const b = new Node(csg._polygons);\r\n\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n\r\n        this._polygons = a.allPolygons();\r\n    }\r\n\r\n    /**\r\n     * Subtracts this CSG with another CSG\r\n     * @param csg The CSG to subtract against this CSG\r\n     * @returns A new CSG\r\n     */\r\n    public subtract(csg: CSG): CSG {\r\n        const a = new Node(this.clone()._polygons);\r\n        const b = new Node(csg.clone()._polygons);\r\n        a.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n        return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\r\n    }\r\n\r\n    /**\r\n     * Subtracts this CSG with another CSG in place\r\n     * @param csg The CSG to subtract against this CSG\r\n     */\r\n    public subtractInPlace(csg: CSG): void {\r\n        const a = new Node(this._polygons);\r\n        const b = new Node(csg._polygons);\r\n\r\n        a.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n\r\n        this._polygons = a.allPolygons();\r\n    }\r\n\r\n    /**\r\n     * Intersect this CSG with another CSG\r\n     * @param csg The CSG to intersect against this CSG\r\n     * @returns A new CSG\r\n     */\r\n    public intersect(csg: CSG): CSG {\r\n        const a = new Node(this.clone()._polygons);\r\n        const b = new Node(csg.clone()._polygons);\r\n        a.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n        return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\r\n    }\r\n\r\n    /**\r\n     * Intersects this CSG with another CSG in place\r\n     * @param csg The CSG to intersect against this CSG\r\n     */\r\n    public intersectInPlace(csg: CSG): void {\r\n        const a = new Node(this._polygons);\r\n        const b = new Node(csg._polygons);\r\n\r\n        a.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n\r\n        this._polygons = a.allPolygons();\r\n    }\r\n\r\n    /**\r\n     * Return a new CSG solid with solid and empty space switched. This solid is\r\n     * not modified.\r\n     * @returns A new CSG solid with solid and empty space switched\r\n     */\r\n    public inverse(): CSG {\r\n        const csg = this.clone();\r\n        csg.inverseInPlace();\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Inverses the CSG in place\r\n     */\r\n    public inverseInPlace(): void {\r\n        this._polygons.map((p) => {\r\n            p.flip();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * This is used to keep meshes transformations so they can be restored\r\n     * when we build back a Babylon Mesh\r\n     * NB : All CSG operations are performed in world coordinates\r\n     * @param csg The CSG to copy the transform attributes from\r\n     * @returns This CSG\r\n     */\r\n    public copyTransformAttributes(csg: CSG): CSG {\r\n        this.matrix = csg.matrix;\r\n        this.position = csg.position;\r\n        this.rotation = csg.rotation;\r\n        this.scaling = csg.scaling;\r\n        this.rotationQuaternion = csg.rotationQuaternion;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Build Raw mesh from CSG\r\n     * Coordinates here are in world space\r\n     * @param name The name of the mesh geometry\r\n     * @param scene The Scene\r\n     * @param keepSubMeshes Specifies if the submeshes should be kept\r\n     * @returns A new Mesh\r\n     */\r\n    public buildMeshGeometry(name: string, scene?: Scene, keepSubMeshes?: boolean): Mesh {\r\n        const matrix = this.matrix.clone();\r\n        matrix.invert();\r\n\r\n        const mesh = new Mesh(name, scene);\r\n        const vertices = [];\r\n        const indices = [];\r\n        const normals = [];\r\n        let uvs: Nullable<number[]> = null;\r\n        let vertColors: Nullable<number[]> = null;\r\n        const vertex = Vector3.Zero();\r\n        const normal = Vector3.Zero();\r\n        const uv = Vector2.Zero();\r\n        const vertColor = new Color4(0, 0, 0, 0);\r\n        const polygons = this._polygons;\r\n        const polygonIndices = [0, 0, 0];\r\n        let polygon;\r\n        const vertice_dict = {};\r\n        let vertex_idx;\r\n        let currentIndex = 0;\r\n        const subMeshDict = {};\r\n        let subMeshObj;\r\n\r\n        if (keepSubMeshes) {\r\n            // Sort Polygons, since subMeshes are indices range\r\n            polygons.sort((a, b) => {\r\n                if (a.shared.meshId === b.shared.meshId) {\r\n                    return a.shared.subMeshId - b.shared.subMeshId;\r\n                } else {\r\n                    return a.shared.meshId - b.shared.meshId;\r\n                }\r\n            });\r\n        }\r\n\r\n        for (let i = 0, il = polygons.length; i < il; i++) {\r\n            polygon = polygons[i];\r\n\r\n            // Building SubMeshes\r\n            if (!(<any>subMeshDict)[polygon.shared.meshId]) {\r\n                (<any>subMeshDict)[polygon.shared.meshId] = {};\r\n            }\r\n            if (!(<any>subMeshDict)[polygon.shared.meshId][polygon.shared.subMeshId]) {\r\n                (<any>subMeshDict)[polygon.shared.meshId][polygon.shared.subMeshId] = {\r\n                    indexStart: +Infinity,\r\n                    indexEnd: -Infinity,\r\n                    materialIndex: polygon.shared.materialIndex,\r\n                };\r\n            }\r\n            subMeshObj = (<any>subMeshDict)[polygon.shared.meshId][polygon.shared.subMeshId];\r\n\r\n            for (let j = 2, jl = polygon.vertices.length; j < jl; j++) {\r\n                polygonIndices[0] = 0;\r\n                polygonIndices[1] = j - 1;\r\n                polygonIndices[2] = j;\r\n\r\n                for (let k = 0; k < 3; k++) {\r\n                    vertex.copyFrom(polygon.vertices[polygonIndices[k]].pos);\r\n                    normal.copyFrom(polygon.vertices[polygonIndices[k]].normal);\r\n                    if (polygon.vertices[polygonIndices[k]].uv) {\r\n                        if (!uvs) {\r\n                            uvs = [];\r\n                        }\r\n                        uv.copyFrom(polygon.vertices[polygonIndices[k]].uv!);\r\n                    }\r\n\r\n                    if (polygon.vertices[polygonIndices[k]].vertColor) {\r\n                        if (!vertColors) {\r\n                            vertColors = [];\r\n                        }\r\n                        vertColor.copyFrom(polygon.vertices[polygonIndices[k]].vertColor!);\r\n                    }\r\n                    const localVertex = Vector3.TransformCoordinates(vertex, matrix);\r\n                    const localNormal = Vector3.TransformNormal(normal, matrix);\r\n\r\n                    vertex_idx = (<any>vertice_dict)[localVertex.x + \",\" + localVertex.y + \",\" + localVertex.z];\r\n\r\n                    let areUvsDifferent = false;\r\n\r\n                    if (uvs && !(uvs[vertex_idx * 2] === uv.x || uvs[vertex_idx * 2 + 1] === uv.y)) {\r\n                        areUvsDifferent = true;\r\n                    }\r\n\r\n                    let areColorsDifferent = false;\r\n\r\n                    if (\r\n                        vertColors &&\r\n                        !(\r\n                            vertColors[vertex_idx * 4] === vertColor.r ||\r\n                            vertColors[vertex_idx * 4 + 1] === vertColor.g ||\r\n                            vertColors[vertex_idx * 4 + 2] === vertColor.b ||\r\n                            vertColors[vertex_idx * 4 + 3] === vertColor.a\r\n                        )\r\n                    ) {\r\n                        areColorsDifferent = true;\r\n                    }\r\n\r\n                    // Check if 2 points can be merged\r\n                    if (\r\n                        !(\r\n                            typeof vertex_idx !== \"undefined\" &&\r\n                            normals[vertex_idx * 3] === localNormal.x &&\r\n                            normals[vertex_idx * 3 + 1] === localNormal.y &&\r\n                            normals[vertex_idx * 3 + 2] === localNormal.z\r\n                        ) ||\r\n                        areUvsDifferent ||\r\n                        areColorsDifferent\r\n                    ) {\r\n                        vertices.push(localVertex.x, localVertex.y, localVertex.z);\r\n                        if (uvs) {\r\n                            uvs.push(uv.x, uv.y);\r\n                        }\r\n                        normals.push(normal.x, normal.y, normal.z);\r\n                        if (vertColors) {\r\n                            vertColors.push(vertColor.r, vertColor.g, vertColor.b, vertColor.a);\r\n                        }\r\n                        vertex_idx = (<any>vertice_dict)[localVertex.x + \",\" + localVertex.y + \",\" + localVertex.z] = vertices.length / 3 - 1;\r\n                    }\r\n\r\n                    indices.push(vertex_idx);\r\n\r\n                    subMeshObj.indexStart = Math.min(currentIndex, subMeshObj.indexStart);\r\n                    subMeshObj.indexEnd = Math.max(currentIndex, subMeshObj.indexEnd);\r\n                    currentIndex++;\r\n                }\r\n            }\r\n        }\r\n\r\n        mesh.setVerticesData(VertexBuffer.PositionKind, vertices);\r\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\r\n        if (uvs) {\r\n            mesh.setVerticesData(VertexBuffer.UVKind, uvs);\r\n        }\r\n        if (vertColors) {\r\n            mesh.setVerticesData(VertexBuffer.ColorKind, vertColors);\r\n        }\r\n        mesh.setIndices(indices, null);\r\n\r\n        if (keepSubMeshes) {\r\n            // We offset the materialIndex by the previous number of materials in the CSG mixed meshes\r\n            let materialIndexOffset = 0,\r\n                materialMaxIndex;\r\n\r\n            mesh.subMeshes = new Array<SubMesh>();\r\n\r\n            for (const m in subMeshDict) {\r\n                materialMaxIndex = -1;\r\n                for (const sm in (<any>subMeshDict)[m]) {\r\n                    subMeshObj = (<any>subMeshDict)[m][sm];\r\n                    SubMesh.CreateFromIndices(\r\n                        subMeshObj.materialIndex + materialIndexOffset,\r\n                        subMeshObj.indexStart,\r\n                        subMeshObj.indexEnd - subMeshObj.indexStart + 1,\r\n                        <AbstractMesh>mesh\r\n                    );\r\n                    materialMaxIndex = Math.max(subMeshObj.materialIndex, materialMaxIndex);\r\n                }\r\n                materialIndexOffset += ++materialMaxIndex;\r\n            }\r\n        }\r\n\r\n        return mesh;\r\n    }\r\n\r\n    /**\r\n     * Build Mesh from CSG taking material and transforms into account\r\n     * @param name The name of the Mesh\r\n     * @param material The material of the Mesh\r\n     * @param scene The Scene\r\n     * @param keepSubMeshes Specifies if submeshes should be kept\r\n     * @returns The new Mesh\r\n     */\r\n    public toMesh(name: string, material: Nullable<Material> = null, scene?: Scene, keepSubMeshes?: boolean): Mesh {\r\n        const mesh = this.buildMeshGeometry(name, scene, keepSubMeshes);\r\n\r\n        mesh.material = material;\r\n\r\n        mesh.position.copyFrom(this.position);\r\n        mesh.rotation.copyFrom(this.rotation);\r\n        if (this.rotationQuaternion) {\r\n            mesh.rotationQuaternion = this.rotationQuaternion.clone();\r\n        }\r\n        mesh.scaling.copyFrom(this.scaling);\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        return mesh;\r\n    }\r\n}\r\n"]}