{"version":3,"file":"screenshotTools.js","sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/screenshotTools.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { FxaaPostProcess } from \"../PostProcesses/fxaaPostProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"./logger\";\r\nimport { Tools } from \"./tools\";\r\nimport type { IScreenshotSize } from \"./interfaces/screenshotSize\";\r\n\r\ndeclare type Engine = import(\"../Engines/engine\").Engine;\r\n\r\n/**\r\n * Captures a screenshot of the current rendering\r\n * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n * @param engine defines the rendering engine\r\n * @param camera defines the source camera\r\n * @param size This parameter can be set to a single number or to an object with the\r\n * following (optional) properties: precision, width, height. If a single number is passed,\r\n * it will be used for both width and height. If an object is passed, the screenshot size\r\n * will be derived from the parameters. The precision property is a multiplier allowing\r\n * rendering at a higher or lower resolution\r\n * @param successCallback defines the callback receives a single parameter which contains the\r\n * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n * src parameter of an <img> to display it\r\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n * Check your browser for supported MIME types\r\n * @param forceDownload force the system to download the image even if a successCallback is provided\r\n */\r\nexport function CreateScreenshot(\r\n    engine: Engine,\r\n    camera: Camera,\r\n    size: IScreenshotSize | number,\r\n    successCallback?: (data: string) => void,\r\n    mimeType: string = \"image/png\",\r\n    forceDownload = false\r\n): void {\r\n    const { height, width } = _GetScreenshotSize(engine, camera, size);\r\n\r\n    if (!(height && width)) {\r\n        Logger.Error(\"Invalid 'size' parameter !\");\r\n        return;\r\n    }\r\n\r\n    if (!Tools._ScreenshotCanvas) {\r\n        Tools._ScreenshotCanvas = document.createElement(\"canvas\");\r\n    }\r\n\r\n    Tools._ScreenshotCanvas.width = width;\r\n    Tools._ScreenshotCanvas.height = height;\r\n\r\n    const renderContext = Tools._ScreenshotCanvas.getContext(\"2d\");\r\n\r\n    const ratio = engine.getRenderWidth() / engine.getRenderHeight();\r\n    let newWidth = width;\r\n    let newHeight = newWidth / ratio;\r\n    if (newHeight > height) {\r\n        newHeight = height;\r\n        newWidth = newHeight * ratio;\r\n    }\r\n\r\n    const offsetX = Math.max(0, width - newWidth) / 2;\r\n    const offsetY = Math.max(0, height - newHeight) / 2;\r\n\r\n    engine.onEndFrameObservable.addOnce(() => {\r\n        const renderingCanvas = engine.getRenderingCanvas();\r\n        if (renderContext && renderingCanvas) {\r\n            renderContext.drawImage(renderingCanvas, offsetX, offsetY, newWidth, newHeight);\r\n        }\r\n\r\n        if (forceDownload) {\r\n            Tools.EncodeScreenshotCanvasData(undefined, mimeType);\r\n            if (successCallback) {\r\n                successCallback(\"\");\r\n            }\r\n        } else {\r\n            Tools.EncodeScreenshotCanvasData(successCallback, mimeType);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Captures a screenshot of the current rendering\r\n * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n * @param engine defines the rendering engine\r\n * @param camera defines the source camera\r\n * @param size This parameter can be set to a single number or to an object with the\r\n * following (optional) properties: precision, width, height. If a single number is passed,\r\n * it will be used for both width and height. If an object is passed, the screenshot size\r\n * will be derived from the parameters. The precision property is a multiplier allowing\r\n * rendering at a higher or lower resolution\r\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n * Check your browser for supported MIME types\r\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n * to the src parameter of an <img> to display it\r\n */\r\nexport function CreateScreenshotAsync(engine: Engine, camera: Camera, size: IScreenshotSize | number, mimeType: string = \"image/png\"): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n        CreateScreenshot(\r\n            engine,\r\n            camera,\r\n            size,\r\n            (data) => {\r\n                if (typeof data !== \"undefined\") {\r\n                    resolve(data);\r\n                } else {\r\n                    reject(new Error(\"Data is undefined\"));\r\n                }\r\n            },\r\n            mimeType\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * Captures a screenshot of the current rendering for a specific size. This will render the entire canvas but will generate a blink (due to canvas resize)\r\n * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n * @param engine defines the rendering engine\r\n * @param camera defines the source camera\r\n * @param width defines the expected width\r\n * @param height defines the expected height\r\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n * Check your browser for supported MIME types\r\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n * to the src parameter of an <img> to display it\r\n */\r\nexport function CreateScreenshotWithResizeAsync(engine: Engine, camera: Camera, width: number, height: number, mimeType: string = \"image/png\"): Promise<void> {\r\n    return new Promise((resolve) => {\r\n        CreateScreenshot(\r\n            engine,\r\n            camera,\r\n            { width: width, height: height },\r\n            () => {\r\n                resolve();\r\n            },\r\n            mimeType,\r\n            true\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * Generates an image screenshot from the specified camera.\r\n * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n * @param engine The engine to use for rendering\r\n * @param camera The camera to use for rendering\r\n * @param size This parameter can be set to a single number or to an object with the\r\n * following (optional) properties: precision, width, height. If a single number is passed,\r\n * it will be used for both width and height. If an object is passed, the screenshot size\r\n * will be derived from the parameters. The precision property is a multiplier allowing\r\n * rendering at a higher or lower resolution\r\n * @param successCallback The callback receives a single parameter which contains the\r\n * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n * src parameter of an <img> to display it\r\n * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n * Check your browser for supported MIME types\r\n * @param samples Texture samples (default: 1)\r\n * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n * @param fileName A name for for the downloaded file.\r\n * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\r\n */\r\nexport function CreateScreenshotUsingRenderTarget(\r\n    engine: Engine,\r\n    camera: Camera,\r\n    size: IScreenshotSize | number,\r\n    successCallback?: (data: string) => void,\r\n    mimeType: string = \"image/png\",\r\n    samples: number = 1,\r\n    antialiasing: boolean = false,\r\n    fileName?: string,\r\n    renderSprites: boolean = false,\r\n    enableStencilBuffer: boolean = false\r\n): void {\r\n    const { height, width } = _GetScreenshotSize(engine, camera, size);\r\n    const targetTextureSize = { width, height };\r\n\r\n    if (!(height && width)) {\r\n        Logger.Error(\"Invalid 'size' parameter !\");\r\n        return;\r\n    }\r\n\r\n    const scene = camera.getScene();\r\n    let previousCamera: Nullable<Camera> = null;\r\n    const previousCameras = scene.activeCameras;\r\n\r\n    scene.activeCameras = null;\r\n\r\n    if (scene.activeCamera !== camera) {\r\n        previousCamera = scene.activeCamera;\r\n        scene.activeCamera = camera;\r\n    }\r\n\r\n    scene.render(); // make sure the scene is ready to be rendered in the RTT with the right list of active meshes (which depends on the camera, that may have been changed above)\r\n\r\n    // At this point size can be a number, or an object (according to engine.prototype.createRenderTargetTexture method)\r\n    const texture = new RenderTargetTexture(\r\n        \"screenShot\",\r\n        targetTextureSize,\r\n        scene,\r\n        false,\r\n        false,\r\n        Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        false,\r\n        Texture.NEAREST_SAMPLINGMODE,\r\n        undefined,\r\n        enableStencilBuffer,\r\n        undefined,\r\n        undefined,\r\n        undefined,\r\n        samples\r\n    );\r\n    texture.renderList = null;\r\n    texture.samples = samples;\r\n    texture.renderSprites = renderSprites;\r\n\r\n    const renderToTexture = () => {\r\n        engine.onEndFrameObservable.addOnce(() => {\r\n            texture.readPixels(undefined, undefined, undefined, false)!.then((data) => {\r\n                Tools.DumpData(width, height, data, successCallback as (data: string | ArrayBuffer) => void, mimeType, fileName, true);\r\n                texture.dispose();\r\n            });\r\n        });\r\n\r\n        // render the RTT\r\n        scene.incrementRenderId();\r\n        scene.resetCachedMaterial();\r\n        texture.render(true);\r\n\r\n        // re-render the scene after the camera has been reset to the original camera to avoid a flicker that could occur\r\n        // if the camera used for the RTT rendering stays in effect for the next frame (and if that camera was different from the original camera)\r\n        scene.incrementRenderId();\r\n        scene.resetCachedMaterial();\r\n        if (previousCamera) {\r\n            scene.activeCamera = previousCamera;\r\n        }\r\n        scene.activeCameras = previousCameras;\r\n        camera.getProjectionMatrix(true); // Force cache refresh;\r\n        scene.render();\r\n    };\r\n\r\n    if (antialiasing) {\r\n        const fxaaPostProcess = new FxaaPostProcess(\"antialiasing\", 1.0, scene.activeCamera);\r\n        texture.addPostProcess(fxaaPostProcess);\r\n        // Async Shader Compilation can lead to none ready effects in synchronous code\r\n        if (!fxaaPostProcess.getEffect().isReady()) {\r\n            fxaaPostProcess.getEffect().onCompiled = () => {\r\n                renderToTexture();\r\n            };\r\n        }\r\n        // The effect is ready we can render\r\n        else {\r\n            renderToTexture();\r\n        }\r\n    } else {\r\n        // No need to wait for extra resources to be ready\r\n        renderToTexture();\r\n    }\r\n}\r\n\r\n/**\r\n * Generates an image screenshot from the specified camera.\r\n * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n * @param engine The engine to use for rendering\r\n * @param camera The camera to use for rendering\r\n * @param size This parameter can be set to a single number or to an object with the\r\n * following (optional) properties: precision, width, height. If a single number is passed,\r\n * it will be used for both width and height. If an object is passed, the screenshot size\r\n * will be derived from the parameters. The precision property is a multiplier allowing\r\n * rendering at a higher or lower resolution\r\n * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n * Check your browser for supported MIME types\r\n * @param samples Texture samples (default: 1)\r\n * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n * @param fileName A name for for the downloaded file.\r\n * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n * to the src parameter of an <img> to display it\r\n */\r\nexport function CreateScreenshotUsingRenderTargetAsync(\r\n    engine: Engine,\r\n    camera: Camera,\r\n    size: IScreenshotSize | number,\r\n    mimeType: string = \"image/png\",\r\n    samples: number = 1,\r\n    antialiasing: boolean = false,\r\n    fileName?: string,\r\n    renderSprites: boolean = false\r\n): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n        CreateScreenshotUsingRenderTarget(\r\n            engine,\r\n            camera,\r\n            size,\r\n            (data) => {\r\n                if (typeof data !== \"undefined\") {\r\n                    resolve(data);\r\n                } else {\r\n                    reject(new Error(\"Data is undefined\"));\r\n                }\r\n            },\r\n            mimeType,\r\n            samples,\r\n            antialiasing,\r\n            fileName,\r\n            renderSprites\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * Gets height and width for screenshot size\r\n * @param engine\r\n * @param camera\r\n * @param size\r\n * @private\r\n */\r\nfunction _GetScreenshotSize(engine: Engine, camera: Camera, size: IScreenshotSize | number): { height: number; width: number } {\r\n    let height = 0;\r\n    let width = 0;\r\n\r\n    //If a size value defined as object\r\n    if (typeof size === \"object\") {\r\n        const precision = size.precision\r\n            ? Math.abs(size.precision) // prevent GL_INVALID_VALUE : glViewport: negative width/height\r\n            : 1;\r\n\r\n        //If a width and height values is specified\r\n        if (size.width && size.height) {\r\n            height = size.height * precision;\r\n            width = size.width * precision;\r\n        }\r\n        //If passing only width, computing height to keep display canvas ratio.\r\n        else if (size.width && !size.height) {\r\n            width = size.width * precision;\r\n            height = Math.round(width / engine.getAspectRatio(camera));\r\n        }\r\n        //If passing only height, computing width to keep display canvas ratio.\r\n        else if (size.height && !size.width) {\r\n            height = size.height * precision;\r\n            width = Math.round(height * engine.getAspectRatio(camera));\r\n        } else {\r\n            width = Math.round(engine.getRenderWidth() * precision);\r\n            height = Math.round(width / engine.getAspectRatio(camera));\r\n        }\r\n    }\r\n    //Assuming here that \"size\" parameter is a number\r\n    else if (!isNaN(size)) {\r\n        height = size;\r\n        width = size;\r\n    }\r\n\r\n    // When creating the image data from the CanvasRenderingContext2D, the width and height is clamped to the size of the _gl context\r\n    // On certain GPUs, it seems as if the _gl context truncates to an integer automatically. Therefore, if a user tries to pass the width of their canvas element\r\n    // and it happens to be a float (1000.5 x 600.5 px), the engine.readPixels will return a different size array than context.createImageData\r\n    // to resolve this, we truncate the floats here to ensure the same size\r\n    if (width) {\r\n        width = Math.floor(width);\r\n    }\r\n    if (height) {\r\n        height = Math.floor(height);\r\n    }\r\n\r\n    return { height: height | 0, width: width | 0 };\r\n}\r\n\r\n/**\r\n * Class containing a set of static utilities functions for screenshots\r\n */\r\nexport const ScreenshotTools = {\r\n    /**\r\n     * Captures a screenshot of the current rendering\r\n     * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n     * @param engine defines the rendering engine\r\n     * @param camera defines the source camera\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param successCallback defines the callback receives a single parameter which contains the\r\n     * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n     * src parameter of an <img> to display it\r\n     * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @param forceDownload force the system to download the image even if a successCallback is provided\r\n     */\r\n    CreateScreenshot,\r\n\r\n    /**\r\n     * Captures a screenshot of the current rendering\r\n     * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n     * @param engine defines the rendering engine\r\n     * @param camera defines the source camera\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n     * to the src parameter of an <img> to display it\r\n     */\r\n    CreateScreenshotAsync,\r\n\r\n    /**\r\n     * Captures a screenshot of the current rendering for a specific size. This will render the entire canvas but will generate a blink (due to canvas resize)\r\n     * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n     * @param engine defines the rendering engine\r\n     * @param camera defines the source camera\r\n     * @param width defines the expected width\r\n     * @param height defines the expected height\r\n     * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n     * to the src parameter of an <img> to display it\r\n     */\r\n    CreateScreenshotWithResizeAsync,\r\n\r\n    /**\r\n     * Generates an image screenshot from the specified camera.\r\n     * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n     * @param engine The engine to use for rendering\r\n     * @param camera The camera to use for rendering\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param successCallback The callback receives a single parameter which contains the\r\n     * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n     * src parameter of an <img> to display it\r\n     * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @param samples Texture samples (default: 1)\r\n     * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n     * @param fileName A name for for the downloaded file.\r\n     * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n     * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\r\n     */\r\n    CreateScreenshotUsingRenderTarget,\r\n\r\n    /**\r\n     * Generates an image screenshot from the specified camera.\r\n     * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n     * @param engine The engine to use for rendering\r\n     * @param camera The camera to use for rendering\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @param samples Texture samples (default: 1)\r\n     * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n     * @param fileName A name for for the downloaded file.\r\n     * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n     * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n     * to the src parameter of an <img> to display it\r\n     */\r\n    CreateScreenshotUsingRenderTargetAsync,\r\n};\r\n\r\n/**\r\n * This will be executed automatically for UMD and es5.\r\n * If esm dev wants the side effects to execute they will have to run it manually\r\n * Once we build native modules those need to be exported.\r\n * @hidden\r\n */\r\nconst initSideEffects = () => {\r\n    // References the dependencies.\r\n    Tools.CreateScreenshot = CreateScreenshot;\r\n    Tools.CreateScreenshotAsync = CreateScreenshotAsync;\r\n    Tools.CreateScreenshotUsingRenderTarget = CreateScreenshotUsingRenderTarget;\r\n    Tools.CreateScreenshotUsingRenderTargetAsync = CreateScreenshotUsingRenderTargetAsync;\r\n};\r\n\r\ninitSideEffects();\r\n"]}