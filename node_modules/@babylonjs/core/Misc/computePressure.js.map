{"version":3,"file":"computePressure.js","sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/computePressure.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,mBAAmB,EAAE,MAAM,iBAAiB,CAAC;AAEtD;;GAEG;AACH;IAEI;;;;OAIG;IACH,wCAAY,QAAgD,EAAE,UAAsC;QAChG,IAAI,8BAA8B,CAAC,WAAW,EAAE;YAC5C,IAAI,CAAC,SAAS,GAAG,IAAU,MAAO,CAAC,uBAAuB,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;SACpF;IACL,CAAC;IAKD,sBAAkB,6CAAW;QAH7B;;WAEG;aACH;YACI,OAAO,mBAAmB,EAAE,IAAI,yBAAyB,IAAI,MAAM,CAAC;QACxE,CAAC;;;OAAA;IAED;;OAEG;IACH,gDAAO,GAAP;;QACI,CAAA,MAAA,IAAI,CAAC,SAAS,0CAAE,OAAO,MAAI,MAAA,IAAI,CAAC,SAAS,0CAAE,OAAO,EAAE,CAAA,CAAC;IACzD,CAAC;IAED;;OAEG;IACH,kDAAS,GAAT;;QACI,CAAA,MAAA,IAAI,CAAC,SAAS,0CAAE,SAAS,MAAI,MAAA,IAAI,CAAC,SAAS,0CAAE,SAAS,EAAE,CAAA,CAAC;IAC7D,CAAC;IACL,qCAAC;AAAD,CAAC,AAjCD,IAiCC","sourcesContent":["import { IsWindowObjectExist } from \"./domManagement\";\r\n\r\n/**\r\n * A wrapper for the experimental compute pressure api which allows a callback to be called whenever certain thresholds are met.\r\n */\r\nexport class ComputePressureObserverWrapper {\r\n    private _observer: any;\r\n    /**\r\n     * A compute pressure observer will call this callback, whenever these thresholds are met.\r\n     * @param callback The callback that is called whenever thresholds are met.\r\n     * @param thresholds An object containing the thresholds used to decide what value to to return for each update property (average of start and end of a threshold boundary).\r\n     */\r\n    constructor(callback: (update: IComputePressureData) => void, thresholds: IComputePressureThresholds) {\r\n        if (ComputePressureObserverWrapper.IsAvailable) {\r\n            this._observer = new (<any>window).ComputePressureObserver(callback, thresholds);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if ComputePressureObserver is available for use, false otherwise.\r\n     */\r\n    public static get IsAvailable() {\r\n        return IsWindowObjectExist() && \"ComputePressureObserver\" in window;\r\n    }\r\n\r\n    /**\r\n     * Method that must be called to begin observing changes, and triggering callbacks.\r\n     */\r\n    observe(): void {\r\n        this._observer?.observe && this._observer?.observe();\r\n    }\r\n\r\n    /**\r\n     * Method that must be called to stop observing changes and triggering callbacks (cleanup function).\r\n     */\r\n    unobserve(): void {\r\n        this._observer?.unobserve && this._observer?.unobserve();\r\n    }\r\n}\r\n\r\n/**\r\n * An interface defining the shape of the thresholds parameter in the experimental compute pressure api\r\n */\r\nexport interface IComputePressureThresholds {\r\n    /**\r\n     * Thresholds to make buckets out of for the cpu utilization, the average between the start and end points of a threshold will be returned to the callback.\r\n     */\r\n    cpuUtilizationThresholds: number[];\r\n    /**\r\n     * Thresholds to make buckets out of for the cpu speed, the average between the start and end points of a threshold will be returned to the callback.\r\n     * 0.5 represents base speed.\r\n     */\r\n    cpuSpeedThresholds: number[];\r\n}\r\n\r\n/**\r\n * An interface defining the shape of the data sent to the callback in the compute pressure observer.\r\n */\r\nexport interface IComputePressureData {\r\n    /**\r\n     * The cpu utilization which will be a number between 0.0 and 1.0.\r\n     */\r\n    cpuUtilization: number;\r\n    /**\r\n     * The cpu speed which will be a number between 0.0 and 1.0.\r\n     */\r\n    cpuSpeed: number;\r\n}\r\n"]}