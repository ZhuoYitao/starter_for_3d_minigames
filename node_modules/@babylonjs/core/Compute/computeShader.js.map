{"version":3,"file":"computeShader.js","sourceRoot":"","sources":["../../../../../lts/core/generated/Compute/computeShader.ts"],"names":[],"mappings":"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","sourcesContent":["import type { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport { SerializationHelper, serialize } from \"../Misc/decorators\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { ComputeEffect, IComputeEffectCreationOptions } from \"./computeEffect\";\r\nimport type { ComputeBindingList, ComputeBindingMapping } from \"../Engines/Extensions/engine.computeShader\";\r\nimport { ComputeBindingType } from \"../Engines/Extensions/engine.computeShader\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { UniqueIdGenerator } from \"../Misc/uniqueIdGenerator\";\r\nimport type { IComputeContext } from \"./IComputeContext\";\r\nimport type { StorageBuffer } from \"../Buffers/storageBuffer\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { TextureSampler } from \"../Materials/Textures/textureSampler\";\r\n\r\n/**\r\n * Defines the options associated with the creation of a compute shader.\r\n */\r\nexport interface IComputeShaderOptions {\r\n    /**\r\n     * list of bindings mapping (key is property name, value is binding location)\r\n     * Must be provided because browsers don't support reflection for wgsl shaders yet (so there's no way to query the binding/group from a variable name)\r\n     * TODO: remove this when browsers support reflection for wgsl shaders\r\n     */\r\n    bindingsMapping: ComputeBindingMapping;\r\n\r\n    /**\r\n     * The list of defines used in the shader\r\n     */\r\n    defines?: string[];\r\n\r\n    /**\r\n     * The name of the entry point in the shader source (default: \"main\")\r\n     */\r\n    entryPoint?: string;\r\n\r\n    /**\r\n     * If provided, will be called with the shader code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<(code: string) => string>;\r\n}\r\n\r\n/**\r\n * The ComputeShader object lets you execute a compute shader on your GPU (if supported by the engine)\r\n */\r\nexport class ComputeShader {\r\n    private _engine: ThinEngine;\r\n    private _shaderPath: any;\r\n    private _options: IComputeShaderOptions;\r\n    private _effect: ComputeEffect;\r\n    private _cachedDefines: string;\r\n    private _bindings: ComputeBindingList = {};\r\n    private _samplers: { [key: string]: TextureSampler } = {};\r\n    private _context: IComputeContext;\r\n    private _contextIsDirty = false;\r\n\r\n    /**\r\n     * Gets the unique id of the compute shader\r\n     */\r\n    public readonly uniqueId: number;\r\n\r\n    /**\r\n     * The name of the shader\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * The options used to create the shader\r\n     */\r\n    public get options() {\r\n        return this._options;\r\n    }\r\n\r\n    /**\r\n     * The shaderPath used to create the shader\r\n     */\r\n    public get shaderPath() {\r\n        return this._shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Callback triggered when the shader is compiled\r\n     */\r\n    public onCompiled: Nullable<(effect: ComputeEffect) => void> = null;\r\n\r\n    /**\r\n     * Callback triggered when an error occurs\r\n     */\r\n    public onError: Nullable<(effect: ComputeEffect, errors: string) => void> = null;\r\n\r\n    /**\r\n     * Instantiates a new compute shader.\r\n     * @param name Defines the name of the compute shader in the scene\r\n     * @param engine Defines the engine the compute shader belongs to\r\n     * @param shaderPath Defines  the route to the shader code in one of three ways:\r\n     *  * object: { compute: \"custom\" }, used with ShaderStore.ShadersStoreWGSL[\"customComputeShader\"]\r\n     *  * object: { computeElement: \"HTMLElementId\" }, used with shader code in script tags\r\n     *  * object: { computeSource: \"compute shader code string\" using with string containing the shader code\r\n     *  * string: try first to find the code in ShaderStore.ShadersStoreWGSL[shaderPath + \"ComputeShader\"]. If not, assumes it is a file with name shaderPath.compute.fx in index.html folder.\r\n     * @param options Define the options used to create the shader\r\n     */\r\n    constructor(name: string, engine: ThinEngine, shaderPath: any, options: Partial<IComputeShaderOptions> = {}) {\r\n        this.name = name;\r\n        this._engine = engine;\r\n        this.uniqueId = UniqueIdGenerator.UniqueId;\r\n\r\n        if (!this._engine.getCaps().supportComputeShaders) {\r\n            Logger.Error(\"This engine does not support compute shaders!\");\r\n            return;\r\n        }\r\n        if (!options.bindingsMapping) {\r\n            Logger.Error(\"You must provide the binding mappings as browsers don't support reflection for wgsl shaders yet!\");\r\n            return;\r\n        }\r\n\r\n        this._context = engine.createComputeContext()!;\r\n        this._shaderPath = shaderPath;\r\n        this._options = {\r\n            bindingsMapping: {},\r\n            defines: [],\r\n            ...options,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"ComputeShader\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ComputeShader\";\r\n    }\r\n\r\n    /**\r\n     * Binds a texture to the shader\r\n     * @param name Binding name of the texture\r\n     * @param texture Texture to bind\r\n     * @param bindSampler Bind the sampler corresponding to the texture (default: true). The sampler will be bound just before the binding index of the texture\r\n     */\r\n    public setTexture(name: string, texture: BaseTexture, bindSampler = true): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._bindings[name] = {\r\n            type: bindSampler ? ComputeBindingType.Texture : ComputeBindingType.TextureWithoutSampler,\r\n            object: texture,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n\r\n        this._contextIsDirty ||= !current || current.object !== texture || current.type !== this._bindings[name].type;\r\n    }\r\n\r\n    /**\r\n     * Binds a storage texture to the shader\r\n     * @param name Binding name of the texture\r\n     * @param texture Texture to bind\r\n     */\r\n    public setStorageTexture(name: string, texture: BaseTexture): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || current.object !== texture;\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.StorageTexture,\r\n            object: texture,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds a uniform buffer to the shader\r\n     * @param name Binding name of the buffer\r\n     * @param buffer Buffer to bind\r\n     */\r\n    public setUniformBuffer(name: string, buffer: UniformBuffer): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || current.object !== buffer;\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.UniformBuffer,\r\n            object: buffer,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds a storage buffer to the shader\r\n     * @param name Binding name of the buffer\r\n     * @param buffer Buffer to bind\r\n     */\r\n    public setStorageBuffer(name: string, buffer: StorageBuffer): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || current.object !== buffer;\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.StorageBuffer,\r\n            object: buffer,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds a texture sampler to the shader\r\n     * @param name Binding name of the sampler\r\n     * @param sampler Sampler to bind\r\n     */\r\n    public setTextureSampler(name: string, sampler: TextureSampler): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || !sampler.compareSampler(current.object);\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.Sampler,\r\n            object: sampler,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Specifies that the compute shader is ready to be executed (the compute effect and all the resources are ready)\r\n     * @returns true if the compute shader is ready to be executed\r\n     */\r\n    public isReady(): boolean {\r\n        let effect = this._effect;\r\n\r\n        for (const key in this._bindings) {\r\n            const binding = this._bindings[key],\r\n                type = binding.type,\r\n                object = binding.object;\r\n\r\n            switch (type) {\r\n                case ComputeBindingType.Texture:\r\n                case ComputeBindingType.TextureWithoutSampler:\r\n                case ComputeBindingType.StorageTexture: {\r\n                    const texture = object as BaseTexture;\r\n                    if (!texture.isReady()) {\r\n                        return false;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        const defines = [];\r\n\r\n        const shaderName = this._shaderPath;\r\n\r\n        if (this._options.defines) {\r\n            for (let index = 0; index < this._options.defines.length; index++) {\r\n                defines.push(this._options.defines[index]);\r\n            }\r\n        }\r\n\r\n        const join = defines.join(\"\\n\");\r\n\r\n        if (this._cachedDefines !== join) {\r\n            this._cachedDefines = join;\r\n\r\n            effect = this._engine.createComputeEffect(shaderName, <IComputeEffectCreationOptions>{\r\n                defines: join,\r\n                entryPoint: this._options.entryPoint,\r\n                onCompiled: this.onCompiled,\r\n                onError: this.onError,\r\n            });\r\n\r\n            this._effect = effect;\r\n        }\r\n\r\n        if (!effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispatches (executes) the compute shader\r\n     * @param x Number of workgroups to execute on the X dimension\r\n     * @param y Number of workgroups to execute on the Y dimension (default: 1)\r\n     * @param z Number of workgroups to execute on the Z dimension (default: 1)\r\n     * @returns True if the dispatch could be done, else false (meaning either the compute effect or at least one of the bound resources was not ready)\r\n     */\r\n    public dispatch(x: number, y?: number, z?: number): boolean {\r\n        if (!this.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        // If the sampling parameters of a texture bound to the shader have changed, we must clear the compute context so that it is recreated with the updated values\r\n        for (const key in this._bindings) {\r\n            const binding = this._bindings[key];\r\n\r\n            // TODO: remove this when browsers support reflection for wgsl shaders\r\n            if (!this._options.bindingsMapping[key]) {\r\n                throw new Error(\"ComputeShader ('\" + this.name + \"'): No binding mapping has been provided for the property '\" + key + \"'\");\r\n            }\r\n\r\n            if (binding.type !== ComputeBindingType.Texture) {\r\n                continue;\r\n            }\r\n\r\n            const sampler = this._samplers[key];\r\n            const texture = binding.object as BaseTexture;\r\n\r\n            if (!sampler || !texture._texture || !sampler.compareSampler(texture._texture)) {\r\n                this._samplers[key] = new TextureSampler().setParameters(\r\n                    texture.wrapU,\r\n                    texture.wrapV,\r\n                    texture.wrapR,\r\n                    texture.anisotropicFilteringLevel,\r\n                    texture._texture!.samplingMode,\r\n                    texture._texture?._comparisonFunction\r\n                );\r\n                this._contextIsDirty = true;\r\n            }\r\n        }\r\n\r\n        if (this._contextIsDirty) {\r\n            this._contextIsDirty = false;\r\n            this._context.clear();\r\n        }\r\n\r\n        this._engine.computeDispatch(this._effect, this._context, this._bindings, x, y, z, this._options.bindingsMapping);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Waits for the compute shader to be ready and executes it\r\n     * @param x Number of workgroups to execute on the X dimension\r\n     * @param y Number of workgroups to execute on the Y dimension (default: 1)\r\n     * @param z Number of workgroups to execute on the Z dimension (default: 1)\r\n     * @param delay Delay between the retries while the shader is not ready (in milliseconds - 10 by default)\r\n     * @returns A promise that is resolved once the shader has been sent to the GPU. Note that it does not mean that the shader execution itself is finished!\r\n     */\r\n    public dispatchWhenReady(x: number, y?: number, z?: number, delay = 10): Promise<void> {\r\n        return new Promise((resolve) => {\r\n            const check = () => {\r\n                if (!this.dispatch(x, y, z)) {\r\n                    setTimeout(check, delay);\r\n                } else {\r\n                    resolve();\r\n                }\r\n            };\r\n\r\n            check();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Serializes this compute shader in a JSON representation\r\n     * @returns the serialized compute shader object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        serializationObject.options = this._options;\r\n        serializationObject.shaderPath = this._shaderPath;\r\n        serializationObject.bindings = {};\r\n        serializationObject.textures = {};\r\n\r\n        for (const key in this._bindings) {\r\n            const binding = this._bindings[key];\r\n            const object = binding.object;\r\n\r\n            switch (binding.type) {\r\n                case ComputeBindingType.Texture:\r\n                case ComputeBindingType.TextureWithoutSampler:\r\n                case ComputeBindingType.StorageTexture: {\r\n                    const serializedData = (object as BaseTexture).serialize();\r\n                    if (serializedData) {\r\n                        serializationObject.textures[key] = serializedData;\r\n                        serializationObject.bindings[key] = {\r\n                            type: binding.type,\r\n                        };\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                case ComputeBindingType.UniformBuffer: {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a compute shader from parsed compute shader data\r\n     * @param source defines the JSON representation of the compute shader\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new compute shader\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): ComputeShader {\r\n        const compute = SerializationHelper.Parse(() => new ComputeShader(source.name, scene.getEngine(), source.shaderPath, source.options), source, scene, rootUrl);\r\n\r\n        for (const key in source.textures) {\r\n            const binding = source.bindings[key];\r\n            const texture = <Texture>Texture.Parse(source.textures[key], scene, rootUrl);\r\n\r\n            if (binding.type === ComputeBindingType.Texture) {\r\n                compute.setTexture(key, texture);\r\n            } else if (binding.type === ComputeBindingType.TextureWithoutSampler) {\r\n                compute.setTexture(key, texture, false);\r\n            } else {\r\n                compute.setStorageTexture(key, texture);\r\n            }\r\n        }\r\n\r\n        return compute;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ComputeShader\", ComputeShader);\r\n"]}