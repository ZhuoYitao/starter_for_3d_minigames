{"version":3,"file":"nodeMaterialBlockConnectionPoint.js","sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Node/nodeMaterialBlockConnectionPoint.ts"],"names":[],"mappings":"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","sourcesContent":["import { NodeMaterialBlockConnectionPointTypes } from \"./Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { InputBlock } from \"./Blocks/Input/inputBlock\";\r\nimport { Observable } from \"../../Misc/observable\";\r\n\r\ndeclare type NodeMaterialBlock = import(\"./nodeMaterialBlock\").NodeMaterialBlock;\r\n\r\n/**\r\n * Enum used to define the compatibility state between two connection points\r\n */\r\nexport enum NodeMaterialConnectionPointCompatibilityStates {\r\n    /** Points are compatibles */\r\n    Compatible,\r\n    /** Points are incompatible because of their types */\r\n    TypeIncompatible,\r\n    /** Points are incompatible because of their targets (vertex vs fragment) */\r\n    TargetIncompatible,\r\n    /** Points are incompatible because they are in the same hierarchy **/\r\n    HierarchyIssue,\r\n}\r\n\r\n/**\r\n * Defines the direction of a connection point\r\n */\r\nexport enum NodeMaterialConnectionPointDirection {\r\n    /** Input */\r\n    Input,\r\n    /** Output */\r\n    Output,\r\n}\r\n\r\n/**\r\n * Defines a connection point for a block\r\n */\r\nexport class NodeMaterialConnectionPoint {\r\n    /**\r\n     * Checks if two types are equivalent\r\n     * @param type1 type 1 to check\r\n     * @param type2 type 2 to check\r\n     * @returns true if both types are equivalent, else false\r\n     */\r\n    public static AreEquivalentTypes(type1: number, type2: number): boolean {\r\n        switch (type1) {\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Color3) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Color4) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n            case NodeMaterialBlockConnectionPointTypes.Color3: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Vector3) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n            case NodeMaterialBlockConnectionPointTypes.Color4: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Vector4) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _ownerBlock: NodeMaterialBlock;\r\n    /** @hidden */\r\n    public _connectedPoint: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    private _endpoints = new Array<NodeMaterialConnectionPoint>();\r\n    private _associatedVariableName: string;\r\n    private _direction: NodeMaterialConnectionPointDirection;\r\n\r\n    /** @hidden */\r\n    public _typeConnectionSource: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    /** @hidden */\r\n    public _defaultConnectionPointType: Nullable<NodeMaterialBlockConnectionPointTypes> = null;\r\n\r\n    /** @hidden */\r\n    public _linkedConnectionSource: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    /** @hidden */\r\n    public _acceptedConnectionPointType: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    private _type = NodeMaterialBlockConnectionPointTypes.Float;\r\n\r\n    /** @hidden */\r\n    public _enforceAssociatedVariableName = false;\r\n\r\n    /** Gets the direction of the point */\r\n    public get direction() {\r\n        return this._direction;\r\n    }\r\n\r\n    /** Indicates that this connection point needs dual validation before being connected to another point */\r\n    public needDualDirectionValidation: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets the additional types supported by this connection point\r\n     */\r\n    public acceptedConnectionPointTypes = new Array<NodeMaterialBlockConnectionPointTypes>();\r\n\r\n    /**\r\n     * Gets or sets the additional types excluded by this connection point\r\n     */\r\n    public excludedConnectionPointTypes = new Array<NodeMaterialBlockConnectionPointTypes>();\r\n\r\n    /**\r\n     * Observable triggered when this point is connected\r\n     */\r\n    public onConnectionObservable = new Observable<NodeMaterialConnectionPoint>();\r\n\r\n    /**\r\n     * Gets or sets the associated variable name in the shader\r\n     */\r\n    public get associatedVariableName(): string {\r\n        if (this._ownerBlock.isInput) {\r\n            return (this._ownerBlock as InputBlock).associatedVariableName;\r\n        }\r\n\r\n        if ((!this._enforceAssociatedVariableName || !this._associatedVariableName) && this._connectedPoint) {\r\n            return this._connectedPoint.associatedVariableName;\r\n        }\r\n\r\n        return this._associatedVariableName;\r\n    }\r\n\r\n    public set associatedVariableName(value: string) {\r\n        this._associatedVariableName = value;\r\n    }\r\n\r\n    /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */\r\n    public get innerType() {\r\n        if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {\r\n            return this.type;\r\n        }\r\n        return this._type;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the connection point type (default is float)\r\n     */\r\n    public get type(): NodeMaterialBlockConnectionPointTypes {\r\n        if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n            if (this._ownerBlock.isInput) {\r\n                return (this._ownerBlock as InputBlock).type;\r\n            }\r\n\r\n            if (this._connectedPoint) {\r\n                return this._connectedPoint.type;\r\n            }\r\n\r\n            if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {\r\n                return this._linkedConnectionSource.type;\r\n            }\r\n        }\r\n\r\n        if (this._type === NodeMaterialBlockConnectionPointTypes.BasedOnInput) {\r\n            if (this._typeConnectionSource) {\r\n                if (!this._typeConnectionSource.isConnected && this._defaultConnectionPointType) {\r\n                    return this._defaultConnectionPointType;\r\n                }\r\n                return this._typeConnectionSource.type;\r\n            } else if (this._defaultConnectionPointType) {\r\n                return this._defaultConnectionPointType;\r\n            }\r\n        }\r\n\r\n        return this._type;\r\n    }\r\n\r\n    public set type(value: NodeMaterialBlockConnectionPointTypes) {\r\n        this._type = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the connection point name\r\n     */\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets the connection point name\r\n     */\r\n    public displayName: string;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point can be omitted\r\n     */\r\n    public isOptional: boolean;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is exposed on a frame\r\n     */\r\n    public isExposedOnFrame: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets number indicating the position that the port is exposed to on a frame\r\n     */\r\n    public exposedPortPosition: number = -1;\r\n\r\n    /**\r\n     * Gets or sets a string indicating that this uniform must be defined under a #ifdef\r\n     */\r\n    public define: string;\r\n\r\n    /** @hidden */\r\n    public _prioritizeVertex = false;\r\n\r\n    private _target: NodeMaterialBlockTargets = NodeMaterialBlockTargets.VertexAndFragment;\r\n\r\n    /** Gets or sets the target of that connection point */\r\n    public get target(): NodeMaterialBlockTargets {\r\n        if (!this._prioritizeVertex || !this._ownerBlock) {\r\n            return this._target;\r\n        }\r\n\r\n        if (this._target !== NodeMaterialBlockTargets.VertexAndFragment) {\r\n            return this._target;\r\n        }\r\n\r\n        if (this._ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            return NodeMaterialBlockTargets.Fragment;\r\n        }\r\n\r\n        return NodeMaterialBlockTargets.Vertex;\r\n    }\r\n\r\n    public set target(value: NodeMaterialBlockTargets) {\r\n        this._target = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the current point is connected to another NodeMaterialBlock\r\n     */\r\n    public get isConnected(): boolean {\r\n        return this.connectedPoint !== null || this.hasEndpoints;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the current point is connected to an input block\r\n     */\r\n    public get isConnectedToInputBlock(): boolean {\r\n        return this.connectedPoint !== null && this.connectedPoint.ownerBlock.isInput;\r\n    }\r\n\r\n    /**\r\n     * Gets a the connected input block (if any)\r\n     */\r\n    public get connectInputBlock(): Nullable<InputBlock> {\r\n        if (!this.isConnectedToInputBlock) {\r\n            return null;\r\n        }\r\n\r\n        return this.connectedPoint!.ownerBlock as InputBlock;\r\n    }\r\n\r\n    /** Get the other side of the connection (if any) */\r\n    public get connectedPoint(): Nullable<NodeMaterialConnectionPoint> {\r\n        return this._connectedPoint;\r\n    }\r\n\r\n    /** Get the block that owns this connection point */\r\n    public get ownerBlock(): NodeMaterialBlock {\r\n        return this._ownerBlock;\r\n    }\r\n\r\n    /** Get the block connected on the other side of this connection (if any) */\r\n    public get sourceBlock(): Nullable<NodeMaterialBlock> {\r\n        if (!this._connectedPoint) {\r\n            return null;\r\n        }\r\n\r\n        return this._connectedPoint.ownerBlock;\r\n    }\r\n\r\n    /** Get the block connected on the endpoints of this connection (if any) */\r\n    public get connectedBlocks(): Array<NodeMaterialBlock> {\r\n        if (this._endpoints.length === 0) {\r\n            return [];\r\n        }\r\n\r\n        return this._endpoints.map((e) => e.ownerBlock);\r\n    }\r\n\r\n    /** Gets the list of connected endpoints */\r\n    public get endpoints() {\r\n        return this._endpoints;\r\n    }\r\n\r\n    /** Gets a boolean indicating if that output point is connected to at least one input */\r\n    public get hasEndpoints(): boolean {\r\n        return this._endpoints && this._endpoints.length > 0;\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection has a path to the vertex output*/\r\n    public get isDirectlyConnectedToVertexOutput(): boolean {\r\n        if (!this.hasEndpoints) {\r\n            return false;\r\n        }\r\n\r\n        for (const endpoint of this._endpoints) {\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                if (endpoint.ownerBlock.outputs.some((o) => o.isDirectlyConnectedToVertexOutput)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection will be used in the vertex shader */\r\n    public get isConnectedInVertexShader(): boolean {\r\n        if (this.target === NodeMaterialBlockTargets.Vertex) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.hasEndpoints) {\r\n            return false;\r\n        }\r\n\r\n        for (const endpoint of this._endpoints) {\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.target === NodeMaterialBlockTargets.Vertex) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                if (endpoint.ownerBlock.outputs.some((o) => o.isConnectedInVertexShader)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection will be used in the fragment shader */\r\n    public get isConnectedInFragmentShader(): boolean {\r\n        if (this.target === NodeMaterialBlockTargets.Fragment) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.hasEndpoints) {\r\n            return false;\r\n        }\r\n\r\n        for (const endpoint of this._endpoints) {\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                if (endpoint.ownerBlock.outputs.some((o) => o.isConnectedInFragmentShader)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Creates a block suitable to be used as an input for this input point.\r\n     * If null is returned, a block based on the point type will be created.\r\n     * @returns The returned string parameter is the name of the output point of NodeMaterialBlock (first parameter of the returned array) that can be connected to the input\r\n     */\r\n    public createCustomInputBlock(): Nullable<[NodeMaterialBlock, string]> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates a new connection point\r\n     * @param name defines the connection point name\r\n     * @param ownerBlock defines the block hosting this connection point\r\n     * @param direction defines the direction of the connection point\r\n     */\r\n    public constructor(name: string, ownerBlock: NodeMaterialBlock, direction: NodeMaterialConnectionPointDirection) {\r\n        this._ownerBlock = ownerBlock;\r\n        this.name = name;\r\n        this._direction = direction;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name e.g. \"NodeMaterialConnectionPoint\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"NodeMaterialConnectionPoint\";\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the current point can be connected to another point\r\n     * @param connectionPoint defines the other connection point\r\n     * @returns a boolean\r\n     */\r\n    public canConnectTo(connectionPoint: NodeMaterialConnectionPoint) {\r\n        return this.checkCompatibilityState(connectionPoint) === NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n    }\r\n\r\n    /**\r\n     * Gets a number indicating if the current point can be connected to another point\r\n     * @param connectionPoint defines the other connection point\r\n     * @returns a number defining the compatibility state\r\n     */\r\n    public checkCompatibilityState(connectionPoint: NodeMaterialConnectionPoint): NodeMaterialConnectionPointCompatibilityStates {\r\n        const ownerBlock = this._ownerBlock;\r\n        const otherBlock = connectionPoint.ownerBlock;\r\n\r\n        if (ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            // Let's check we are not going reverse\r\n\r\n            if (otherBlock.target === NodeMaterialBlockTargets.Vertex) {\r\n                return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;\r\n            }\r\n\r\n            for (const output of otherBlock.outputs) {\r\n                if (output.ownerBlock.target != NodeMaterialBlockTargets.Neutral && output.isConnectedInVertexShader) {\r\n                    return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n            // Equivalents\r\n            if (NodeMaterialConnectionPoint.AreEquivalentTypes(this.type, connectionPoint.type)) {\r\n                return NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n            }\r\n\r\n            // Accepted types\r\n            if (\r\n                (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1) ||\r\n                (connectionPoint._acceptedConnectionPointType && NodeMaterialConnectionPoint.AreEquivalentTypes(connectionPoint._acceptedConnectionPointType.type, this.type))\r\n            ) {\r\n                return NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n            } else {\r\n                return NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;\r\n            }\r\n        }\r\n\r\n        // Excluded\r\n        if (connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1) {\r\n            return NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;\r\n        }\r\n\r\n        // Check hierarchy\r\n        let targetBlock = otherBlock;\r\n        let sourceBlock = ownerBlock;\r\n        if (this.direction === NodeMaterialConnectionPointDirection.Input) {\r\n            targetBlock = ownerBlock;\r\n            sourceBlock = otherBlock;\r\n        }\r\n\r\n        if (targetBlock.isAnAncestorOf(sourceBlock)) {\r\n            return NodeMaterialConnectionPointCompatibilityStates.HierarchyIssue;\r\n        }\r\n\r\n        return NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n    }\r\n\r\n    /**\r\n     * Connect this point to another connection point\r\n     * @param connectionPoint defines the other connection point\r\n     * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)\r\n     * @returns the current connection point\r\n     */\r\n    public connectTo(connectionPoint: NodeMaterialConnectionPoint, ignoreConstraints = false): NodeMaterialConnectionPoint {\r\n        if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {\r\n            throw \"Cannot connect these two connectors.\";\r\n        }\r\n\r\n        this._endpoints.push(connectionPoint);\r\n        connectionPoint._connectedPoint = this;\r\n\r\n        this._enforceAssociatedVariableName = false;\r\n\r\n        this.onConnectionObservable.notifyObservers(connectionPoint);\r\n        connectionPoint.onConnectionObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disconnect this point from one of his endpoint\r\n     * @param endpoint defines the other connection point\r\n     * @returns the current connection point\r\n     */\r\n    public disconnectFrom(endpoint: NodeMaterialConnectionPoint): NodeMaterialConnectionPoint {\r\n        const index = this._endpoints.indexOf(endpoint);\r\n\r\n        if (index === -1) {\r\n            return this;\r\n        }\r\n\r\n        this._endpoints.splice(index, 1);\r\n        endpoint._connectedPoint = null;\r\n        this._enforceAssociatedVariableName = false;\r\n        endpoint._enforceAssociatedVariableName = false;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Serializes this point in a JSON representation\r\n     * @param isInput defines if the connection point is an input (default is true)\r\n     * @returns the serialized point object\r\n     */\r\n    public serialize(isInput = true): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.displayName = this.displayName;\r\n\r\n        if (isInput && this.connectedPoint) {\r\n            serializationObject.inputName = this.name;\r\n            serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;\r\n            serializationObject.targetConnectionName = this.connectedPoint.name;\r\n            serializationObject.isExposedOnFrame = true;\r\n            serializationObject.exposedPortPosition = this.exposedPortPosition;\r\n        }\r\n\r\n        if (this.isExposedOnFrame || this.exposedPortPosition >= 0) {\r\n            serializationObject.isExposedOnFrame = true;\r\n            serializationObject.exposedPortPosition = this.exposedPortPosition;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public dispose() {\r\n        this.onConnectionObservable.clear();\r\n    }\r\n}\r\n"]}