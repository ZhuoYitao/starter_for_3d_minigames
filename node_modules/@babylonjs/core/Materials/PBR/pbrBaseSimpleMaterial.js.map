{"version":3,"file":"pbrBaseSimpleMaterial.js","sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/PBR/pbrBaseSimpleMaterial.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,SAAS,EAAE,iBAAiB,EAAE,gBAAgB,EAAE,kBAAkB,EAAE,MAAM,uBAAuB,CAAC;AAE3G,OAAO,EAAE,MAAM,EAAE,MAAM,wBAAwB,CAAC;AAChD,OAAO,EAAE,eAAe,EAAE,MAAM,mBAAmB,CAAC;AAIpD;;;;;GAKG;AACH;IAAoD,yCAAe;IA+G/D;;;;;OAKG;IACH,+BAAY,IAAY,EAAE,KAAa;QAAvC,YACI,kBAAM,IAAI,EAAE,KAAK,CAAC,SAIrB;QAzHD;;WAEG;QAGI,2BAAqB,GAAG,CAAC,CAAC;QAEjC;;WAEG;QAGI,qBAAe,GAAG,KAAK,CAAC;QAS/B;;WAEG;QAGI,sBAAgB,GAAG,KAAK,CAAC;QAEhC;;WAEG;QAGI,sBAAgB,GAAG,KAAK,CAAC;QAShC;;WAEG;QAGI,mBAAa,GAAG,IAAI,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAS3C;;WAEG;QAGI,uBAAiB,GAAW,GAAG,CAAC;QA0CvC;;WAEG;QAGI,4BAAsB,GAAG,KAAK,CAAC;QAWlC,KAAI,CAAC,0BAA0B,GAAG,IAAI,CAAC;QACvC,KAAI,CAAC,sBAAsB,GAAG,IAAI,CAAC;;IACvC,CAAC;IAxCD,sBAAW,8CAAW;QAJtB;;WAEG;aAEH;YACI,OAAO,IAAI,CAAC,iBAAiB,CAAC;QAClC,CAAC;QACD;;WAEG;aACH,UAAuB,KAAc;YACjC,IAAI,IAAI,CAAC,iBAAiB,KAAK,KAAK,EAAE;gBAClC,OAAO;aACV;YACD,IAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC;YAC/B,IAAI,CAAC,eAAe,GAAG,CAAC,KAAK,CAAC;YAC9B,IAAI,CAAC,gCAAgC,EAAE,CAAC;QAC5C,CAAC;;;OAXA;IAwCM,4CAAY,GAAnB;QACI,OAAO,uBAAuB,CAAC;IACnC,CAAC;IAxHD;QAFC,SAAS,EAAE;QACX,gBAAgB,CAAC,gCAAgC,CAAC;wEAClB;IAOjC;QAFC,SAAS,EAAE;QACX,gBAAgB,CAAC,gCAAgC,CAAC;kEACpB;IAO/B;QAFC,kBAAkB,EAAE;QACpB,gBAAgB,CAAC,kCAAkC,EAAE,oBAAoB,CAAC;qEAC1B;IAOjD;QAFC,SAAS,EAAE;QACX,gBAAgB,CAAC,kCAAkC,CAAC;mEACrB;IAOhC;QAFC,SAAS,EAAE;QACX,gBAAgB,CAAC,kCAAkC,CAAC;mEACrB;IAOhC;QAFC,kBAAkB,EAAE;QACpB,gBAAgB,CAAC,kCAAkC,EAAE,cAAc,CAAC;gEACzB;IAO5C;QAFC,iBAAiB,CAAC,UAAU,CAAC;QAC7B,gBAAgB,CAAC,kCAAkC,CAAC;gEACV;IAO3C;QAFC,kBAAkB,EAAE;QACpB,gBAAgB,CAAC,kCAAkC,CAAC;kEACP;IAO9C;QAFC,SAAS,EAAE;QACX,gBAAgB,CAAC,kCAAkC,EAAE,yBAAyB,CAAC;oEACzC;IAOvC;QAFC,kBAAkB,EAAE;QACpB,gBAAgB,CAAC,kCAAkC,EAAE,iBAAiB,CAAC;mEACzB;IAO/C;QAFC,SAAS,EAAE;QACX,gBAAgB,CAAC,kCAAkC,EAAE,cAAc,CAAC;8DAC1C;IAM3B;QADC,SAAS,EAAE;4DAGX;IAkBD;QAFC,kBAAkB,EAAE;QACpB,gBAAgB,CAAC,kCAAkC,EAAE,IAAI,CAAC;kEACb;IAO9C;QAFC,SAAS,EAAE;QACX,gBAAgB,CAAC,kCAAkC,CAAC;yEACf;IAkB1C,4BAAC;CAAA,AA/HD,CAAoD,eAAe,GA+HlE;SA/HqB,qBAAqB","sourcesContent":["import { serialize, serializeAsColor3, expandToProperty, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Nullable } from \"../../types\";\r\n\r\n/**\r\n * The Physically based simple base material of BJS.\r\n *\r\n * This enables better naming and convention enforcements on top of the pbrMaterial.\r\n * It is used as the base class for both the specGloss and metalRough conventions.\r\n */\r\nexport abstract class PBRBaseSimpleMaterial extends PBRBaseMaterial {\r\n    /**\r\n     * Number of Simultaneous lights allowed on the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights = 4;\r\n\r\n    /**\r\n     * If sets to true, disables all the lights affecting the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting = false;\r\n\r\n    /**\r\n     * Environment Texture used in the material (this is use for both reflection and environment lighting).\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_reflectionTexture\")\r\n    public environmentTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * If sets to true, x component of normal map value will invert (x = 1.0 - x).\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public invertNormalMapX = false;\r\n\r\n    /**\r\n     * If sets to true, y component of normal map value will invert (y = 1.0 - y).\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public invertNormalMapY = false;\r\n\r\n    /**\r\n     * Normal map used in the model.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_bumpTexture\")\r\n    public normalTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Emissivie color used to self-illuminate the model.\r\n     */\r\n    @serializeAsColor3(\"emissive\")\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public emissiveColor = new Color3(0, 0, 0);\r\n\r\n    /**\r\n     * Emissivie texture used to self-illuminate the model.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public emissiveTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Occlusion Channel Strength.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_ambientTextureStrength\")\r\n    public occlusionStrength: number = 1.0;\r\n\r\n    /**\r\n     * Occlusion Texture of the material (adding extra occlusion effects).\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_ambientTexture\")\r\n    public occlusionTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Defines the alpha limits in alpha test mode.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_alphaCutOff\")\r\n    public alphaCutOff: number;\r\n\r\n    /**\r\n     * Gets the current double sided mode.\r\n     */\r\n    @serialize()\r\n    public get doubleSided(): boolean {\r\n        return this._twoSidedLighting;\r\n    }\r\n    /**\r\n     * If sets to true and backfaceCulling is false, normals will be flipped on the backside.\r\n     */\r\n    public set doubleSided(value: boolean) {\r\n        if (this._twoSidedLighting === value) {\r\n            return;\r\n        }\r\n        this._twoSidedLighting = value;\r\n        this.backFaceCulling = !value;\r\n        this._markAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Stores the pre-calculated light information of a mesh in a texture.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", null)\r\n    public lightmapTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * If true, the light map contains occlusion information instead of lighting info.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useLightmapAsShadowmap = false;\r\n\r\n    /**\r\n     * Instantiates a new PBRMaterial instance.\r\n     *\r\n     * @param name The material name\r\n     * @param scene The scene the material will be use in.\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n\r\n        this._useAlphaFromAlbedoTexture = true;\r\n        this._useAmbientInGrayScale = true;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"PBRBaseSimpleMaterial\";\r\n    }\r\n}\r\n"]}