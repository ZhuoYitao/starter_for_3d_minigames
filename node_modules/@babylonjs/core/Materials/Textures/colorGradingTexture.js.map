{"version":3,"file":"colorGradingTexture.js","sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/colorGradingTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { RegisterClass } from \"../../Misc/typeStore\";\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\n\r\n// Ensures Raw texture are included\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\n\r\n/**\r\n * This represents a color grading texture. This acts as a lookup table LUT, useful during post process\r\n * It can help converting any input color in a desired output one. This can then be used to create effects\r\n * from sepia, black and white to sixties or futuristic rendering...\r\n *\r\n * The only supported format is currently 3dl.\r\n * More information on LUT: https://en.wikipedia.org/wiki/3D_lookup_table\r\n */\r\nexport class ColorGradingTexture extends BaseTexture {\r\n    /**\r\n     * The texture URL.\r\n     */\r\n    public url: string;\r\n\r\n    /**\r\n     * Empty line regex stored for GC.\r\n     */\r\n    private static _NoneEmptyLineRegex = /\\S+/;\r\n\r\n    private _textureMatrix: Matrix;\r\n    private _onLoad: Nullable<() => void>;\r\n\r\n    /**\r\n     * Instantiates a ColorGradingTexture from the following parameters.\r\n     *\r\n     * @param url The location of the color grading data (currently only supporting 3dl)\r\n     * @param sceneOrEngine The scene or engine the texture will be used in\r\n     * @param onLoad defines a callback triggered when the texture has been loaded\r\n     */\r\n    constructor(url: string, sceneOrEngine: Scene | ThinEngine, onLoad: Nullable<() => void> = null) {\r\n        super(sceneOrEngine);\r\n\r\n        if (!url) {\r\n            return;\r\n        }\r\n\r\n        this._textureMatrix = Matrix.Identity();\r\n        this.name = url;\r\n        this.url = url;\r\n        this._onLoad = onLoad;\r\n\r\n        this._texture = this._getFromCache(url, true);\r\n\r\n        if (!this._texture) {\r\n            const scene = this.getScene();\r\n            if (scene) {\r\n                if (!scene.useDelayedTextureLoading) {\r\n                    this._loadTexture();\r\n                } else {\r\n                    this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n                }\r\n            } else {\r\n                this._loadTexture();\r\n            }\r\n        } else {\r\n            this._triggerOnLoad();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fires the onload event from the constructor if requested.\r\n     */\r\n    private _triggerOnLoad(): void {\r\n        if (this._onLoad) {\r\n            this._onLoad();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the texture matrix used in most of the material.\r\n     * This is not used in color grading but keep for troubleshooting purpose (easily swap diffuse by colorgrading to look in).\r\n     */\r\n    public getTextureMatrix(): Matrix {\r\n        return this._textureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Occurs when the file being loaded is a .3dl LUT file.\r\n     */\r\n    private _load3dlTexture() {\r\n        const engine = this._getEngine()!;\r\n        let texture: InternalTexture;\r\n        if (!engine._features.support3DTextures) {\r\n            texture = engine.createRawTexture(\r\n                null,\r\n                1,\r\n                1,\r\n                Constants.TEXTUREFORMAT_RGBA,\r\n                false,\r\n                false,\r\n                Constants.TEXTURE_BILINEAR_SAMPLINGMODE,\r\n                null,\r\n                Constants.TEXTURETYPE_UNSIGNED_INT\r\n            );\r\n        } else {\r\n            texture = engine.createRawTexture3D(\r\n                null,\r\n                1,\r\n                1,\r\n                1,\r\n                Constants.TEXTUREFORMAT_RGBA,\r\n                false,\r\n                false,\r\n                Constants.TEXTURE_BILINEAR_SAMPLINGMODE,\r\n                null,\r\n                Constants.TEXTURETYPE_UNSIGNED_INT\r\n            );\r\n        }\r\n\r\n        this._texture = texture;\r\n        this._texture.isReady = false;\r\n\r\n        this.isCube = false;\r\n        this.is3D = engine._features.support3DTextures;\r\n        this.wrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        this.wrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        this.wrapR = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        this.anisotropicFilteringLevel = 1;\r\n\r\n        const callback = (text: string | ArrayBuffer) => {\r\n            if (typeof text !== \"string\") {\r\n                return;\r\n            }\r\n\r\n            let data: Nullable<Uint8Array> = null;\r\n            let tempData: Nullable<Float32Array> = null;\r\n\r\n            let line: string;\r\n            const lines = text.split(\"\\n\");\r\n            let size = 0,\r\n                pixelIndexW = 0,\r\n                pixelIndexH = 0,\r\n                pixelIndexSlice = 0;\r\n            let maxColor = 0;\r\n\r\n            for (let i = 0; i < lines.length; i++) {\r\n                line = lines[i];\r\n\r\n                if (!ColorGradingTexture._NoneEmptyLineRegex.test(line)) {\r\n                    continue;\r\n                }\r\n\r\n                if (line.indexOf(\"#\") === 0) {\r\n                    continue;\r\n                }\r\n\r\n                const words = line.split(\" \");\r\n                if (size === 0) {\r\n                    // Number of space + one\r\n                    size = words.length;\r\n                    data = new Uint8Array(size * size * size * 4); // volume texture of side size and rgb 8\r\n                    tempData = new Float32Array(size * size * size * 4);\r\n                    continue;\r\n                }\r\n\r\n                if (size != 0) {\r\n                    const r = Math.max(parseInt(words[0]), 0);\r\n                    const g = Math.max(parseInt(words[1]), 0);\r\n                    const b = Math.max(parseInt(words[2]), 0);\r\n\r\n                    maxColor = Math.max(r, maxColor);\r\n                    maxColor = Math.max(g, maxColor);\r\n                    maxColor = Math.max(b, maxColor);\r\n\r\n                    const pixelStorageIndex = (pixelIndexW + pixelIndexSlice * size + pixelIndexH * size * size) * 4;\r\n\r\n                    if (tempData) {\r\n                        tempData[pixelStorageIndex + 0] = r;\r\n                        tempData[pixelStorageIndex + 1] = g;\r\n                        tempData[pixelStorageIndex + 2] = b;\r\n                    }\r\n\r\n                    // Keep for reference in case of back compat problems.\r\n                    // pixelIndexSlice++;\r\n                    // if (pixelIndexSlice % size == 0) {\r\n                    //     pixelIndexH++;\r\n                    //     pixelIndexSlice = 0;\r\n                    //     if (pixelIndexH % size == 0) {\r\n                    //         pixelIndexW++;\r\n                    //         pixelIndexH = 0;\r\n                    //     }\r\n                    // }\r\n\r\n                    pixelIndexH++;\r\n                    if (pixelIndexH % size == 0) {\r\n                        pixelIndexSlice++;\r\n                        pixelIndexH = 0;\r\n                        if (pixelIndexSlice % size == 0) {\r\n                            pixelIndexW++;\r\n                            pixelIndexSlice = 0;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (tempData && data) {\r\n                for (let i = 0; i < tempData.length; i++) {\r\n                    if (i > 0 && (i + 1) % 4 === 0) {\r\n                        data[i] = 255;\r\n                    } else {\r\n                        const value = tempData[i];\r\n                        data[i] = (value / maxColor) * 255;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (texture.is3D) {\r\n                texture.updateSize(size, size, size);\r\n                engine.updateRawTexture3D(texture, data, Constants.TEXTUREFORMAT_RGBA, false);\r\n            } else {\r\n                texture.updateSize(size * size, size);\r\n                engine.updateRawTexture(texture, data, Constants.TEXTUREFORMAT_RGBA, false);\r\n            }\r\n\r\n            texture.isReady = true;\r\n            this._triggerOnLoad();\r\n        };\r\n\r\n        const scene = this.getScene();\r\n        if (scene) {\r\n            scene._loadFile(this.url, callback);\r\n        } else {\r\n            engine._loadFile(this.url, callback);\r\n        }\r\n\r\n        return this._texture;\r\n    }\r\n\r\n    /**\r\n     * Starts the loading process of the texture.\r\n     */\r\n    private _loadTexture() {\r\n        if (this.url && this.url.toLocaleLowerCase().indexOf(\".3dl\") == this.url.length - 4) {\r\n            this._load3dlTexture();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones the color grading texture.\r\n     */\r\n    public clone(): ColorGradingTexture {\r\n        const newTexture = new ColorGradingTexture(this.url, this.getScene() || this._getEngine()!);\r\n\r\n        // Base texture\r\n        newTexture.level = this.level;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Called during delayed load for textures.\r\n     */\r\n    public delayLoad(): void {\r\n        if (this.delayLoadState !== Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            return;\r\n        }\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\r\n        this._texture = this._getFromCache(this.url, true);\r\n\r\n        if (!this._texture) {\r\n            this._loadTexture();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses a color grading texture serialized by Babylon.\r\n     * @param parsedTexture The texture information being parsedTexture\r\n     * @param scene The scene to load the texture in\r\n     * @return A color grading texture\r\n     */\r\n    public static Parse(parsedTexture: any, scene: Scene): Nullable<ColorGradingTexture> {\r\n        let texture = null;\r\n        if (parsedTexture.name && !parsedTexture.isRenderTarget) {\r\n            texture = new ColorGradingTexture(parsedTexture.name, scene);\r\n            texture.name = parsedTexture.name;\r\n            texture.level = parsedTexture.level;\r\n        }\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Serializes the LUT texture to json format.\r\n     */\r\n    public serialize(): any {\r\n        if (!this.name) {\r\n            return null;\r\n        }\r\n\r\n        const serializationObject: any = {};\r\n        serializationObject.name = this.name;\r\n        serializationObject.level = this.level;\r\n        serializationObject.customType = \"BABYLON.ColorGradingTexture\";\r\n\r\n        return serializationObject;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ColorGradingTexture\", ColorGradingTexture);\r\n"]}