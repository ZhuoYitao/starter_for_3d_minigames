{"version":3,"file":"externalTexture.js","sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/externalTexture.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,yBAAyB,CAAC;AACpD,OAAO,EAAE,eAAe,EAAE,MAAM,mBAAmB,CAAC;AAEpD;;GAEG;AACH;IA0CI;;;OAGG;IACH,yBAAY,KAAuB;QAnBnC;;WAEG;QACI,eAAU,GAAY,KAAK,CAAC;QAEnC;;WAEG;QACa,SAAI,GAAG,SAAS,CAAC,qBAAqB,CAAC;QAYnD,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,IAAI,CAAC,QAAQ,GAAG,eAAe,CAAC,QAAQ,EAAE,CAAC;IAC/C,CAAC;IAhDD;;;;OAIG;IACW,iCAAiB,GAA/B,UAAgC,OAA0C;QACtE,OAAQ,OAA2B,CAAC,kBAAkB,KAAK,SAAS,CAAC;IACzE,CAAC;IAID;;;OAGG;IACI,sCAAY,GAAnB;QACI,OAAO,iBAAiB,CAAC;IAC7B,CAAC;IAKD,sBAAW,+CAAkB;QAH7B;;WAEG;aACH;YACI,OAAO,IAAI,CAAC,MAAM,CAAC;QACvB,CAAC;;;OAAA;IA0BD;;;OAGG;IACI,iCAAO,GAAd;QACI,OAAO,IAAI,CAAC,MAAM,CAAC,UAAU,IAAI,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC;IACnE,CAAC;IAED;;OAEG;IACI,iCAAO,GAAd,cAAwB,CAAC;IAC7B,sBAAC;AAAD,CAAC,AA/DD,IA+DC","sourcesContent":["import { Constants } from \"../../Engines/constants\";\r\nimport { InternalTexture } from \"./internalTexture\";\r\n\r\n/**\r\n * Class used to store an external texture (like GPUExternalTexture in WebGPU)\r\n */\r\nexport class ExternalTexture {\r\n    /**\r\n     * Checks if a texture is an external or internal texture\r\n     * @param texture the external or internal texture\r\n     * @returns true if the texture is an external texture, else false\r\n     */\r\n    public static IsExternalTexture(texture: ExternalTexture | InternalTexture): texture is ExternalTexture {\r\n        return (texture as ExternalTexture).underlyingResource !== undefined;\r\n    }\r\n\r\n    private _video: HTMLVideoElement;\r\n\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"ExternalTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"ExternalTexture\";\r\n    }\r\n\r\n    /**\r\n     * Gets the underlying texture object\r\n     */\r\n    public get underlyingResource(): any {\r\n        return this._video;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the texture uses mipmaps\r\n     */\r\n    public useMipMaps: boolean = false;\r\n\r\n    /**\r\n     * The type of the underlying texture is implementation dependent, so return \"UNDEFINED\" for the type\r\n     */\r\n    public readonly type = Constants.TEXTURETYPE_UNDEFINED;\r\n\r\n    /**\r\n     * Gets the unique id of this texture\r\n     */\r\n    public readonly uniqueId: number;\r\n\r\n    /**\r\n     * Constructs the texture\r\n     * @param video The video the texture should be wrapped around\r\n     */\r\n    constructor(video: HTMLVideoElement) {\r\n        this._video = video;\r\n        this.uniqueId = InternalTexture._Counter++;\r\n    }\r\n\r\n    /**\r\n     * Get if the texture is ready to be used (downloaded, converted, mip mapped...).\r\n     * @returns true if fully ready\r\n     */\r\n    public isReady(): boolean {\r\n        return this._video.readyState >= this._video.HAVE_CURRENT_DATA;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {}\r\n}\r\n"]}