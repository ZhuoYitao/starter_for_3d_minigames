{"version":3,"file":"baseTexture.js","sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/baseTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize, SerializationHelper, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport { RandomGUID } from \"../../Misc/guid\";\r\n\r\nimport \"../../Misc/fileTools\";\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { ThinTexture } from \"./thinTexture\";\r\nimport type { AbstractScene } from \"../../abstractScene\";\r\n\r\ndeclare type Animation = import(\"../../Animations/animation\").Animation;\r\n\r\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties the materials, post process, lights... might need\r\n * in order to make a correct use of the texture.\r\n */\r\nexport class BaseTexture extends ThinTexture implements IAnimatable {\r\n    /**\r\n     * Default anisotropic filtering level for the application.\r\n     * It is set to 4 as a good tradeoff between perf and quality.\r\n     */\r\n    public static DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the texture\r\n     */\r\n    @serialize()\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Define the name of the texture.\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information.\r\n     */\r\n    @serialize()\r\n    public metadata: any = null;\r\n\r\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\r\n    public reservedDataStore: any = null;\r\n\r\n    @serialize(\"hasAlpha\")\r\n    private _hasAlpha = false;\r\n    /**\r\n     * Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).\r\n     */\r\n    public set hasAlpha(value: boolean) {\r\n        if (this._hasAlpha === value) {\r\n            return;\r\n        }\r\n        this._hasAlpha = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get hasAlpha(): boolean {\r\n        return this._hasAlpha;\r\n    }\r\n\r\n    @serialize(\"getAlphaFromRGB\")\r\n    private _getAlphaFromRGB = false;\r\n    /**\r\n     * Defines if the alpha value should be determined via the rgb values.\r\n     * If true the luminance of the pixel might be used to find the corresponding alpha value.\r\n     */\r\n    public set getAlphaFromRGB(value: boolean) {\r\n        if (this._getAlphaFromRGB === value) {\r\n            return;\r\n        }\r\n        this._getAlphaFromRGB = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get getAlphaFromRGB(): boolean {\r\n        return this._getAlphaFromRGB;\r\n    }\r\n\r\n    /**\r\n     * Intensity or strength of the texture.\r\n     * It is commonly used by materials to fine tune the intensity of the texture\r\n     */\r\n    @serialize()\r\n    public level = 1;\r\n\r\n    @serialize(\"coordinatesIndex\")\r\n    protected _coordinatesIndex = 0;\r\n\r\n    /**\r\n     * Define the UV channel to use starting from 0 and defaulting to 0.\r\n     * This is part of the texture as textures usually maps to one uv set.\r\n     */\r\n    public set coordinatesIndex(value: number) {\r\n        if (this._coordinatesIndex === value) {\r\n            return;\r\n        }\r\n        this._coordinatesIndex = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get coordinatesIndex(): number {\r\n        return this._coordinatesIndex;\r\n    }\r\n\r\n    @serialize(\"coordinatesMode\")\r\n    protected _coordinatesMode = Constants.TEXTURE_EXPLICIT_MODE;\r\n\r\n    /**\r\n     * How a texture is mapped.\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 0     | EXPLICIT_MODE                       |             |\r\n     * | 1     | SPHERICAL_MODE                      |             |\r\n     * | 2     | PLANAR_MODE                         |             |\r\n     * | 3     | CUBIC_MODE                          |             |\r\n     * | 4     | PROJECTION_MODE                     |             |\r\n     * | 5     | SKYBOX_MODE                         |             |\r\n     * | 6     | INVCUBIC_MODE                       |             |\r\n     * | 7     | EQUIRECTANGULAR_MODE                |             |\r\n     * | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |\r\n     * | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |\r\n     */\r\n    public set coordinatesMode(value: number) {\r\n        if (this._coordinatesMode === value) {\r\n            return;\r\n        }\r\n        this._coordinatesMode = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get coordinatesMode(): number {\r\n        return this._coordinatesMode;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public get wrapU() {\r\n        return this._wrapU;\r\n    }\r\n    public set wrapU(value: number) {\r\n        this._wrapU = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public get wrapV() {\r\n        return this._wrapV;\r\n    }\r\n    public set wrapV(value: number) {\r\n        this._wrapV = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public wrapR = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n    /**\r\n     * With compliant hardware and browser (supporting anisotropic filtering)\r\n     * this defines the level of anisotropic filtering in the texture.\r\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n     */\r\n    @serialize()\r\n    public anisotropicFilteringLevel = BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;\r\n\r\n    private _isCube = false;\r\n    /**\r\n     * Define if the texture is a cube texture or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public get isCube(): boolean {\r\n        if (!this._texture) {\r\n            return this._isCube;\r\n        }\r\n\r\n        return this._texture.isCube;\r\n    }\r\n\r\n    public set isCube(value: boolean) {\r\n        if (!this._texture) {\r\n            this._isCube = value;\r\n        } else {\r\n            this._texture.isCube = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public get is3D(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is3D;\r\n    }\r\n\r\n    public set is3D(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is3D = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public get is2DArray(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is2DArray;\r\n    }\r\n\r\n    public set is2DArray(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is2DArray = value;\r\n    }\r\n\r\n    private _gammaSpace = true;\r\n    /**\r\n     * Define if the texture contains data in gamma space (most of the png/jpg aside bump).\r\n     * HDR texture are usually stored in linear space.\r\n     * This only impacts the PBR and Background materials\r\n     */\r\n    @serialize()\r\n    public get gammaSpace(): boolean {\r\n        if (!this._texture) {\r\n            return this._gammaSpace;\r\n        } else {\r\n            if (this._texture._gammaSpace === null) {\r\n                this._texture._gammaSpace = this._gammaSpace;\r\n            }\r\n        }\r\n\r\n        return this._texture._gammaSpace && !this._texture._useSRGBBuffer;\r\n    }\r\n\r\n    public set gammaSpace(gamma: boolean) {\r\n        if (!this._texture) {\r\n            if (this._gammaSpace === gamma) {\r\n                return;\r\n            }\r\n\r\n            this._gammaSpace = gamma;\r\n        } else {\r\n            if (this._texture._gammaSpace === gamma) {\r\n                return;\r\n            }\r\n            this._texture._gammaSpace = gamma;\r\n        }\r\n\r\n        this._markAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets whether or not the texture contains RGBD data.\r\n     */\r\n    public get isRGBD(): boolean {\r\n        return this._texture != null && this._texture._isRGBD;\r\n    }\r\n    public set isRGBD(value: boolean) {\r\n        if (this._texture) {\r\n            this._texture._isRGBD = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Is Z inverted in the texture (useful in a cube texture).\r\n     */\r\n    @serialize()\r\n    public invertZ = false;\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    public get noMipmap(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    @serialize()\r\n    public lodLevelInAlpha = false;\r\n\r\n    /**\r\n     * With prefiltered texture, defined the offset used during the prefiltering steps.\r\n     */\r\n    @serialize()\r\n    public get lodGenerationOffset(): number {\r\n        if (this._texture) {\r\n            return this._texture._lodGenerationOffset;\r\n        }\r\n\r\n        return 0.0;\r\n    }\r\n    public set lodGenerationOffset(value: number) {\r\n        if (this._texture) {\r\n            this._texture._lodGenerationOffset = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * With prefiltered texture, defined the scale used during the prefiltering steps.\r\n     */\r\n    @serialize()\r\n    public get lodGenerationScale(): number {\r\n        if (this._texture) {\r\n            return this._texture._lodGenerationScale;\r\n        }\r\n\r\n        return 0.0;\r\n    }\r\n    public set lodGenerationScale(value: number) {\r\n        if (this._texture) {\r\n            this._texture._lodGenerationScale = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * With prefiltered texture, defined if the specular generation is based on a linear ramp.\r\n     * By default we are using a log2 of the linear roughness helping to keep a better resolution for\r\n     * average roughness values.\r\n     */\r\n    @serialize()\r\n    public get linearSpecularLOD(): boolean {\r\n        if (this._texture) {\r\n            return this._texture._linearSpecularLOD;\r\n        }\r\n\r\n        return false;\r\n    }\r\n    public set linearSpecularLOD(value: boolean) {\r\n        if (this._texture) {\r\n            this._texture._linearSpecularLOD = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * In case a better definition than spherical harmonics is required for the diffuse part of the environment.\r\n     * You can set the irradiance texture to rely on a texture instead of the spherical approach.\r\n     * This texture need to have the same characteristics than its parent (Cube vs 2d, coordinates mode, Gamma/Linear, RGBD).\r\n     */\r\n    @serializeAsTexture()\r\n    public get irradianceTexture(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._irradianceTexture;\r\n        }\r\n\r\n        return null;\r\n    }\r\n    public set irradianceTexture(value: Nullable<BaseTexture>) {\r\n        if (this._texture) {\r\n            this._texture._irradianceTexture = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a render target.\r\n     */\r\n    @serialize()\r\n    public isRenderTarget = false;\r\n\r\n    /**\r\n     * Define the unique id of the texture in the scene.\r\n     */\r\n    public get uid(): string {\r\n        if (!this._uid) {\r\n            this._uid = RandomGUID();\r\n        }\r\n        return this._uid;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _prefiltered: boolean = false;\r\n    /** @hidden */\r\n    public _forceSerialize: boolean = false;\r\n\r\n    /**\r\n     * Return a string representation of the texture.\r\n     * @returns the texture as a string\r\n     */\r\n    public toString(): string {\r\n        return this.name;\r\n    }\r\n\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"BaseTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseTexture\";\r\n    }\r\n\r\n    /**\r\n     * Define the list of animation attached to the texture.\r\n     */\r\n    public animations = new Array<Animation>();\r\n\r\n    /**\r\n     * An event triggered when the texture is disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<BaseTexture>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<BaseTexture>> = null;\r\n    /**\r\n     * Callback triggered when the texture has been disposed.\r\n     * Kept for back compatibility, you can use the onDisposeObservable instead.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    protected _scene: Nullable<Scene> = null;\r\n\r\n    /** @hidden */\r\n    private _uid: Nullable<string> = null;\r\n\r\n    /**\r\n     * Define if the texture is preventing a material to render or not.\r\n     * If not and the texture is not ready, the engine will use a default black texture instead.\r\n     */\r\n    public get isBlocking(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    protected _loadingError: boolean = false;\r\n    protected _errorObject?: {\r\n        message?: string;\r\n        exception?: any;\r\n    };\r\n\r\n    /**\r\n     * Was there any loading error?\r\n     */\r\n    public get loadingError(): boolean {\r\n        return this._loadingError;\r\n    }\r\n\r\n    /**\r\n     * If a loading error occurred this object will be populated with information about the error.\r\n     */\r\n    public get errorObject():\r\n        | {\r\n              message?: string;\r\n              exception?: any;\r\n          }\r\n        | undefined {\r\n        return this._errorObject;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new BaseTexture.\r\n     * Base class of all the textures in babylon.\r\n     * It groups all the common properties the materials, post process, lights... might need\r\n     * in order to make a correct use of the texture.\r\n     * @param sceneOrEngine Define the scene or engine the texture belongs to\r\n     */\r\n    constructor(sceneOrEngine?: Nullable<Scene | ThinEngine>) {\r\n        super(null);\r\n\r\n        if (sceneOrEngine) {\r\n            if (BaseTexture._IsScene(sceneOrEngine)) {\r\n                this._scene = sceneOrEngine;\r\n            } else {\r\n                this._engine = sceneOrEngine;\r\n            }\r\n        } else {\r\n            this._scene = EngineStore.LastCreatedScene;\r\n        }\r\n\r\n        if (this._scene) {\r\n            this.uniqueId = this._scene.getUniqueId();\r\n            this._scene.addTexture(this);\r\n            this._engine = this._scene.getEngine();\r\n        }\r\n\r\n        this._uid = null;\r\n    }\r\n\r\n    /**\r\n     * Get the scene the texture belongs to.\r\n     * @returns the scene or null if undefined\r\n     */\r\n    public getScene(): Nullable<Scene> {\r\n        return this._scene;\r\n    }\r\n\r\n    /** @hidden */\r\n    protected _getEngine(): Nullable<ThinEngine> {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Checks if the texture has the same transform matrix than another texture\r\n     * @param texture texture to check against\r\n     * @returns true if the transforms are the same, else false\r\n     */\r\n    public checkTransformsAreIdentical(texture: Nullable<BaseTexture>): boolean {\r\n        return texture !== null;\r\n    }\r\n\r\n    /**\r\n     * Get the texture transform matrix used to offset tile the texture for instance.\r\n     * @returns the transformation matrix\r\n     */\r\n    public getTextureMatrix(): Matrix {\r\n        return <Matrix>Matrix.IdentityReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Get the texture reflection matrix used to rotate/transform the reflection.\r\n     * @returns the reflection matrix\r\n     */\r\n    public getReflectionTextureMatrix(): Matrix {\r\n        return <Matrix>Matrix.IdentityReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Get if the texture is ready to be consumed (either it is ready or it is not blocking)\r\n     * @returns true if ready, not blocking or if there was an error loading the texture\r\n     */\r\n    public isReadyOrNotBlocking(): boolean {\r\n        return !this.isBlocking || this.isReady() || this.loadingError;\r\n    }\r\n\r\n    /**\r\n     * Scales the texture if is `canRescale()`\r\n     * @param ratio the resize factor we want to use to rescale\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public scale(ratio: number): void {}\r\n\r\n    /**\r\n     * Get if the texture can rescale.\r\n     */\r\n    public get canRescale(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @param url\r\n     * @param noMipmap\r\n     * @param sampling\r\n     * @param invertY\r\n     * @param useSRGBBuffer\r\n     * @hidden\r\n     */\r\n    public _getFromCache(url: Nullable<string>, noMipmap: boolean, sampling?: number, invertY?: boolean, useSRGBBuffer?: boolean): Nullable<InternalTexture> {\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        const correctedUseSRGBBuffer = engine._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);\r\n\r\n        const texturesCache = engine.getLoadedTexturesCache();\r\n        for (let index = 0; index < texturesCache.length; index++) {\r\n            const texturesCacheEntry = texturesCache[index];\r\n\r\n            if (useSRGBBuffer === undefined || correctedUseSRGBBuffer === texturesCacheEntry._useSRGBBuffer) {\r\n                if (invertY === undefined || invertY === texturesCacheEntry.invertY) {\r\n                    if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {\r\n                        if (!sampling || sampling === texturesCacheEntry.samplingMode) {\r\n                            texturesCacheEntry.incrementReferences();\r\n                            return texturesCacheEntry;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {}\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get the texture underlying type (INT, FLOAT...)\r\n     */\r\n    public get textureType(): number {\r\n        if (!this._texture) {\r\n            return Constants.TEXTURETYPE_UNSIGNED_INT;\r\n        }\r\n\r\n        return this._texture.type !== undefined ? this._texture.type : Constants.TEXTURETYPE_UNSIGNED_INT;\r\n    }\r\n\r\n    /**\r\n     * Get the texture underlying format (RGB, RGBA...)\r\n     */\r\n    public get textureFormat(): number {\r\n        if (!this._texture) {\r\n            return Constants.TEXTUREFORMAT_RGBA;\r\n        }\r\n\r\n        return this._texture.format !== undefined ? this._texture.format : Constants.TEXTUREFORMAT_RGBA;\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures need to be re-calculated for all materials\r\n     */\r\n    protected _markAllSubMeshesAsTexturesDirty() {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.\r\n     * This will returns an RGBA array buffer containing either in values (0-255) or\r\n     * float values (0-1) depending of the underlying buffer type.\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @param buffer defines a user defined buffer to fill with data (can be null)\r\n     * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\r\n     * @param noDataConversion false to convert the data to Uint8Array (if texture type is UNSIGNED_BYTE) or to Float32Array (if texture type is anything but UNSIGNED_BYTE). If true, the type of the generated buffer (if buffer==null) will depend on the type of the texture\r\n     * @param x defines the region x coordinates to start reading from (default to 0)\r\n     * @param y defines the region y coordinates to start reading from (default to 0)pe is UNSIGNED_BYTE) or to Float32Array (if texture type is anything but UNSIGNED_BYTE). If true, the type of the generated buffer (if buffer==null) will depend on the type of the texture\r\n     * @param width defines the region width to read from (default to the texture size at level)\r\n     * @param height defines the region width to read from (default to the texture size at level)\r\n     * @returns The Array buffer promise containing the pixels data.\r\n     */\r\n    public readPixels(\r\n        faceIndex = 0,\r\n        level = 0,\r\n        buffer: Nullable<ArrayBufferView> = null,\r\n        flushRenderer = true,\r\n        noDataConversion = false,\r\n        x = 0,\r\n        y = 0,\r\n        width = Number.MAX_VALUE,\r\n        height = Number.MAX_VALUE\r\n    ): Nullable<Promise<ArrayBufferView>> {\r\n        if (!this._texture) {\r\n            return null;\r\n        }\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        const size = this.getSize();\r\n        let maxWidth = size.width;\r\n        let maxHeight = size.height;\r\n        if (level !== 0) {\r\n            maxWidth = maxWidth / Math.pow(2, level);\r\n            maxHeight = maxHeight / Math.pow(2, level);\r\n            maxWidth = Math.round(maxWidth);\r\n            maxHeight = Math.round(maxHeight);\r\n        }\r\n\r\n        width = Math.min(maxWidth, width);\r\n        height = Math.min(maxHeight, height);\r\n\r\n        try {\r\n            if (this._texture.isCube) {\r\n                return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y);\r\n            }\r\n\r\n            return engine._readTexturePixels(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion, x, y);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param faceIndex\r\n     * @param level\r\n     * @param buffer\r\n     * @param flushRenderer\r\n     * @param noDataConversion\r\n     * @hidden\r\n     */\r\n    public _readPixelsSync(faceIndex = 0, level = 0, buffer: Nullable<ArrayBufferView> = null, flushRenderer = true, noDataConversion = false): Nullable<ArrayBufferView> {\r\n        if (!this._texture) {\r\n            return null;\r\n        }\r\n\r\n        const size = this.getSize();\r\n        let width = size.width;\r\n        let height = size.height;\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        if (level != 0) {\r\n            width = width / Math.pow(2, level);\r\n            height = height / Math.pow(2, level);\r\n\r\n            width = Math.round(width);\r\n            height = Math.round(height);\r\n        }\r\n\r\n        try {\r\n            if (this._texture.isCube) {\r\n                return engine._readTexturePixelsSync(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion);\r\n            }\r\n\r\n            return engine._readTexturePixelsSync(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public get _lodTextureHigh(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureHigh;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @hidden */\r\n    public get _lodTextureMid(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureMid;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @hidden */\r\n    public get _lodTextureLow(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureLow;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._scene) {\r\n            // Animations\r\n            if (this._scene.stopAnimation) {\r\n                this._scene.stopAnimation(this);\r\n            }\r\n\r\n            // Remove from scene\r\n            this._scene._removePendingData(this);\r\n            const index = this._scene.textures.indexOf(this);\r\n\r\n            if (index >= 0) {\r\n                this._scene.textures.splice(index, 1);\r\n            }\r\n            this._scene.onTextureRemovedObservable.notifyObservers(this);\r\n            this._scene = null;\r\n\r\n            if (this._parentContainer) {\r\n                const index = this._parentContainer.textures.indexOf(this);\r\n                if (index > -1) {\r\n                    this._parentContainer.textures.splice(index, 1);\r\n                }\r\n                this._parentContainer = null;\r\n            }\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n\r\n        this.metadata = null;\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Serialize the texture into a JSON representation that can be parsed later on.\r\n     * @returns the JSON representation of the texture\r\n     */\r\n    public serialize(): any {\r\n        if (!this.name) {\r\n            return null;\r\n        }\r\n\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Helper function to be called back once a list of texture contains only ready textures.\r\n     * @param textures Define the list of textures to wait for\r\n     * @param callback Define the callback triggered once the entire list will be ready\r\n     */\r\n    public static WhenAllReady(textures: BaseTexture[], callback: () => void): void {\r\n        let numRemaining = textures.length;\r\n        if (numRemaining === 0) {\r\n            callback();\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < textures.length; i++) {\r\n            const texture = textures[i];\r\n\r\n            if (texture.isReady()) {\r\n                if (--numRemaining === 0) {\r\n                    callback();\r\n                }\r\n            } else {\r\n                const onLoadObservable = (texture as any).onLoadObservable as Observable<BaseTexture>;\r\n\r\n                if (onLoadObservable) {\r\n                    onLoadObservable.addOnce(() => {\r\n                        if (--numRemaining === 0) {\r\n                            callback();\r\n                        }\r\n                    });\r\n                } else {\r\n                    if (--numRemaining === 0) {\r\n                        callback();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _IsScene(sceneOrEngine: Scene | ThinEngine): sceneOrEngine is Scene {\r\n        return sceneOrEngine.getClassName() === \"Scene\";\r\n    }\r\n}\r\n"]}