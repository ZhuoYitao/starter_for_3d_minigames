{"version":3,"file":"cubeTexture.js","sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/cubeTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize, serializeAsMatrix, SerializationHelper } from \"../../Misc/decorators\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore\";\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\n\r\nimport \"../../Engines/Extensions/engine.cubeTexture\";\r\nimport { StartsWith } from \"../../Misc/stringTools\";\r\nimport { Observable } from \"../../Misc/observable\";\r\n\r\n/**\r\n * Class for creating a cube texture\r\n */\r\nexport class CubeTexture extends BaseTexture {\r\n    private _delayedOnLoad: Nullable<() => void>;\r\n    private _delayedOnError: Nullable<(message?: string, exception?: any) => void>;\r\n    private _lodScale: number = 0.8;\r\n    private _lodOffset: number = 0;\r\n\r\n    /**\r\n     * Observable triggered once the texture has been loaded.\r\n     */\r\n    public onLoadObservable: Observable<CubeTexture> = new Observable<CubeTexture>();\r\n\r\n    /**\r\n     * The url of the texture\r\n     */\r\n    @serialize()\r\n    public url: string;\r\n\r\n    /**\r\n     * Gets or sets the center of the bounding box associated with the cube texture.\r\n     * It must define where the camera used to render the texture was set\r\n     * @see https://doc.babylonjs.com/how_to/reflect#using-local-cubemap-mode\r\n     */\r\n    public boundingBoxPosition = Vector3.Zero();\r\n\r\n    private _boundingBoxSize: Vector3;\r\n\r\n    /**\r\n     * Gets or sets the size of the bounding box associated with the cube texture\r\n     * When defined, the cubemap will switch to local mode\r\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\r\n     * @example https://www.babylonjs-playground.com/#RNASML\r\n     */\r\n    public set boundingBoxSize(value: Vector3) {\r\n        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\r\n            return;\r\n        }\r\n        this._boundingBoxSize = value;\r\n        const scene = this.getScene();\r\n        if (scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the bounding box size\r\n     * @see https://doc.babylonjs.com/how_to/reflect#using-local-cubemap-mode\r\n     */\r\n    public get boundingBoxSize(): Vector3 {\r\n        return this._boundingBoxSize;\r\n    }\r\n\r\n    protected _rotationY: number = 0;\r\n\r\n    /**\r\n     * Sets texture matrix rotation angle around Y axis in radians.\r\n     */\r\n    @serialize(\"rotationY\")\r\n    public set rotationY(value: number) {\r\n        this._rotationY = value;\r\n        this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));\r\n    }\r\n    /**\r\n     * Gets texture matrix rotation angle around Y axis radians.\r\n     */\r\n    public get rotationY(): number {\r\n        return this._rotationY;\r\n    }\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    public get noMipmap(): boolean {\r\n        return this._noMipmap;\r\n    }\r\n\r\n    private _noMipmap: boolean;\r\n\r\n    @serialize(\"files\")\r\n    private _files: Nullable<string[]> = null;\r\n\r\n    @serialize(\"forcedExtension\")\r\n    protected _forcedExtension: Nullable<string> = null;\r\n\r\n    /**\r\n     * Gets the forced extension (if any)\r\n     */\r\n    public get forcedExtension(): Nullable<string> {\r\n        return this._forcedExtension;\r\n    }\r\n\r\n    @serialize(\"extensions\")\r\n    private _extensions: Nullable<string[]> = null;\r\n\r\n    @serializeAsMatrix(\"textureMatrix\")\r\n    private _textureMatrix: Matrix;\r\n\r\n    private _format: number;\r\n    private _createPolynomials: boolean;\r\n    private _loaderOptions: any;\r\n    private _useSRGBBuffer?: boolean;\r\n\r\n    /**\r\n     * Creates a cube texture from an array of image urls\r\n     * @param files defines an array of image urls\r\n     * @param scene defines the hosting scene\r\n     * @param noMipmap specifies if mip maps are not used\r\n     * @returns a cube texture\r\n     */\r\n    public static CreateFromImages(files: string[], scene: Scene, noMipmap?: boolean): CubeTexture {\r\n        let rootUrlKey = \"\";\r\n\r\n        files.forEach((url) => (rootUrlKey += url));\r\n\r\n        return new CubeTexture(rootUrlKey, scene, null, noMipmap, files);\r\n    }\r\n\r\n    /**\r\n     * Creates and return a texture created from prefilterd data by tools like IBL Baker or Lys.\r\n     * @param url defines the url of the prefiltered texture\r\n     * @param scene defines the scene the texture is attached to\r\n     * @param forcedExtension defines the extension of the file if different from the url\r\n     * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\r\n     * @return the prefiltered texture\r\n     */\r\n    public static CreateFromPrefilteredData(url: string, scene: Scene, forcedExtension: any = null, createPolynomials: boolean = true) {\r\n        const oldValue = scene.useDelayedTextureLoading;\r\n        scene.useDelayedTextureLoading = false;\r\n\r\n        const result = new CubeTexture(url, scene, null, false, null, null, null, undefined, true, forcedExtension, createPolynomials);\r\n\r\n        scene.useDelayedTextureLoading = oldValue;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a cube texture to use with reflection for instance. It can be based upon dds or six images as well\r\n     * as prefiltered data.\r\n     * @param rootUrl defines the url of the texture or the root name of the six images\r\n     * @param sceneOrEngine defines the scene or engine the texture is attached to\r\n     * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...\r\n     * @param noMipmap defines if mipmaps should be created or not\r\n     * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\r\n     * @param onLoad defines a callback triggered at the end of the file load if no errors occurred\r\n     * @param onError defines a callback triggered in case of error during load\r\n     * @param format defines the internal format to use for the texture once loaded\r\n     * @param prefiltered defines whether or not the texture is created from prefiltered data\r\n     * @param forcedExtension defines the extensions to use (force a special type of file to load) in case it is different from the file name\r\n     * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\r\n     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param useSRGBBuffer Defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU) (default: false)\r\n     * @return the cube texture\r\n     */\r\n    constructor(\r\n        rootUrl: string,\r\n        sceneOrEngine: Scene | ThinEngine,\r\n        extensions: Nullable<string[]> = null,\r\n        noMipmap: boolean = false,\r\n        files: Nullable<string[]> = null,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        prefiltered = false,\r\n        forcedExtension: any = null,\r\n        createPolynomials: boolean = false,\r\n        lodScale: number = 0.8,\r\n        lodOffset: number = 0,\r\n        loaderOptions?: any,\r\n        useSRGBBuffer?: boolean\r\n    ) {\r\n        super(sceneOrEngine);\r\n\r\n        this.name = rootUrl;\r\n        this.url = rootUrl;\r\n        this._noMipmap = noMipmap;\r\n        this.hasAlpha = false;\r\n        this._format = format;\r\n        this.isCube = true;\r\n        this._textureMatrix = Matrix.Identity();\r\n        this._createPolynomials = createPolynomials;\r\n        this.coordinatesMode = Texture.CUBIC_MODE;\r\n        this._extensions = extensions;\r\n        this._files = files;\r\n        this._forcedExtension = forcedExtension;\r\n        this._loaderOptions = loaderOptions;\r\n        this._useSRGBBuffer = useSRGBBuffer;\r\n        this._lodScale = lodScale;\r\n        this._lodOffset = lodOffset;\r\n\r\n        if (!rootUrl && !files) {\r\n            return;\r\n        }\r\n\r\n        this.updateURL(rootUrl, forcedExtension, onLoad, prefiltered, onError, extensions, this.getScene()?.useDelayedTextureLoading, files);\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"CubeTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"CubeTexture\";\r\n    }\r\n\r\n    /**\r\n     * Update the url (and optional buffer) of this texture if url was null during construction.\r\n     * @param url the url of the texture\r\n     * @param forcedExtension defines the extension to use\r\n     * @param onLoad callback called when the texture is loaded  (defaults to null)\r\n     * @param prefiltered Defines whether the updated texture is prefiltered or not\r\n     * @param onError callback called if there was an error during the loading process (defaults to null)\r\n     * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...\r\n     * @param delayLoad defines if the texture should be loaded now (false by default)\r\n     * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\r\n     */\r\n    public updateURL(\r\n        url: string,\r\n        forcedExtension?: string,\r\n        onLoad: Nullable<() => void> = null,\r\n        prefiltered: boolean = false,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        extensions: Nullable<string[]> = null,\r\n        delayLoad = false,\r\n        files: Nullable<string[]> = null\r\n    ): void {\r\n        if (!this.name || StartsWith(this.name, \"data:\")) {\r\n            this.name = url;\r\n        }\r\n        this.url = url;\r\n\r\n        if (forcedExtension) {\r\n            this._forcedExtension = forcedExtension;\r\n        }\r\n\r\n        const lastDot = url.lastIndexOf(\".\");\r\n        const extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : \"\";\r\n        const isDDS = extension.indexOf(\".dds\") === 0;\r\n        const isEnv = extension.indexOf(\".env\") === 0;\r\n\r\n        if (isEnv) {\r\n            this.gammaSpace = false;\r\n            this._prefiltered = false;\r\n            this.anisotropicFilteringLevel = 1;\r\n        } else {\r\n            this._prefiltered = prefiltered;\r\n\r\n            if (prefiltered) {\r\n                this.gammaSpace = false;\r\n                this.anisotropicFilteringLevel = 1;\r\n            }\r\n        }\r\n\r\n        if (files) {\r\n            this._files = files;\r\n        } else {\r\n            if (!isEnv && !isDDS && !extensions) {\r\n                extensions = [\"_px.jpg\", \"_py.jpg\", \"_pz.jpg\", \"_nx.jpg\", \"_ny.jpg\", \"_nz.jpg\"];\r\n            }\r\n\r\n            this._files = this._files || [];\r\n            this._files.length = 0;\r\n\r\n            if (extensions) {\r\n                for (let index = 0; index < extensions.length; index++) {\r\n                    this._files.push(url + extensions[index]);\r\n                }\r\n                this._extensions = extensions;\r\n            }\r\n        }\r\n\r\n        if (delayLoad) {\r\n            this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n            this._delayedOnLoad = onLoad;\r\n            this._delayedOnError = onError;\r\n        } else {\r\n            this._loadTexture(onLoad, onError);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delays loading of the cube texture\r\n     * @param forcedExtension defines the extension to use\r\n     */\r\n    public delayLoad(forcedExtension?: string): void {\r\n        if (this.delayLoadState !== Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            return;\r\n        }\r\n        if (forcedExtension) {\r\n            this._forcedExtension = forcedExtension;\r\n        }\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\r\n        this._loadTexture(this._delayedOnLoad, this._delayedOnError);\r\n    }\r\n\r\n    /**\r\n     * Returns the reflection texture matrix\r\n     * @returns the reflection texture matrix\r\n     */\r\n    public getReflectionTextureMatrix(): Matrix {\r\n        return this._textureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Sets the reflection texture matrix\r\n     * @param value Reflection texture matrix\r\n     */\r\n    public setReflectionTextureMatrix(value: Matrix): void {\r\n        if (value.updateFlag === this._textureMatrix.updateFlag) {\r\n            return;\r\n        }\r\n\r\n        if (value.isIdentity() !== this._textureMatrix.isIdentity()) {\r\n            this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => mat.getActiveTextures().indexOf(this) !== -1);\r\n        }\r\n\r\n        this._textureMatrix = value;\r\n    }\r\n\r\n    private _loadTexture(onLoad: Nullable<() => void> = null, onError: Nullable<(message?: string, exception?: any) => void> = null) {\r\n        const scene = this.getScene();\r\n        const oldTexture = this._texture;\r\n        this._texture = this._getFromCache(this.url, this._noMipmap, undefined, undefined, this._useSRGBBuffer);\r\n\r\n        const onLoadProcessing = () => {\r\n            this.onLoadObservable.notifyObservers(this);\r\n            if (oldTexture) {\r\n                oldTexture.dispose();\r\n                this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n            }\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n        };\r\n\r\n        const errorHandler = (message?: string, exception?: any) => {\r\n            this._loadingError = true;\r\n            this._errorObject = { message, exception };\r\n            if (onError) {\r\n                onError(message, exception);\r\n            }\r\n            Texture.OnTextureLoadErrorObservable.notifyObservers(this);\r\n        };\r\n\r\n        if (!this._texture) {\r\n            if (this._prefiltered) {\r\n                this._texture = this._getEngine()!.createPrefilteredCubeTexture(\r\n                    this.url,\r\n                    scene,\r\n                    this._lodScale,\r\n                    this._lodOffset,\r\n                    onLoad,\r\n                    errorHandler,\r\n                    this._format,\r\n                    this._forcedExtension,\r\n                    this._createPolynomials\r\n                );\r\n            } else {\r\n                this._texture = this._getEngine()!.createCubeTexture(\r\n                    this.url,\r\n                    scene,\r\n                    this._files,\r\n                    this._noMipmap,\r\n                    onLoad,\r\n                    errorHandler,\r\n                    this._format,\r\n                    this._forcedExtension,\r\n                    false,\r\n                    this._lodScale,\r\n                    this._lodOffset,\r\n                    null,\r\n                    this._loaderOptions,\r\n                    !!this._useSRGBBuffer\r\n                );\r\n            }\r\n\r\n            this._texture?.onLoadedObservable.add(() => this.onLoadObservable.notifyObservers(this));\r\n        } else {\r\n            if (this._texture.isReady) {\r\n                Tools.SetImmediate(() => onLoadProcessing());\r\n            } else {\r\n                this._texture.onLoadedObservable.add(() => onLoadProcessing());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses text to create a cube texture\r\n     * @param parsedTexture define the serialized text to read from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root url of the cube texture\r\n     * @returns a cube texture\r\n     */\r\n    public static Parse(parsedTexture: any, scene: Scene, rootUrl: string): CubeTexture {\r\n        const texture = SerializationHelper.Parse(\r\n            () => {\r\n                let prefiltered: boolean = false;\r\n                if (parsedTexture.prefiltered) {\r\n                    prefiltered = parsedTexture.prefiltered;\r\n                }\r\n                return new CubeTexture(\r\n                    rootUrl + parsedTexture.name,\r\n                    scene,\r\n                    parsedTexture.extensions,\r\n                    false,\r\n                    parsedTexture.files || null,\r\n                    null,\r\n                    null,\r\n                    undefined,\r\n                    prefiltered,\r\n                    parsedTexture.forcedExtension\r\n                );\r\n            },\r\n            parsedTexture,\r\n            scene\r\n        );\r\n\r\n        // Local Cubemaps\r\n        if (parsedTexture.boundingBoxPosition) {\r\n            texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);\r\n        }\r\n        if (parsedTexture.boundingBoxSize) {\r\n            texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);\r\n        }\r\n\r\n        // Animations\r\n        if (parsedTexture.animations) {\r\n            for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\r\n                const parsedAnimation = parsedTexture.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    texture.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Makes a clone, or deep copy, of the cube texture\r\n     * @returns a new cube texture\r\n     */\r\n    public clone(): CubeTexture {\r\n        let uniqueId = 0;\r\n\r\n        const newCubeTexture = SerializationHelper.Clone(() => {\r\n            const cubeTexture = new CubeTexture(this.url, this.getScene() || this._getEngine()!, this._extensions, this._noMipmap, this._files);\r\n            uniqueId = cubeTexture.uniqueId;\r\n\r\n            return cubeTexture;\r\n        }, this);\r\n\r\n        newCubeTexture.uniqueId = uniqueId;\r\n\r\n        return newCubeTexture;\r\n    }\r\n}\r\n\r\nTexture._CubeTextureParser = CubeTexture.Parse;\r\n// Some exporters relies on Tools.Instantiate\r\nRegisterClass(\"BABYLON.CubeTexture\", CubeTexture);\r\n"]}