{"version":3,"file":"multiRenderTarget.js","sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/multiRenderTarget.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Scene } from \"../../scene\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\nimport \"../../Engines/Extensions/engine.multiRender\";\r\nimport type { InternalTexture } from \"./internalTexture\";\r\n\r\n/**\r\n * Creation options of the multi render target texture.\r\n */\r\nexport interface IMultiRenderTargetOptions {\r\n    /**\r\n     * Define if the texture needs to create mip maps after render.\r\n     */\r\n    generateMipMaps?: boolean;\r\n    /**\r\n     * Define the types of all the draw buffers we want to create\r\n     */\r\n    types?: number[];\r\n    /**\r\n     * Define the sampling modes of all the draw buffers we want to create\r\n     */\r\n    samplingModes?: number[];\r\n    /**\r\n     * Define if a depth buffer is required\r\n     */\r\n    generateDepthBuffer?: boolean;\r\n    /**\r\n     * Define if a stencil buffer is required\r\n     */\r\n    generateStencilBuffer?: boolean;\r\n    /**\r\n     * Define if a depth texture is required instead of a depth buffer\r\n     */\r\n    generateDepthTexture?: boolean;\r\n    /**\r\n     * Define depth texture format to use\r\n     */\r\n    depthTextureFormat?: number;\r\n    /**\r\n     * Define the number of desired draw buffers\r\n     */\r\n    textureCount?: number;\r\n    /**\r\n     * Define if aspect ratio should be adapted to the texture or stay the scene one\r\n     */\r\n    doNotChangeAspectRatio?: boolean;\r\n    /**\r\n     * Define the default type of the buffers we are creating\r\n     */\r\n    defaultType?: number;\r\n    /**\r\n     * Define the default type of the buffers we are creating\r\n     */\r\n    drawOnlyOnFirstAttachmentByDefault?: boolean;\r\n}\r\n\r\n/**\r\n * A multi render target, like a render target provides the ability to render to a texture.\r\n * Unlike the render target, it can render to several draw buffers in one draw.\r\n * This is specially interesting in deferred rendering or for any effects requiring more than\r\n * just one color from a single pass.\r\n */\r\nexport class MultiRenderTarget extends RenderTargetTexture {\r\n    private _textures: Texture[];\r\n    private _multiRenderTargetOptions: IMultiRenderTargetOptions;\r\n    private _count: number;\r\n    private _drawOnlyOnFirstAttachmentByDefault: boolean;\r\n\r\n    /**\r\n     * Get if draw buffers are currently supported by the used hardware and browser.\r\n     */\r\n    public get isSupported(): boolean {\r\n        return this._engine?.getCaps().drawBuffersExtension ?? false;\r\n    }\r\n\r\n    /**\r\n     * Get the list of textures generated by the multi render target.\r\n     */\r\n    public get textures(): Texture[] {\r\n        return this._textures;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of textures in this MRT. This number can be different from `_textures.length` in case a depth texture is generated.\r\n     */\r\n    public get count(): number {\r\n        return this._count;\r\n    }\r\n\r\n    /**\r\n     * Get the depth texture generated by the multi render target if options.generateDepthTexture has been set\r\n     */\r\n    public get depthTexture(): Texture {\r\n        return this._textures[this._textures.length - 1];\r\n    }\r\n\r\n    /**\r\n     * Set the wrapping mode on U of all the textures we are rendering to.\r\n     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\r\n     */\r\n    public set wrapU(wrap: number) {\r\n        if (this._textures) {\r\n            for (let i = 0; i < this._textures.length; i++) {\r\n                this._textures[i].wrapU = wrap;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the wrapping mode on V of all the textures we are rendering to.\r\n     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\r\n     */\r\n    public set wrapV(wrap: number) {\r\n        if (this._textures) {\r\n            for (let i = 0; i < this._textures.length; i++) {\r\n                this._textures[i].wrapV = wrap;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instantiate a new multi render target texture.\r\n     * A multi render target, like a render target provides the ability to render to a texture.\r\n     * Unlike the render target, it can render to several draw buffers in one draw.\r\n     * This is specially interesting in deferred rendering or for any effects requiring more than\r\n     * just one color from a single pass.\r\n     * @param name Define the name of the texture\r\n     * @param size Define the size of the buffers to render to\r\n     * @param count Define the number of target we are rendering into\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param options Define the options used to create the multi render target\r\n     * @param textureNames Define the names to set to the textures (if count > 0 - optional)\r\n     */\r\n    constructor(name: string, size: any, count: number, scene?: Scene, options?: IMultiRenderTargetOptions, textureNames?: string[]) {\r\n        const generateMipMaps = options && options.generateMipMaps ? options.generateMipMaps : false;\r\n        const generateDepthTexture = options && options.generateDepthTexture ? options.generateDepthTexture : false;\r\n        const depthTextureFormat = options && options.depthTextureFormat ? options.depthTextureFormat : Constants.TEXTUREFORMAT_DEPTH16;\r\n        const doNotChangeAspectRatio = !options || options.doNotChangeAspectRatio === undefined ? true : options.doNotChangeAspectRatio;\r\n        const drawOnlyOnFirstAttachmentByDefault = options && options.drawOnlyOnFirstAttachmentByDefault ? options.drawOnlyOnFirstAttachmentByDefault : false;\r\n        super(name, size, scene, generateMipMaps, doNotChangeAspectRatio, undefined, undefined, undefined, undefined, undefined, undefined, undefined, true);\r\n\r\n        if (!this.isSupported) {\r\n            this.dispose();\r\n            return;\r\n        }\r\n\r\n        const types: number[] = [];\r\n        const samplingModes: number[] = [];\r\n        this._initTypes(count, types, samplingModes, options);\r\n\r\n        const generateDepthBuffer = !options || options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\r\n        const generateStencilBuffer = !options || options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\r\n\r\n        this._size = size;\r\n        this._multiRenderTargetOptions = {\r\n            samplingModes: samplingModes,\r\n            generateMipMaps: generateMipMaps,\r\n            generateDepthBuffer: generateDepthBuffer,\r\n            generateStencilBuffer: generateStencilBuffer,\r\n            generateDepthTexture: generateDepthTexture,\r\n            depthTextureFormat: depthTextureFormat,\r\n            types: types,\r\n            textureCount: count,\r\n        };\r\n\r\n        this._count = count;\r\n        this._drawOnlyOnFirstAttachmentByDefault = drawOnlyOnFirstAttachmentByDefault;\r\n\r\n        if (count > 0) {\r\n            this._createInternalTextures();\r\n            this._createTextures(textureNames);\r\n        }\r\n    }\r\n\r\n    private _initTypes(count: number, types: number[], samplingModes: number[], options?: IMultiRenderTargetOptions) {\r\n        for (let i = 0; i < count; i++) {\r\n            if (options && options.types && options.types[i] !== undefined) {\r\n                types.push(options.types[i]);\r\n            } else {\r\n                types.push(options && options.defaultType ? options.defaultType : Constants.TEXTURETYPE_UNSIGNED_INT);\r\n            }\r\n\r\n            if (options && options.samplingModes && options.samplingModes[i] !== undefined) {\r\n                samplingModes.push(options.samplingModes[i]);\r\n            } else {\r\n                samplingModes.push(Texture.BILINEAR_SAMPLINGMODE);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param forceFullRebuild\r\n     * @param textureNames\r\n     * @hidden\r\n     */\r\n    public _rebuild(forceFullRebuild: boolean = false, textureNames?: string[]): void {\r\n        if (this._count < 1) {\r\n            return;\r\n        }\r\n\r\n        this.releaseInternalTextures();\r\n        this._createInternalTextures();\r\n\r\n        if (forceFullRebuild) {\r\n            this._releaseTextures();\r\n            this._createTextures(textureNames);\r\n        }\r\n\r\n        const internalTextures = this._renderTarget!.textures!;\r\n        for (let i = 0; i < internalTextures.length; i++) {\r\n            const texture = this._textures[i];\r\n            texture._texture = internalTextures[i];\r\n        }\r\n\r\n        if (this.samples !== 1) {\r\n            this._renderTarget!.setSamples(this.samples, !this._drawOnlyOnFirstAttachmentByDefault, true);\r\n        }\r\n    }\r\n\r\n    private _createInternalTextures(): void {\r\n        this._renderTarget = this._getEngine()!.createMultipleRenderTarget(this._size, this._multiRenderTargetOptions, !this._drawOnlyOnFirstAttachmentByDefault);\r\n        this._texture = this._renderTarget.texture;\r\n    }\r\n\r\n    private _releaseTextures(): void {\r\n        if (this._textures) {\r\n            for (let i = 0; i < this._textures.length; i++) {\r\n                this._textures[i]._texture = null; // internal textures are released by a call to releaseInternalTextures()\r\n                this._textures[i].dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _createTextures(textureNames?: string[]): void {\r\n        const internalTextures = this._renderTarget!.textures!;\r\n        this._textures = [];\r\n        for (let i = 0; i < internalTextures.length; i++) {\r\n            const texture = new Texture(null, this.getScene());\r\n            if (textureNames?.[i]) {\r\n                texture.name = textureNames[i];\r\n            }\r\n            texture._texture = internalTextures[i];\r\n            this._textures.push(texture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Replaces an internal texture within the MRT. Useful to share textures between MultiRenderTarget.\r\n     * @param texture The new texture to set in the MRT\r\n     * @param index The index of the texture to replace\r\n     * @param disposePrevious Set to true if the previous internal texture should be disposed\r\n     */\r\n    public setInternalTexture(texture: InternalTexture, index: number, disposePrevious: boolean = true) {\r\n        if (!this.renderTarget) {\r\n            return;\r\n        }\r\n\r\n        if (index === 0) {\r\n            this._texture = texture;\r\n        }\r\n\r\n        this.renderTarget.setTexture(texture, index, disposePrevious);\r\n\r\n        if (!this.textures[index]) {\r\n            this.textures[index] = new Texture(null, this.getScene());\r\n        }\r\n        this.textures[index]._texture = texture;\r\n\r\n        this._count = this.renderTarget.textures ? this.renderTarget.textures.length : 0;\r\n\r\n        if (this._multiRenderTargetOptions.types) {\r\n            this._multiRenderTargetOptions.types[index] = texture.type;\r\n        }\r\n        if (this._multiRenderTargetOptions.samplingModes) {\r\n            this._multiRenderTargetOptions.samplingModes[index] = texture.samplingMode;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define the number of samples used if MSAA is enabled.\r\n     */\r\n    public get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    public set samples(value: number) {\r\n        if (this._renderTarget) {\r\n            this._samples = this._renderTarget.setSamples(value);\r\n        } else {\r\n            // In case samples are set with 0 textures created, we must save the desired samples value\r\n            this._samples = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resize all the textures in the multi render target.\r\n     * Be careful as it will recreate all the data in the new texture.\r\n     * @param size Define the new size\r\n     */\r\n    public resize(size: any) {\r\n        this._size = size;\r\n        this._rebuild();\r\n    }\r\n\r\n    /**\r\n     * Changes the number of render targets in this MRT\r\n     * Be careful as it will recreate all the data in the new texture.\r\n     * @param count new texture count\r\n     * @param options Specifies texture types and sampling modes for new textures\r\n     * @param textureNames Specifies the names of the textures (optional)\r\n     */\r\n    public updateCount(count: number, options?: IMultiRenderTargetOptions, textureNames?: string[]) {\r\n        this._multiRenderTargetOptions.textureCount = count;\r\n        this._count = count;\r\n\r\n        const types: number[] = [];\r\n        const samplingModes: number[] = [];\r\n\r\n        this._initTypes(count, types, samplingModes, options);\r\n        this._multiRenderTargetOptions.types = types;\r\n        this._multiRenderTargetOptions.samplingModes = samplingModes;\r\n        this._rebuild(true, textureNames);\r\n    }\r\n\r\n    protected _unbindFrameBuffer(engine: Engine, faceIndex: number): void {\r\n        if (this._renderTarget) {\r\n            engine.unBindMultiColorAttachmentFramebuffer(this._renderTarget, this.isCube, () => {\r\n                this.onAfterRenderObservable.notifyObservers(faceIndex);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the render targets and their associated resources\r\n     * @param doNotDisposeInternalTextures\r\n     */\r\n    public dispose(doNotDisposeInternalTextures = false): void {\r\n        this._releaseTextures();\r\n        if (!doNotDisposeInternalTextures) {\r\n            this.releaseInternalTextures();\r\n        } else {\r\n            // Prevent internal texture dispose in super.dispose\r\n            this._texture = null;\r\n        }\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Release all the underlying texture used as draw buffers.\r\n     */\r\n    public releaseInternalTextures(): void {\r\n        const internalTextures = this._renderTarget?.textures;\r\n\r\n        if (!internalTextures) {\r\n            return;\r\n        }\r\n\r\n        for (let i = internalTextures.length - 1; i >= 0; i--) {\r\n            this._textures[i]._texture = null;\r\n        }\r\n\r\n        this._renderTarget?.dispose();\r\n        this._renderTarget = null;\r\n    }\r\n}\r\n"]}