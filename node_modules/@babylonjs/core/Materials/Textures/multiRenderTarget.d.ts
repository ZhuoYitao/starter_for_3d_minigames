import type { Scene } from "../../scene";
import type { Engine } from "../../Engines/engine";
import { Texture } from "../../Materials/Textures/texture";
import { RenderTargetTexture } from "../../Materials/Textures/renderTargetTexture";
import "../../Engines/Extensions/engine.multiRender";
import type { InternalTexture } from "./internalTexture";
/**
 * Creation options of the multi render target texture.
 */
export interface IMultiRenderTargetOptions {
    /**
     * Define if the texture needs to create mip maps after render.
     */
    generateMipMaps?: boolean;
    /**
     * Define the types of all the draw buffers we want to create
     */
    types?: number[];
    /**
     * Define the sampling modes of all the draw buffers we want to create
     */
    samplingModes?: number[];
    /**
     * Define if a depth buffer is required
     */
    generateDepthBuffer?: boolean;
    /**
     * Define if a stencil buffer is required
     */
    generateStencilBuffer?: boolean;
    /**
     * Define if a depth texture is required instead of a depth buffer
     */
    generateDepthTexture?: boolean;
    /**
     * Define depth texture format to use
     */
    depthTextureFormat?: number;
    /**
     * Define the number of desired draw buffers
     */
    textureCount?: number;
    /**
     * Define if aspect ratio should be adapted to the texture or stay the scene one
     */
    doNotChangeAspectRatio?: boolean;
    /**
     * Define the default type of the buffers we are creating
     */
    defaultType?: number;
    /**
     * Define the default type of the buffers we are creating
     */
    drawOnlyOnFirstAttachmentByDefault?: boolean;
}
/**
 * A multi render target, like a render target provides the ability to render to a texture.
 * Unlike the render target, it can render to several draw buffers in one draw.
 * This is specially interesting in deferred rendering or for any effects requiring more than
 * just one color from a single pass.
 */
export declare class MultiRenderTarget extends RenderTargetTexture {
    private _textures;
    private _multiRenderTargetOptions;
    private _count;
    private _drawOnlyOnFirstAttachmentByDefault;
    /**
     * Get if draw buffers are currently supported by the used hardware and browser.
     */
    get isSupported(): boolean;
    /**
     * Get the list of textures generated by the multi render target.
     */
    get textures(): Texture[];
    /**
     * Gets the number of textures in this MRT. This number can be different from `_textures.length` in case a depth texture is generated.
     */
    get count(): number;
    /**
     * Get the depth texture generated by the multi render target if options.generateDepthTexture has been set
     */
    get depthTexture(): Texture;
    /**
     * Set the wrapping mode on U of all the textures we are rendering to.
     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)
     */
    set wrapU(wrap: number);
    /**
     * Set the wrapping mode on V of all the textures we are rendering to.
     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)
     */
    set wrapV(wrap: number);
    /**
     * Instantiate a new multi render target texture.
     * A multi render target, like a render target provides the ability to render to a texture.
     * Unlike the render target, it can render to several draw buffers in one draw.
     * This is specially interesting in deferred rendering or for any effects requiring more than
     * just one color from a single pass.
     * @param name Define the name of the texture
     * @param size Define the size of the buffers to render to
     * @param count Define the number of target we are rendering into
     * @param scene Define the scene the texture belongs to
     * @param options Define the options used to create the multi render target
     * @param textureNames Define the names to set to the textures (if count > 0 - optional)
     */
    constructor(name: string, size: any, count: number, scene?: Scene, options?: IMultiRenderTargetOptions, textureNames?: string[]);
    private _initTypes;
    /**
     * @param forceFullRebuild
     * @param textureNames
     * @hidden
     */
    _rebuild(forceFullRebuild?: boolean, textureNames?: string[]): void;
    private _createInternalTextures;
    private _releaseTextures;
    private _createTextures;
    /**
     * Replaces an internal texture within the MRT. Useful to share textures between MultiRenderTarget.
     * @param texture The new texture to set in the MRT
     * @param index The index of the texture to replace
     * @param disposePrevious Set to true if the previous internal texture should be disposed
     */
    setInternalTexture(texture: InternalTexture, index: number, disposePrevious?: boolean): void;
    /**
     * Define the number of samples used if MSAA is enabled.
     */
    get samples(): number;
    set samples(value: number);
    /**
     * Resize all the textures in the multi render target.
     * Be careful as it will recreate all the data in the new texture.
     * @param size Define the new size
     */
    resize(size: any): void;
    /**
     * Changes the number of render targets in this MRT
     * Be careful as it will recreate all the data in the new texture.
     * @param count new texture count
     * @param options Specifies texture types and sampling modes for new textures
     * @param textureNames Specifies the names of the textures (optional)
     */
    updateCount(count: number, options?: IMultiRenderTargetOptions, textureNames?: string[]): void;
    protected _unbindFrameBuffer(engine: Engine, faceIndex: number): void;
    /**
     * Dispose the render targets and their associated resources
     * @param doNotDisposeInternalTextures
     */
    dispose(doNotDisposeInternalTextures?: boolean): void;
    /**
     * Release all the underlying texture used as draw buffers.
     */
    releaseInternalTextures(): void;
}
