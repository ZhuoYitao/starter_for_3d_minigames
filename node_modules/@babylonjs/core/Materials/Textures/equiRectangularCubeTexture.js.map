{"version":3,"file":"equiRectangularCubeTexture.js","sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/equiRectangularCubeTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { PanoramaToCubeMapTools } from \"../../Misc/HighDynamicRange/panoramaToCubemap\";\r\nimport { BaseTexture } from \"./baseTexture\";\r\nimport { Texture } from \"./texture\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { LoadImage } from \"../../Misc/fileTools\";\r\n\r\n/**\r\n * This represents a texture coming from an equirectangular image supported by the web browser canvas.\r\n */\r\nexport class EquiRectangularCubeTexture extends BaseTexture {\r\n    /** The six faces of the cube. */\r\n    private static _FacesMapping = [\"right\", \"left\", \"up\", \"down\", \"front\", \"back\"];\r\n\r\n    private _noMipmap: boolean;\r\n    private _onLoad: Nullable<() => void> = null;\r\n    private _onError: Nullable<() => void> = null;\r\n\r\n    /** The size of the cubemap. */\r\n    private _size: number;\r\n\r\n    /** The buffer of the image. */\r\n    private _buffer: ArrayBuffer;\r\n\r\n    /** The width of the input image. */\r\n    private _width: number;\r\n\r\n    /** The height of the input image. */\r\n    private _height: number;\r\n\r\n    /** The URL to the image. */\r\n    public url: string;\r\n\r\n    /**\r\n     * Instantiates an EquiRectangularCubeTexture from the following parameters.\r\n     * @param url The location of the image\r\n     * @param scene The scene the texture will be used in\r\n     * @param size The cubemap desired size (the more it increases the longer the generation will be)\r\n     * @param noMipmap Forces to not generate the mipmap if true\r\n     * @param gammaSpace Specifies if the texture will be used in gamma or linear space\r\n     * (the PBR material requires those textures in linear space, but the standard material would require them in Gamma space)\r\n     * @param onLoad — defines a callback called when texture is loaded\r\n     * @param onError — defines a callback called if there is an error\r\n     */\r\n    constructor(\r\n        url: string,\r\n        scene: Scene,\r\n        size: number,\r\n        noMipmap: boolean = false,\r\n        gammaSpace: boolean = true,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null\r\n    ) {\r\n        super(scene);\r\n\r\n        if (!url) {\r\n            throw new Error(\"Image url is not set\");\r\n        }\r\n\r\n        this._coordinatesMode = Texture.CUBIC_MODE;\r\n        this.name = url;\r\n        this.url = url;\r\n        this._size = size;\r\n        this._noMipmap = noMipmap;\r\n        this.gammaSpace = gammaSpace;\r\n        this._onLoad = onLoad;\r\n        this._onError = onError;\r\n\r\n        this.hasAlpha = false;\r\n        this.isCube = true;\r\n\r\n        this._texture = this._getFromCache(url, this._noMipmap);\r\n\r\n        if (!this._texture) {\r\n            if (!scene.useDelayedTextureLoading) {\r\n                this._loadImage(this._loadTexture.bind(this), this._onError);\r\n            } else {\r\n                this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n            }\r\n        } else if (onLoad) {\r\n            if (this._texture.isReady) {\r\n                Tools.SetImmediate(() => onLoad());\r\n            } else {\r\n                this._texture.onLoadedObservable.add(onLoad);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load the image data, by putting the image on a canvas and extracting its buffer.\r\n     * @param loadTextureCallback\r\n     * @param onError\r\n     */\r\n    private _loadImage(loadTextureCallback: () => void, onError: Nullable<(message?: string, exception?: any) => void>): void {\r\n        const canvas = document.createElement(\"canvas\");\r\n        LoadImage(\r\n            this.url,\r\n            (image) => {\r\n                this._width = image.width;\r\n                this._height = image.height;\r\n                canvas.width = this._width;\r\n                canvas.height = this._height;\r\n\r\n                const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n                ctx.drawImage(image, 0, 0);\r\n\r\n                const imageData = ctx.getImageData(0, 0, image.width, image.height);\r\n                this._buffer = imageData.data.buffer as ArrayBuffer;\r\n\r\n                canvas.remove();\r\n                loadTextureCallback();\r\n            },\r\n            (_, e) => {\r\n                if (onError) {\r\n                    onError(`${this.getClassName()} could not be loaded`, e);\r\n                }\r\n            },\r\n            null\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Convert the image buffer into a cubemap and create a CubeTexture.\r\n     */\r\n    private _loadTexture(): void {\r\n        const scene = this.getScene();\r\n        const callback = (): Nullable<ArrayBufferView[]> => {\r\n            const imageData = this._getFloat32ArrayFromArrayBuffer(this._buffer);\r\n\r\n            // Extract the raw linear data.\r\n            const data = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(imageData, this._width, this._height, this._size);\r\n\r\n            const results = [];\r\n\r\n            // Push each faces.\r\n            for (let i = 0; i < 6; i++) {\r\n                const dataFace = (data as any)[EquiRectangularCubeTexture._FacesMapping[i]];\r\n                results.push(dataFace);\r\n            }\r\n\r\n            return results;\r\n        };\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this._texture = scene\r\n            .getEngine()\r\n            .createRawCubeTextureFromUrl(\r\n                this.url,\r\n                scene,\r\n                this._size,\r\n                Constants.TEXTUREFORMAT_RGB,\r\n                scene.getEngine().getCaps().textureFloat ? Constants.TEXTURETYPE_FLOAT : Constants.TEXTURETYPE_UNSIGNED_INTEGER,\r\n                this._noMipmap,\r\n                callback,\r\n                null,\r\n                this._onLoad,\r\n                this._onError\r\n            );\r\n    }\r\n\r\n    /**\r\n     * Convert the ArrayBuffer into a Float32Array and drop the transparency channel.\r\n     * @param buffer The ArrayBuffer that should be converted.\r\n     * @returns The buffer as Float32Array.\r\n     */\r\n    private _getFloat32ArrayFromArrayBuffer(buffer: ArrayBuffer): Float32Array {\r\n        const dataView = new DataView(buffer);\r\n        const floatImageData = new Float32Array((buffer.byteLength * 3) / 4);\r\n\r\n        let k = 0;\r\n        for (let i = 0; i < buffer.byteLength; i++) {\r\n            // We drop the transparency channel, because we do not need/want it\r\n            if ((i + 1) % 4 !== 0) {\r\n                floatImageData[k++] = dataView.getUint8(i) / 255;\r\n            }\r\n        }\r\n\r\n        return floatImageData;\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"EquiRectangularCubeTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"EquiRectangularCubeTexture\";\r\n    }\r\n\r\n    /**\r\n     * Create a clone of the current EquiRectangularCubeTexture and return it.\r\n     * @returns A clone of the current EquiRectangularCubeTexture.\r\n     */\r\n    public clone(): EquiRectangularCubeTexture {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return this;\r\n        }\r\n\r\n        const newTexture = new EquiRectangularCubeTexture(this.url, scene, this._size, this._noMipmap, this.gammaSpace);\r\n\r\n        // Base texture\r\n        newTexture.level = this.level;\r\n        newTexture.wrapU = this.wrapU;\r\n        newTexture.wrapV = this.wrapV;\r\n        newTexture.coordinatesIndex = this.coordinatesIndex;\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n\r\n        return newTexture;\r\n    }\r\n}\r\n"]}