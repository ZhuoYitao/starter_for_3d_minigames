{"version":3,"file":"gpuUpdateParticles.compute.js","sourceRoot":"","sources":["../../../../../lts/core/generated/ShadersWGSL/gpuUpdateParticles.compute.ts"],"names":[],"mappings":"AAAA,eAAe;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AAErD,IAAM,IAAI,GAAG,iCAAiC,CAAC;AAC/C,IAAM,MAAM,GAAG,4kcA6Xd,CAAC;AACF,aAAa;AACb,WAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAC5C,cAAc;AACd,MAAM,CAAC,IAAM,+BAA+B,GAAG,EAAE,IAAI,MAAA,EAAE,MAAM,QAAA,EAAE,CAAC","sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"gpuUpdateParticlesComputeShader\";\nconst shader = `struct Particle {\rposition : vec3<f32>,\rage : f32,\rsize : vec3<f32>,\rlife : f32,\rseed : vec4<f32>,\rdirection : vec3<f32>,\rdummy0: f32,\r#ifdef CUSTOMEMITTER\ninitialPosition : vec3<f32>,\rdummy1: f32,\r#endif\n#ifndef COLORGRADIENTS\ncolor : vec4<f32>,\r#endif\n#ifndef BILLBOARD\ninitialDirection : vec3<f32>,\rdummy2: f32,\r#endif\n#ifdef NOISE\nnoiseCoordinates1 : vec3<f32>,\rdummy3: f32,\rnoiseCoordinates2 : vec3<f32>,\rdummy4: f32,\r#endif\n#ifdef ANGULARSPEEDGRADIENTS\nangle : f32,\r#else\nangle : vec2<f32>,\r#endif\n#ifdef ANIMATESHEET\ncellIndex : f32,\r#ifdef ANIMATESHEETRANDOMSTART\ncellStartOffset : f32,\r#endif\n#endif\n};\rstruct Particles {\rparticles : array<Particle>,\r};\rstruct SimParams {\rcurrentCount : f32,\rtimeDelta : f32,\rstopFactor : f32,\rrandomTextureSize: i32,\rlifeTime : vec2<f32>,\remitPower : vec2<f32>,\r#ifndef COLORGRADIENTS\ncolor1 : vec4<f32>,\rcolor2 : vec4<f32>,\r#endif\nsizeRange : vec2<f32>,\rscaleRange : vec4<f32>,\rangleRange : vec4<f32>,\rgravity : vec3<f32>,\r#ifdef LIMITVELOCITYGRADIENTS\nlimitVelocityDamping : f32,\r#endif\n#ifdef ANIMATESHEET\ncellInfos : vec4<f32>,\r#endif\n#ifdef NOISE\nnoiseStrength : vec3<f32>,\r#endif\n#ifndef LOCAL\nemitterWM : mat4x4<f32>,\r#endif\n#ifdef BOXEMITTER\ndirection1 : vec3<f32>,\rdirection2 : vec3<f32>,\rminEmitBox : vec3<f32>,\rmaxEmitBox : vec3<f32>,\r#endif\n#ifdef CONEEMITTER\nradius : vec2<f32>,\rconeAngle : f32,\rheight : vec2<f32>,\rdirectionRandomizer : f32,\r#endif\n#ifdef CYLINDEREMITTER\nradius : f32,\rheight : f32,\rradiusRange : f32,\r#ifdef DIRECTEDCYLINDEREMITTER\ndirection1 : vec3<f32>,\rdirection2 : vec3<f32>,\r#else\ndirectionRandomizer : f32,\r#endif\n#endif\n#ifdef HEMISPHERICEMITTER\nradius : f32,\rradiusRange : f32,\rdirectionRandomizer : f32,\r#endif\n#ifdef POINTEMITTER\ndirection1 : vec3<f32>,\rdirection2 : vec3<f32>,\r#endif\n#ifdef SPHEREEMITTER\nradius : f32,\rradiusRange : f32,\r#ifdef DIRECTEDSPHEREEMITTER\ndirection1 : vec3<f32>,\rdirection2 : vec3<f32>,\r#else\ndirectionRandomizer : f32,\r#endif\n#endif\n};\r@binding(0) @group(0) var<uniform> params : SimParams;\r@binding(1) @group(0) var<storage,read> particlesIn : Particles;\r@binding(2) @group(0) var<storage,read_write> particlesOut : Particles;\r@binding(3) @group(0) var randomTexture : texture_2d<f32>;\r@binding(4) @group(0) var randomTexture2 : texture_2d<f32>;\r#ifdef SIZEGRADIENTS\n@binding(0) @group(1) var sizeGradientSampler : sampler;\r@binding(1) @group(1) var sizeGradientTexture : texture_2d<f32>;\r#endif \n#ifdef ANGULARSPEEDGRADIENTS\n@binding(2) @group(1) var angularSpeedGradientSampler : sampler;\r@binding(3) @group(1) var angularSpeedGradientTexture : texture_2d<f32>;\r#endif \n#ifdef VELOCITYGRADIENTS\n@binding(4) @group(1) var velocityGradientSampler : sampler;\r@binding(5) @group(1) var velocityGradientTexture : texture_2d<f32>;\r#endif\n#ifdef LIMITVELOCITYGRADIENTS\n@binding(6) @group(1) var limitVelocityGradientSampler : sampler;\r@binding(7) @group(1) var limitVelocityGradientTexture : texture_2d<f32>;\r#endif\n#ifdef DRAGGRADIENTS\n@binding(8) @group(1) var dragGradientSampler : sampler;\r@binding(9) @group(1) var dragGradientTexture : texture_2d<f32>;\r#endif\n#ifdef NOISE\n@binding(10) @group(1) var noiseSampler : sampler;\r@binding(11) @group(1) var noiseTexture : texture_2d<f32>;\r#endif\nfn getRandomVec3(offset : f32,vertexID : f32)->vec3<f32> {\rreturn textureLoad(randomTexture2,vec2<i32>(i32(vertexID*offset/params.currentCount*f32(params.randomTextureSize)) % params.randomTextureSize,0),0).rgb;\r}\rfn getRandomVec4(offset : f32,vertexID : f32)->vec4<f32> {\rreturn textureLoad(randomTexture,vec2<i32>(i32(vertexID*offset/params.currentCount*f32(params.randomTextureSize)) % params.randomTextureSize,0),0);\r}\r@stage(compute) @workgroup_size(64)\rfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\rlet index : u32=GlobalInvocationID.x;\rlet vertexID : f32=f32(index);\rif (index>=u32(params.currentCount)) {\rreturn;\r}\rlet PI : f32=3.14159;\rlet timeDelta : f32=params.timeDelta;\rlet newAge : f32=particlesIn.particles[index].age+timeDelta;\rlet life : f32=particlesIn.particles[index].life;\rlet seed : vec4<f32>=particlesIn.particles[index].seed;\rlet direction : vec3<f32>=particlesIn.particles[index].direction;\rif (newAge>=life && params.stopFactor != 0.) {\rvar newPosition : vec3<f32>;\rvar newDirection : vec3<f32>;\rlet randoms : vec4<f32>=getRandomVec4(seed.x,vertexID);\rlet outLife : f32=params.lifeTime.x+(params.lifeTime.y-params.lifeTime.x)*randoms.r;\rparticlesOut.particles[index].life=outLife;\rparticlesOut.particles[index].age=newAge-life;\rparticlesOut.particles[index].seed=seed;\rvar sizex : f32;\r#ifdef SIZEGRADIENTS \nsizex=textureSampleLevel(sizeGradientTexture,sizeGradientSampler,vec2<f32>(0.,0.),0.).r;\r#else\nsizex=params.sizeRange.x+(params.sizeRange.y-params.sizeRange.x)*randoms.g;\r#endif\nparticlesOut.particles[index].size=vec3<f32>(\rsizex,\rparams.scaleRange.x+(params.scaleRange.y-params.scaleRange.x)*randoms.b,\rparams.scaleRange.z+(params.scaleRange.w-params.scaleRange.z)*randoms.a);\r#ifndef COLORGRADIENTS\nparticlesOut.particles[index].color=params.color1+(params.color2-params.color1)*randoms.b;\r#endif\n#ifndef ANGULARSPEEDGRADIENTS \nparticlesOut.particles[index].angle=vec2<f32>(\rparams.angleRange.z+(params.angleRange.w-params.angleRange.z)*randoms.r,\rparams.angleRange.x+(params.angleRange.y-params.angleRange.x)*randoms.a);\r#else\nparticlesOut.particles[index].angle=params.angleRange.z+(params.angleRange.w-params.angleRange.z)*randoms.r;\r#endif \n#if defined(POINTEMITTER)\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);\rlet randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);\rnewPosition=vec3<f32>(0.,0.,0.);\rnewDirection=params.direction1+(params.direction2-params.direction1)*randoms3;\r#elif defined(BOXEMITTER)\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);\rlet randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);\rnewPosition=params.minEmitBox+(params.maxEmitBox-params.minEmitBox)*randoms2;\rnewDirection=params.direction1+(params.direction2-params.direction1)*randoms3; \r#elif defined(HEMISPHERICEMITTER)\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);\rlet randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);\rlet phi : f32=2.0*PI*randoms2.x;\rlet theta : f32=acos(-1.0+2.0*randoms2.y);\rlet randX : f32=cos(phi)*sin(theta);\rlet randY : f32=cos(theta);\rlet randZ : f32=sin(phi)*sin(theta);\rnewPosition=(params.radius-(params.radius*params.radiusRange*randoms2.z))*vec3<f32>(randX,abs(randY),randZ);\rnewDirection=normalize(newPosition+params.directionRandomizer*randoms3);\r#elif defined(SPHEREEMITTER)\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);\rlet randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);\rlet phi : f32=2.0*PI*randoms2.x;\rlet theta : f32=acos(-1.0+2.0*randoms2.y);\rlet randX : f32=cos(phi)*sin(theta);\rlet randY : f32=cos(theta);\rlet randZ : f32=sin(phi)*sin(theta);\rnewPosition=(params.radius-(params.radius*params.radiusRange*randoms2.z))*vec3<f32>(randX,randY,randZ);\r#ifdef DIRECTEDSPHEREEMITTER\nnewDirection=normalize(params.direction1+(params.direction2-params.direction1)*randoms3);\r#else\nnewDirection=normalize(newPosition+params.directionRandomizer*randoms3);\r#endif\n#elif defined(CYLINDEREMITTER)\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);\rlet randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);\rlet yPos : f32=(-0.5+randoms2.x)*params.height;\rvar angle : f32=randoms2.y*PI*2.;\rlet inverseRadiusRangeSquared : f32=(1.-params.radiusRange)*(1.-params.radiusRange);\rlet positionRadius : f32=params.radius*sqrt(inverseRadiusRangeSquared+randoms2.z*(1.-inverseRadiusRangeSquared));\rlet xPos : f32=positionRadius*cos(angle);\rlet zPos : f32=positionRadius*sin(angle);\rnewPosition=vec3<f32>(xPos,yPos,zPos);\r#ifdef DIRECTEDCYLINDEREMITTER\nnewDirection=params.direction1+(params.direction2-params.direction1)*randoms3;\r#else\nangle=angle+(-0.5+randoms3.x)*PI*params.directionRandomizer;\rnewDirection=vec3<f32>(cos(angle),(-0.5+randoms3.y)*params.directionRandomizer,sin(angle));\rnewDirection=normalize(newDirection);\r#endif\n#elif defined(CONEEMITTER)\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);\rlet s : f32=2.0*PI*randoms2.x;\r#ifdef CONEEMITTERSPAWNPOINT\nlet h : f32=0.0001;\r#else\nvar h : f32=randoms2.y*params.height.y;\rh=1.-h*h; \r#endif\nvar lRadius : f32=params.radius.x-params.radius.x*randoms2.z*params.radius.y;\rlRadius=lRadius*h;\rlet randX : f32=lRadius*sin(s);\rlet randZ : f32=lRadius*cos(s);\rlet randY : f32=h *params.height.x;\rnewPosition=vec3<f32>(randX,randY,randZ); \rif (abs(cos(params.coneAngle))==1.0) {\rnewDirection=vec3<f32>(0.,1.0,0.);\r} else {\rlet randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);\rnewDirection=normalize(newPosition+params.directionRandomizer*randoms3); \r}\r#elif defined(CUSTOMEMITTER)\nnewPosition=particlesIn.particles[index].initialPosition;\rparticlesOut.particles[index].initialPosition=newPosition;\r#else \nnewPosition=vec3<f32>(0.,0.,0.);\rnewDirection=2.0*(getRandomVec3(seed.w,vertexID)-vec3<f32>(0.5,0.5,0.5));\r#endif\nlet power : f32=params.emitPower.x+(params.emitPower.y-params.emitPower.x)*randoms.a;\r#ifdef LOCAL\nparticlesOut.particles[index].position=newPosition;\r#else\nparticlesOut.particles[index].position=(params.emitterWM*vec4<f32>(newPosition,1.)).xyz;\r#endif\n#ifdef CUSTOMEMITTER\nparticlesOut.particles[index].direction=direction;\r#ifndef BILLBOARD \nparticlesOut.particles[index].initialDirection=direction;\r#endif\n#else\n#ifdef LOCAL\nlet initial : vec3<f32>=newDirection;\r#else \nlet initial : vec3<f32>=(params.emitterWM*vec4<f32>(newDirection,0.)).xyz;\r#endif\nparticlesOut.particles[index].direction=initial*power;\r#ifndef BILLBOARD \nparticlesOut.particles[index].initialDirection=initial;\r#endif\n#endif\n#ifdef ANIMATESHEET \nparticlesOut.particles[index].cellIndex=params.cellInfos.x;\r#ifdef ANIMATESHEETRANDOMSTART\nparticlesOut.particles[index].cellStartOffset=randoms.a*outLife;\r#endif \n#endif\n#ifdef NOISE\nparticlesOut.particles[index].noiseCoordinates1=particlesIn.particles[index].noiseCoordinates1;\rparticlesOut.particles[index].noiseCoordinates2=particlesIn.particles[index].noiseCoordinates2;\r#endif\n} else {\rvar directionScale : f32=timeDelta;\rparticlesOut.particles[index].age=newAge;\rlet ageGradient : f32=newAge/life;\r#ifdef VELOCITYGRADIENTS\ndirectionScale=directionScale*textureSampleLevel(velocityGradientTexture,velocityGradientSampler,vec2<f32>(ageGradient,0.),0.).r;\r#endif\n#ifdef DRAGGRADIENTS\ndirectionScale=directionScale*(1.0-textureSampleLevel(dragGradientTexture,dragGradientSampler,vec2<f32>(ageGradient,0.),0.).r);\r#endif\nlet position : vec3<f32>=particlesIn.particles[index].position;\r#if defined(CUSTOMEMITTER)\nparticlesOut.particles[index].position=position+(direction-position)*ageGradient; \rparticlesOut.particles[index].initialPosition=particlesIn.particles[index].initialPosition;\r#else\nparticlesOut.particles[index].position=position+direction*directionScale;\r#endif\nparticlesOut.particles[index].life=life;\rparticlesOut.particles[index].seed=seed;\r#ifndef COLORGRADIENTS \nparticlesOut.particles[index].color=particlesIn.particles[index].color;\r#endif\n#ifdef SIZEGRADIENTS\nparticlesOut.particles[index].size=vec3<f32>(\rtextureSampleLevel(sizeGradientTexture,sizeGradientSampler,vec2<f32>(ageGradient,0.),0.).r,\rparticlesIn.particles[index].size.yz);\r#else\nparticlesOut.particles[index].size=particlesIn.particles[index].size;\r#endif \n#ifndef BILLBOARD \nparticlesOut.particles[index].initialDirection=particlesIn.particles[index].initialDirection;\r#endif\n#ifdef CUSTOMEMITTER\nparticlesOut.particles[index].direction=direction;\r#else\nvar updatedDirection : vec3<f32>=direction+params.gravity*timeDelta;\r#ifdef LIMITVELOCITYGRADIENTS\nlet limitVelocity : f32=textureSampleLevel(limitVelocityGradientTexture,limitVelocityGradientSampler,vec2<f32>(ageGradient,0.),0.).r;\rlet currentVelocity : f32=length(updatedDirection);\rif (currentVelocity>limitVelocity) {\rupdatedDirection=updatedDirection*params.limitVelocityDamping;\r}\r#endif\nparticlesOut.particles[index].direction=updatedDirection;\r#ifdef NOISE\nlet noiseCoordinates1 : vec3<f32>=particlesIn.particles[index].noiseCoordinates1;\rlet noiseCoordinates2 : vec3<f32>=particlesIn.particles[index].noiseCoordinates2;\rlet fetchedR : f32=textureSampleLevel(noiseTexture,noiseSampler,vec2<f32>(noiseCoordinates1.x,noiseCoordinates1.y)*vec2<f32>(0.5,0.5)+vec2<f32>(0.5,0.5),0.).r;\rlet fetchedG : f32=textureSampleLevel(noiseTexture,noiseSampler,vec2<f32>(noiseCoordinates1.z,noiseCoordinates2.x)*vec2<f32>(0.5,0.5)+vec2<f32>(0.5,0.5),0.).r;\rlet fetchedB : f32=textureSampleLevel(noiseTexture,noiseSampler,vec2<f32>(noiseCoordinates2.y,noiseCoordinates2.z)*vec2<f32>(0.5,0.5)+vec2<f32>(0.5,0.5),0.).r;\rlet force : vec3<f32>=vec3<f32>(-1.+2.*fetchedR,-1.+2.*fetchedG,-1.+2.*fetchedB)*params.noiseStrength;\rparticlesOut.particles[index].direction=particlesOut.particles[index].direction+force*timeDelta;\rparticlesOut.particles[index].noiseCoordinates1=noiseCoordinates1;\rparticlesOut.particles[index].noiseCoordinates2=noiseCoordinates2;\r#endif \n#endif \n#ifdef ANGULARSPEEDGRADIENTS\nlet angularSpeed : f32=textureSampleLevel(angularSpeedGradientTexture,angularSpeedGradientSampler,vec2<f32>(ageGradient,0.),0.).r;\rparticlesOut.particles[index].angle=particlesIn.particles[index].angle+angularSpeed*timeDelta;\r#else\nlet angle : vec2<f32>=particlesIn.particles[index].angle;\rparticlesOut.particles[index].angle=vec2<f32>(angle.x+angle.y*timeDelta,angle.y);\r#endif\n#ifdef ANIMATESHEET \nvar offsetAge : f32=particlesOut.particles[index].age;\rlet dist : f32=params.cellInfos.y-params.cellInfos.x;\r#ifdef ANIMATESHEETRANDOMSTART\nlet cellStartOffset : f32=particlesIn.particles[index].cellStartOffset;\rparticlesOut.particles[index].cellStartOffset=cellStartOffset;\roffsetAge=offsetAge+cellStartOffset;\r#else\nlet cellStartOffset : f32=0.;\r#endif \nvar ratio : f32;\rif (params.cellInfos.w==1.0) {\rratio=clamp(((cellStartOffset+params.cellInfos.z*offsetAge) % life)/life,0.,1.0);\r}\relse {\rratio=clamp((cellStartOffset+params.cellInfos.z*offsetAge)/life,0.,1.0);\r}\rparticlesOut.particles[index].cellIndex=f32(i32(params.cellInfos.x+ratio*dist));\r#endif\n}\r}\r`;\n// Sideeffect\nShaderStore.ShadersStoreWGSL[name] = shader;\n/** @hidden */\nexport const gpuUpdateParticlesComputeShader = { name, shader };\n"]}