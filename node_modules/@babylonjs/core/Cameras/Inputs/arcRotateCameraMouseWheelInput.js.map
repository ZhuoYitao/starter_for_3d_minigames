{"version":3,"file":"arcRotateCameraMouseWheelInput.js","sourceRoot":"","sources":["../../../../../../lts/core/generated/Cameras/Inputs/arcRotateCameraMouseWheelInput.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { EventState, Observer } from \"../../Misc/observable\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { Plane } from \"../../Maths/math.plane\";\r\nimport { Vector3, Matrix, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\nimport type { IWheelEvent } from \"../../Events/deviceInputEvents\";\r\nimport { EventConstants } from \"../../Events/deviceInputEvents\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\n\r\n/**\r\n * Firefox uses a different scheme to report scroll distances to other\r\n * browsers. Rather than use complicated methods to calculate the exact\r\n * multiple we need to apply, let's just cheat and use a constant.\r\n * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\r\n * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\r\n */\r\nconst ffMultiplier = 40;\r\n\r\n/**\r\n * Manage the mouse wheel inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nexport class ArcRotateCameraMouseWheelInput implements ICameraInput<ArcRotateCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * Gets or Set the mouse wheel precision or how fast is the camera zooming.\r\n     */\r\n    @serialize()\r\n    public wheelPrecision = 3.0;\r\n\r\n    /**\r\n     * Gets or Set the boolean value that controls whether or not the mouse wheel\r\n     * zooms to the location of the mouse pointer or not.  The default is false.\r\n     */\r\n    @serialize()\r\n    public zoomToMouseLocation = false;\r\n\r\n    /**\r\n     * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when wheel is used.\r\n     */\r\n    @serialize()\r\n    public wheelDeltaPercentage = 0;\r\n\r\n    /**\r\n     * If set, this function will be used to set the radius delta that will be added to the current camera radius\r\n     */\r\n    public customComputeDeltaFromMouseWheel: Nullable<(wheelDelta: number, input: ArcRotateCameraMouseWheelInput, event: IWheelEvent) => number> = null;\r\n\r\n    private _wheel: Nullable<(p: PointerInfo, s: EventState) => void>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _hitPlane: Nullable<Plane>;\r\n\r\n    protected _computeDeltaFromMouseWheelLegacyEvent(mouseWheelDelta: number, radius: number) {\r\n        let delta = 0;\r\n        const wheelDelta = mouseWheelDelta * 0.01 * this.wheelDeltaPercentage * radius;\r\n        if (mouseWheelDelta > 0) {\r\n            delta = wheelDelta / (1.0 + this.wheelDeltaPercentage);\r\n        } else {\r\n            delta = wheelDelta * (1.0 + this.wheelDeltaPercentage);\r\n        }\r\n        return delta;\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // was there a second variable defined?\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this._wheel = (p) => {\r\n            //sanity check - this should be a PointerWheel event.\r\n            if (p.type !== PointerEventTypes.POINTERWHEEL) {\r\n                return;\r\n            }\r\n            const event = <IWheelEvent>p.event;\r\n            let delta = 0;\r\n\r\n            const mouseWheelLegacyEvent = event as any;\r\n            let wheelDelta = 0;\r\n\r\n            const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? ffMultiplier : 1; // If this happens to be set to DOM_DELTA_LINE, adjust accordingly\r\n            if (event.deltaY !== undefined) {\r\n                wheelDelta = -(event.deltaY * platformScale);\r\n            } else if ((<any>event).wheelDeltaY !== undefined) {\r\n                wheelDelta = -((<any>event).wheelDeltaY * platformScale);\r\n            } else {\r\n                wheelDelta = mouseWheelLegacyEvent.wheelDelta;\r\n            }\r\n\r\n            if (this.customComputeDeltaFromMouseWheel) {\r\n                delta = this.customComputeDeltaFromMouseWheel(wheelDelta, this, event);\r\n            } else {\r\n                if (this.wheelDeltaPercentage) {\r\n                    delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, this.camera.radius);\r\n\r\n                    // If zooming in, estimate the target radius and use that to compute the delta for inertia\r\n                    // this will stop multiple scroll events zooming in from adding too much inertia\r\n                    if (delta > 0) {\r\n                        let estimatedTargetRadius = this.camera.radius;\r\n                        let targetInertia = this.camera.inertialRadiusOffset + delta;\r\n                        for (let i = 0; i < 20 && Math.abs(targetInertia) > 0.001; i++) {\r\n                            estimatedTargetRadius -= targetInertia;\r\n                            targetInertia *= this.camera.inertia;\r\n                        }\r\n                        estimatedTargetRadius = Scalar.Clamp(estimatedTargetRadius, 0, Number.MAX_VALUE);\r\n                        delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, estimatedTargetRadius);\r\n                    }\r\n                } else {\r\n                    delta = wheelDelta / (this.wheelPrecision * 40);\r\n                }\r\n            }\r\n\r\n            if (delta) {\r\n                if (this.zoomToMouseLocation && this._hitPlane) {\r\n                    this._zoomToMouse(delta);\r\n                } else {\r\n                    this.camera.inertialRadiusOffset += delta;\r\n                }\r\n            }\r\n\r\n            if (event.preventDefault) {\r\n                if (!noPreventDefault) {\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera.getScene().onPointerObservable.add(this._wheel, PointerEventTypes.POINTERWHEEL);\r\n\r\n        if (this.zoomToMouseLocation) {\r\n            this._inertialPanning.setAll(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene().onPointerObservable.remove(this._observer);\r\n            this._observer = null;\r\n            this._wheel = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (!this.zoomToMouseLocation) {\r\n            return;\r\n        }\r\n\r\n        const camera = this.camera;\r\n        const motion = 0.0 + camera.inertialAlphaOffset + camera.inertialBetaOffset + camera.inertialRadiusOffset;\r\n        if (motion) {\r\n            // if zooming is still happening as a result of inertia, then we also need to update\r\n            // the hit plane.\r\n            this._updateHitPlane();\r\n\r\n            // Note we cannot  use arcRotateCamera.inertialPlanning here because arcRotateCamera panning\r\n            // uses a different panningInertia which could cause this panning to get out of sync with\r\n            // the zooming, and for this to work they must be exactly in sync.\r\n            camera.target.addInPlace(this._inertialPanning);\r\n            this._inertialPanning.scaleInPlace(camera.inertia);\r\n            this._zeroIfClose(this._inertialPanning);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mousewheel\";\r\n    }\r\n\r\n    private _updateHitPlane() {\r\n        const camera = this.camera;\r\n        const direction = camera.target.subtract(camera.position);\r\n        this._hitPlane = Plane.FromPositionAndNormal(camera.target, direction);\r\n    }\r\n\r\n    // Get position on the hit plane\r\n    private _getPosition(): Vector3 {\r\n        const camera = this.camera;\r\n        const scene = camera.getScene();\r\n\r\n        // since the _hitPlane is always updated to be orthogonal to the camera position vector\r\n        // we don't have to worry about this ray shooting off to infinity. This ray creates\r\n        // a vector defining where we want to zoom to.\r\n        const ray = scene.createPickingRay(scene.pointerX, scene.pointerY, Matrix.Identity(), camera, false);\r\n        let distance = 0;\r\n        if (this._hitPlane) {\r\n            distance = ray.intersectsPlane(this._hitPlane) ?? 0;\r\n        }\r\n\r\n        // not using this ray again, so modifying its vectors here is fine\r\n        return ray.origin.addInPlace(ray.direction.scaleInPlace(distance));\r\n    }\r\n\r\n    private _inertialPanning: Vector3 = Vector3.Zero();\r\n\r\n    private _zoomToMouse(delta: number) {\r\n        const camera = this.camera;\r\n        const inertiaComp = 1 - camera.inertia;\r\n        if (camera.lowerRadiusLimit) {\r\n            const lowerLimit = camera.lowerRadiusLimit ?? 0;\r\n            if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp < lowerLimit) {\r\n                delta = (camera.radius - lowerLimit) * inertiaComp - camera.inertialRadiusOffset;\r\n            }\r\n        }\r\n        if (camera.upperRadiusLimit) {\r\n            const upperLimit = camera.upperRadiusLimit ?? 0;\r\n            if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp > upperLimit) {\r\n                delta = (camera.radius - upperLimit) * inertiaComp - camera.inertialRadiusOffset;\r\n            }\r\n        }\r\n\r\n        const zoomDistance = delta / inertiaComp;\r\n        const ratio = zoomDistance / camera.radius;\r\n        const vec = this._getPosition();\r\n\r\n        // Now this vector tells us how much we also need to pan the camera\r\n        // so the targeted mouse location becomes the center of zooming.\r\n\r\n        const directionToZoomLocation = TmpVectors.Vector3[6];\r\n        vec.subtractToRef(camera.target, directionToZoomLocation);\r\n        directionToZoomLocation.scaleInPlace(ratio);\r\n        directionToZoomLocation.scaleInPlace(inertiaComp);\r\n        this._inertialPanning.addInPlace(directionToZoomLocation);\r\n\r\n        camera.inertialRadiusOffset += delta;\r\n    }\r\n\r\n    // Sets x y or z of passed in vector to zero if less than Epsilon.\r\n    private _zeroIfClose(vec: Vector3) {\r\n        if (Math.abs(vec.x) < Epsilon) {\r\n            vec.x = 0;\r\n        }\r\n        if (Math.abs(vec.y) < Epsilon) {\r\n            vec.y = 0;\r\n        }\r\n        if (Math.abs(vec.z) < Epsilon) {\r\n            vec.z = 0;\r\n        }\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"ArcRotateCameraMouseWheelInput\"] = ArcRotateCameraMouseWheelInput;\r\n"]}